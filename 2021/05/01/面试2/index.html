<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试题 | MyHomePage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Spring是什么?轻量级的开源的J2EE框架。它是一个容器框架，用来装javabean (java对象)，中间层框架（万能胶)可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁  Spring是一个轻量级的控制反转(loC)和面向切面(AOP)的容器框架 从大小与开销两方面而言Spring都是轻量级的。 通过控制反转(IoC)的技术达到松">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://example.com/2021/05/01/%E9%9D%A2%E8%AF%952/index.html">
<meta property="og:site_name" content="MyHomePage">
<meta property="og:description" content="Spring是什么?轻量级的开源的J2EE框架。它是一个容器框架，用来装javabean (java对象)，中间层框架（万能胶)可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁  Spring是一个轻量级的控制反转(loC)和面向切面(AOP)的容器框架 从大小与开销两方面而言Spring都是轻量级的。 通过控制反转(IoC)的技术达到松">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdn.net/20180803145042704?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxOTEyMjA=">
<meta property="og:image" content="c:/Users/hp/AppData/Roaming/Typora/typora-user-images/image-20210516214833845.png">
<meta property="og:image" content="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517162629444.png">
<meta property="og:image" content="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517162818524.png">
<meta property="og:image" content="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517172428904.png">
<meta property="article:published_time" content="2021-04-30T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-15T13:22:59.249Z">
<meta property="article:author" content="Lee yunbo">
<meta property="article:tag" content="Java、面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20180803145042704?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxOTEyMjA=">
  
    <link rel="alternate" href="/atom.xml" title="MyHomePage" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MyHomePage</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/01/%E9%9D%A2%E8%AF%952/" class="article-date">
  <time class="dt-published" datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试题
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么?"></a>Spring是什么?</h1><p>轻量级的开源的J2EE框架。它是一个容器框架，用来装javabean (java对象)，中间层框架（万能胶)可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁</p>
<ul>
<li>Spring是一个轻量级的控制反转(loC)和面向切面(AOP)的容器框架</li>
<li>从大小与开销两方面而言Spring都是轻量级的。</li>
<li>通过控制反转(IoC)的技术达到松耦合的目的</li>
<li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发</li>
<li>包含并管理应用对象(Bean)的配置和生命周期;这个意义上是一个容器。</li>
<li>将简单的组件配置、组合成为复杂的应用，这个意义上是一个框架。</li>
</ul>
<h1 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h1><p>容器概念、控制反转、依赖注入</p>
<p><strong>ioc容器:</strong><br>实际上就是个map (key,value)，里面存的是各种对象（在xml里配置的bean节点、@repository,@service、@controller、@component)，在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。<br>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入(autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入;id就是对象名）。</p>
<p><strong>控制反转:</strong><br>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建—个对象B注入到对象A需要的地方。<br>通过前后的对比，不难看出来:对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。<br>全部对象的控制权全部上缴给”第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成”粘合剂”的由来。</p>
<p><strong>依赖注入:</strong><br>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<h1 id="谈谈你对AOP的理解"><a href="#谈谈你对AOP的理解" class="headerlink" title="谈谈你对AOP的理解"></a>谈谈你对AOP的理解</h1><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</p>
<p>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</p>
<p>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP:将程序中的交叉业务逻辑（比如安全，日志，事务等)，封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</p>
<h1 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别?"></a>BeanFactory和ApplicationContext有什么区别?</h1><p>ApplicationContext是BeanFactory的子接口<br>ApplicationContext提供了更完整的功能:<br>    ①继承MessageSource，因此支持国际化。<br>    ②统一的资源文件访问方式。<br>    ③提供在监听器中注册bean的事件。<br>    ④同时加载多个配置文件。<br>    ⑤载入多个(有继承关系)上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>区别：<br>1、BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。<br>2、ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。<br>3、相对于基本的BeanFactory，ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。<br>4、BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。<br>5、BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用, 但两者之间的区别是:BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h1 id="描述一下Spring-Bean的生命周期"><a href="#描述一下Spring-Bean的生命周期" class="headerlink" title="描述一下Spring Bean的生命周期?"></a>描述一下Spring Bean的生命周期?</h1><p>01、解析类得到BeanDefinition<br>02、如果有多个构造方法，则要推断构造方法<br>03、确定好构造方法后，进行实例化得到一个对象<br>04、为对象中的加了@Autowired注解的属性进行属性填充<br>05、回调Aware方法，比如BeanNameAware，BeanFactoryAware<br>06、调用BeanPostProcessor的初始化前的方法<br>07、调用初始化方法<br>08、调用BeanPostProcessor的初始化后的方法，在这里会进行AOP<br>09、如果当前创建的bean是单例的则会把bean放入单例池<br>10、使用bean<br>11、Spring容器关闭时调用DisposableBean中destory()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、实例化 Instantiation</span><br><span class="line">2、属性赋值 Populate</span><br><span class="line">3、初始化 Initialization</span><br><span class="line">4、销毁 Destruction</span><br><span class="line"></span><br><span class="line">1、Spring对bean进行实例化；</span><br><span class="line">2、Spring将值和bean的引用注入到bean对应的属性中；</span><br><span class="line">3、如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</span><br><span class="line">4、如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</span><br><span class="line">5、如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</span><br><span class="line">6、如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</span><br><span class="line">7、如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</span><br><span class="line">8、如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</span><br><span class="line">9、此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</span><br><span class="line">10、如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</span><br></pre></td></tr></table></figure>



<h1 id="解释下Spring支持的几种bean的作用域。"><a href="#解释下Spring支持的几种bean的作用域。" class="headerlink" title="解释下Spring支持的几种bean的作用域。"></a>解释下Spring支持的几种bean的作用域。</h1><ul>
<li>singleton:默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建)。</li>
<li>prototype:为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象</li>
<li>request: bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。</li>
<li>session:与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>
<li>application: bean被定义为在ServletContext的生命周期中复用一个单例对象。</li>
<li>websocket: bean被定义为在websocket的生命周期中复用一个单例对象。</li>
</ul>
<p>global-session:全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p>
<h1 id="Spring框架中的单例Bean是线程安全的么"><a href="#Spring框架中的单例Bean是线程安全的么" class="headerlink" title="Spring框架中的单例Bean是线程安全的么?"></a>Spring框架中的单例Bean是线程安全的么?</h1><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。</p>
<p>如果Bean是有状态的那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域把”singleton”改为”protopyte”这样每次请求Bean就相当于是new Bean()这样就可以保证线程的安全了。</p>
<ul>
<li>有状态就是有数据存储功能</li>
<li>无状态就是不会保存数据    controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</li>
</ul>
<p>Dao会操作数据库Connection，Connection是带有状态的，比如说数据库事务，Spring的事务管理器使用Threadlocal为不同线程维护了一套独立的connection副本，保证线程之间不会互相影响(Spring是如何保证事务获取同一个Connection的)</p>
<p>不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法了。</p>
<h1 id="Spring框架中都用到了哪些设计模式"><a href="#Spring框架中都用到了哪些设计模式" class="headerlink" title="Spring框架中都用到了哪些设计模式?"></a>Spring框架中都用到了哪些设计模式?</h1><p>简单工厂:由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p>
<blockquote>
<p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>
</blockquote>
<p>工厂方法:</p>
<blockquote>
<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getobject()方法，所以返回的不是factory这个bean，而是这个bean.getojbect()方法的返回值。</p>
</blockquote>
<p>单例模式:保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<blockquote>
<p>spring对单例的实现: spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</p>
</blockquote>
<p>适配器模式:</p>
<blockquote>
<p>spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVc的扩展了。</p>
</blockquote>
<p>装饰器模式:动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p>
<blockquote>
<p>spring中用到的包装器模式在类名上有两种表现:一种是类名中含有wrapper，另一种是类名中含有Decorator。</p>
</blockquote>
<p>动态代理:</p>
<blockquote>
<p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AoP容器会为目标对象创建动态的创建一个代理对象。springAOP就是以这种方式织入切面的。<br>织入:把切面应用到目标对象并创建新的代理对象的过程。</p>
</blockquote>
<p>观察者模式:</p>
<blockquote>
<p>spring的事件驱动模型使用的是观察者模式，Spring中observer模式常用的地方是listener的实现。</p>
</blockquote>
<p>策略模式:</p>
<blockquote>
<p>spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring框架本身大量使用了Resource接口来访问底层资源。</p>
</blockquote>
<h1 id="Spring事务的实现方式和原理以及隔离级别"><a href="#Spring事务的实现方式和原理以及隔离级别" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别?"></a>Spring事务的实现方式和原理以及隔离级别?</h1><p>在使用Spring框架时，可以有两种使用事务的方式，一种是<strong>编程式</strong>的，一种是<strong>申明式</strong>的，@Transactional注解就是申明式的。</p>
<p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。</p>
<p>比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统—成功或失败。</p>
<p>在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。</p>
<p>当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。</p>
<p>spring事务隔离级别就是数据库的隔离级别:外加一个默认级别</p>
<ul>
<li>read uncommitted(未提交读)</li>
<li>read committed (提交读、不可重复读)</li>
<li>repeatable read(可重复读)</li>
<li>serializable (可串行化)</li>
</ul>
<p>数据库的配置隔离级别是Read commited , 而Spring配置的隔离级别是Repeatable Read，请问这时隔离级别是以哪一个为准?<br>    以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库</p>
<h1 id="说一下Spring的事务机制"><a href="#说一下Spring的事务机制" class="headerlink" title="说一下Spring的事务机制"></a>说一下Spring的事务机制</h1><p>1.Spring事务底层是基于数据库事务和AOP机制的</p>
<p>2.首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean</p>
<p>3.当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解</p>
<p>4.如果加了，那么则利用事务管理器创建一个数据库连接</p>
<p>5.并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步</p>
<p>6.然后执行当前方法，方法中会执行sql</p>
<p>7.执行完当前方法后，如果没有出现异常就直接提交事务</p>
<p>8.如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</p>
<p>9.Spring事务的隔离级别对应的就是数据库的隔离级别</p>
<p>10.Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的</p>
<p>11.spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制衙置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据<br>库连接上执行sql</p>
<h1 id="spring事务传播机制"><a href="#spring事务传播机制" class="headerlink" title="spring事务传播机制"></a>spring事务传播机制</h1><p>多个事务方法相互调用时,事务如何在这些方法间传播</p>
<blockquote>
<p>方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</p>
</blockquote>
<p>REQUIRED(Spring默认的事务传播类型):如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</p>
<p>SUPPORTS:当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</p>
<p>MANDATORY:当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</p>
<p>REQUIRES_NEW:创建一个新事务，如果存在当前事务，则挂起该事务。</p>
<p>NOT_SUPPORTED:以非事务方式执行,如果当前存在事务，则挂起当前事务</p>
<p>NEVER:不使用事务，如果当前事务存在，则抛出异常</p>
<p>NESTED:如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样(开启一个事务)</p>
<blockquote>
<p>和IREQUIRES_NEW的区别<br>REQUIRES_NEWw是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时〈我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务)。在NESTED情况下父事务回滚时，子事务也会回滚，而在REQUIRES_NEw情况下，原有事务回滚，不会影响新开启的事务。</p>
<p>和REQUIRED的区别<br>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚。而在NESTED况下，被调用方发生异常时，调用方可以catch其异常，这样具有子事务回滚，父事务不受影响</p>
</blockquote>
<h1 id="spring事务什么时候会失效"><a href="#spring事务什么时候会失效" class="headerlink" title="spring事务什么时候会失效?"></a>spring事务什么时候会失效?</h1><p>Spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了!</p>
<p>常见情况有如下几种</p>
<p>1、发生自调用，类里面使用this调用本类的方法（this通常省略)，此时这个this对象不是代理类，而是UserService对象本身!<br>    解决方法很简单，让那个this变成UserService的代理类即可!</p>
<p>2、方法不是public的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactiona1只能用于 public的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启Aspectj代理模式。</span><br></pre></td></tr></table></figure>

<p>3、数据库不支持事务</p>
<p>4、没有被spring管理</p>
<p>5、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)</p>
<h1 id="什么是bean的自动装配，有哪些方式"><a href="#什么是bean的自动装配，有哪些方式" class="headerlink" title="什么是bean的自动装配，有哪些方式?"></a>什么是bean的自动装配，有哪些方式?</h1><p>开启自动装配，只需要在xml配置文件&#x3D;&#x3D;<bean>&#x3D;&#x3D;中定义”autowire”属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;cutomer&quot; c1ass=&quot;com.xxx.xxx.Customer&quot; autowire=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>autowire属性有五种装配的方式:</p>
<p>no-缺省情况下，自动配置是通过”ref”属性手动设定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手动装配:以value或ref的方式明确指定属性值都是手动装配。</span><br><span class="line">需要通过‘ref&#x27;属性来连接bean。</span><br></pre></td></tr></table></figure>

<p>byName-根据bean的属性名称进行自动装配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id=&quot;cutomer&quot; c1ass=&quot;com.xxx.xxx.Cutomer&quot; autowire=&quot;byName&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;person&quot; c1ass=&quot;com.xxx.xxx.Person&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>byType-根据bean的类型进行自动装配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id=&quot;cutomer&quot; class=&quot;com.xxx.xxx.cutomer&quot; autowire=&quot;byType&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;person&quot; class=&quot;com.xxx.xxx.Person&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>construltor-类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型形同，则进行自动装配，否则导致异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cutomer构造函数的参数person的类型为Person，spirng会将Person类型通过构造方法进行自动装配。</span><br><span class="line">&lt;bean id=&quot;cutomer&quot; class=&quot;com.xxx.xxx.Cutomer&quot; autowire=&quot;construtor&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;person&quot; c1ass=&quot;com.xxx.xxx.Person&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>autodetect-如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</span><br></pre></td></tr></table></figure>

<p>@Autowired自动装配bean，可以在字段、 setter方法、构造函数上使用。</p>
<h1 id="Spring-Boot、Spring-MVC和Spring-有什么区别"><a href="#Spring-Boot、Spring-MVC和Spring-有什么区别" class="headerlink" title="Spring Boot、Spring MVC和Spring 有什么区别"></a>Spring Boot、Spring MVC和Spring 有什么区别</h1><p><strong>spring</strong>是一个lOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</p>
<p><strong>springmvc</strong>是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet，用来接收请求，然后定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端</p>
<p><strong>springboot</strong>是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc应用，简化了配置(约定了默认配置)，整合了一系列的解决方案(starter机制) 、 redis、mongodb、es，可以开箱即用</p>
<h1 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h1><ol>
<li><p>用户发送请求至前端控制器DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 收到请求调用HandlerMapping处理器映射器。</p>
</li>
<li><p>处理器映射器找到具体的处理器(可以根据 xml配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)—并返回给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 调用HandlerAdapter处理器适配器。</p>
</li>
<li><p>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)</p>
</li>
<li><p>Controller执行完成返回ModelAndView。</p>
</li>
<li><p>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServiet。</p>
</li>
<li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>
</li>
<li><p>ViewReslover解析后返回具体View。</p>
</li>
<li><p>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。</p>
</li>
<li><p>DispatcherServlet响应用户。</p>
</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180803145042704?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxOTEyMjA=" alt="img"></p>
<h1 id="Spring-MVC的主要组件"><a href="#Spring-MVC的主要组件" class="headerlink" title="Spring MVC的主要组件?"></a>Spring MVC的主要组件?</h1><p>Handler:也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler</p>
<p><strong>1、HandlerMapping(主要)</strong><br>initHandlerMappings(context)，处理器映射器，根据用户请求的资源uri来查找Handler的。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行，这就是<br>HandlerMapping需要做的事。</p>
<p><strong>2、HandlerAdapter（主要）</strong><br>initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的servlet处理方法调用灵活的Handler来进行处理呢?这就是HandlerAdapter要做的事情。<br>Handler是用来干活的工具;HandlerMapping用于根据需要干的活找到相应的工具;HandlerAdapter是使用工具干活的人。</p>
<p>3、HandlerExceptionResolver<br>initHandlerExceptionResolvers(context)，其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢?这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是<br>HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。</p>
<p>4、ViewResolver<br>initviewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。Vview是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html(也可能是其它类型)文件。这里就有两个关键问题:使用哪个模板?用什么技术(规则)填入参数?这其实是ViewResolver主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型)进行渲染，具体的渲染过程则交由不同的视图自己完成</p>
<p>5、RequestToViewNameTranslator<br>initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。</p>
<p>6、LocaleResolver<br>initLocaleResolver(context)，解析视图需要两个参数:一是视图名，另一个是Locale。视图名是处理器返回的,Locale是从哪里来的?这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale,Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale:一是ViewResolver视图解析的时候;二是用到国际化资源或者主题的时候。</p>
<p>7、ThemeResolver<br>initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。</p>
<p>8、MultipartResolver<br>initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的request包装成<br>MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</p>
<p>9、FlashMapManager<br>initFlashMapManager(context)，用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</p>
<h1 id="Spring-Boot自动配置原理-高频考点"><a href="#Spring-Boot自动配置原理-高频考点" class="headerlink" title="Spring Boot自动配置原理?(高频考点)"></a>Spring Boot自动配置原理?(高频考点)</h1><p>@lmport +@Configuration + Spring spi</p>
<p>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META-INF&#x2F;spring.factories下使用Spring spi扫描META-INF&#x2F;spring.factories下的配置类</p>
<p>使用@Import导入自动配置类</p>
<p><img src="C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210516214833845.png" alt="image-20210516214833845"></p>
<h1 id="如何理解-Spring-Boot中的Starter"><a href="#如何理解-Spring-Boot中的Starter" class="headerlink" title="如何理解 Spring Boot中的Starter"></a>如何理解 Spring Boot中的Starter</h1><p>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</p>
<p>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在starter包的META-INF&#x2F;spring.factories中写入该配置类，springboot会按照约定来加载该配置类</p>
<p>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置)<br>就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot–starter，spring-boot-starter-redis</p>
<h1 id="什么是嵌入式服务器-为什么要使用嵌入式服务器"><a href="#什么是嵌入式服务器-为什么要使用嵌入式服务器" class="headerlink" title="什么是嵌入式服务器?为什么要使用嵌入式服务器?"></a>什么是嵌入式服务器?为什么要使用嵌入式服务器?</h1><p>节省了下载安装tomcat，应用也不需要再打war包，然后放到webapp目录下再运行</p>
<p>只需要一个安装了Java的虚拟机，就可以直接在上面部署应用程序了</p>
<p>springboot已经内置了tomcat.jar，运行main方法时会去启动tomcat，并利用tomcat的spi机制加载springmvc</p>
<h1 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h1><p>优点:</p>
<p>1、基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在XML里，解除sql与程序代码的耦合，便于统一管理; 提供XML标签，支持编写动态SQL语句，并可重用。</p>
<p>2、与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接;</p>
<p>3、很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要DBC支持的数据库MyBatis都支持)。</p>
<p>4、能够与Spring很好的集成;</p>
<p>5、提供映射标签，支持对象与数据库的ORM字段关系映射;提供对象关系映射标签，支持对象关系组件维护。</p>
<p>缺点:</p>
<p>1、SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>2、SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h1 id="MyBatis-与Hibernate有哪些不同"><a href="#MyBatis-与Hibernate有哪些不同" class="headerlink" title="MyBatis 与Hibernate有哪些不同?"></a>MyBatis 与Hibernate有哪些不同?</h1><p>SQL和ORM的争论，永远都不会终止</p>
<p><strong>开发速度</strong>的对比:<br>Hibernate的真正掌握要比Mybatis难些。Mybatis框架相对简单很容易上手，但也相对简陋些。<br>比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如:一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。</p>
<p><strong>开发工作量</strong>的对比:<br>Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射,可以更专注于业务流程</p>
<p><strong>sql优化</strong>方面:<br>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。</p>
<p>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p>
<p>对象管理的对比:<br>Hibernate是完整的对象&#x2F;关系映射解决方案，它提供了对象状态管理(state management)的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的JDBC&#x2F;SQL持久层方案中需要管理SQL语句，Hibernate采用了更自然的面向对象的视角来持久化Java应用中的数据。<br>换句话说，使用Hibernate的开发者应该总是关注对象的状态（state)，不必考虑SQL语句的执行。这部分细节已经由 Hibernate掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p>
<p>缓存机制对比:<br>相同点:都可以实现自己的缓存或使用其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</p>
<p>不同点: Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是哪种缓存。</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>两者比较:因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>
<p>而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>Hibernate功能强大数据库无关性好，O&#x2F;R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。</p>
<p>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O&#x2F;R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。</p>
<p>MYBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。</p>
<p>MYBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</p>
<h1 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么?"></a>#{}和${}的区别是什么?</h1><p>#{}是预编译处理、是占位符，${}是字符串替换、是拼接符。<br>Mybatis在处理&#x3D;&#x3D;#{}&#x3D;&#x3D;时，会将sql中的&#x3D;&#x3D;#{}&#x3D;&#x3D;替换为?号，调用PreparedStatement来赋值;</p>
<p>Mybatis在处理&#x3D;&#x3D;${}&#x3D;&#x3D;时，就是把&#x3D;&#x3D;${}&#x3D;&#x3D;替换成变量的值，调用Statement来赋值;</p>
<p>#{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号</p>
<p>&#x3D;&#x3D;${}&#x3D;&#x3D;的变量替换是在DBMS外、变量替换后，&#x3D;&#x3D;${}&#x3D;&#x3D;对应的变量不会加上单引号</p>
<p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h1 id="简述Mybatis的插件运行原理，如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，如何编写一个插件。"></a>简述Mybatis的插件运行原理，如何编写一个插件。</h1><p>答: Mybatis 只支持针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的 invoke()方法，拦截那些你指定需要拦截的方法。</p>
<p>编写插件:实现Mybatis 的 Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，在配置文件中配置编写的插件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">    @Signature(type = StatementHandler.c1ass，method = &quot;query&quot;,</span></span><br><span class="line"><span class="meta">               args =&#123;Statement.class, ResultHandler.class]),</span></span><br><span class="line"><span class="meta">	@signature(type = StatementHandler.c1ass，method = &quot;update&quot;,</span></span><br><span class="line"><span class="meta">               args =&#123;Statement.class&#125;,</span></span><br><span class="line"><span class="meta">	@signature(type = StatementHand1er.c1ass，method = &quot;batch&quot;,,</span></span><br><span class="line"><span class="meta">               args = &#123;Statement.c1ass &#125;)</span></span><br><span class="line"><span class="meta">               &#125;)</span></span><br><span class="line"><span class="meta">@component</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">invocation.proceed()执行具体的业务逻辑</span></span><br></pre></td></tr></table></figure>

<h1 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h1><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理:就是把无序的数据变成有序的查询</p>
<ol>
<li><p>把创建了索引的列的内容进行排序</p>
</li>
<li><p>对排序结果生成倒排表</p>
</li>
<li><p>在倒排表内容上拼上数据地址链</p>
</li>
<li><p>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p>
</li>
</ol>
<h1 id="mysql聚簇和非聚簇索引的区别"><a href="#mysql聚簇和非聚簇索引的区别" class="headerlink" title="mysql聚簇和非聚簇索引的区别"></a>mysql聚簇和非聚簇索引的区别</h1><p>都是B+树的数据结构</p>
<ul>
<li>聚簇索引:将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即:只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</li>
<li>非聚簇索引:叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本书的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优势:</span><br><span class="line">1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高</span><br><span class="line">2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的</span><br><span class="line">3、聚簇索引适合用在排序的场合，非聚簇索引不适合</span><br><span class="line"></span><br><span class="line">劣势:</span><br><span class="line">1、维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片</span><br><span class="line">2、表因为使用UUId(随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键</span><br><span class="line">3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值;过长的主键值，会导致非叶子节点占用占用更多的物理空间</span><br></pre></td></tr></table></figure>

<p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏ijd来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>MyISAM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p>如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小,这些操作是需要在内存中完成的。</p>
<h1 id="mysql索引的数据结构，各自优劣"><a href="#mysql索引的数据结构，各自优劣" class="headerlink" title="mysql索引的数据结构，各自优劣"></a>mysql索引的数据结构，各自优劣</h1><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，InnoDB存储引擎的默认索引实现为:B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快; 其余大部分场景，建议选择B+Tree索引。</p>
<p>B+树:<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517162629444.png" alt="image-20210517162629444"></p>
<p>哈希索引:<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快</p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517162818524.png" alt="image-20210517162818524"></p>
<p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值;前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据;</p>
<p>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索;</p>
<p>哈希索引也没办法利用索引完成排序，以及like ‘xxx%’这样的部分模糊查询(这种部分模糊查询，其实本质上也是范围查询);</p>
<p>哈希索引也不支持多列联合索引的最左匹配规则;</p>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。</p>
<h1 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则?"></a>索引设计的原则?</h1><p>查询更快、占用空间更小</p>
<ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、 image和bit的数据类型的列不要建立索引。</li>
</ol>
<h1 id="锁的类型有哪些"><a href="#锁的类型有哪些" class="headerlink" title="锁的类型有哪些"></a>锁的类型有哪些</h1><p>基于锁的属性分类: 共享锁、排他锁。</p>
<p>基于锁的粒度分类: 行级锁(INNODB)、表级锁(INNODB、MYISAM)、页级锁(BDB引擎)、记录锁、间隙锁、临键锁。</p>
<p>基于锁的状态分类: 意向共享锁、意向排它锁。</p>
<p>共享锁(Share Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共享锁又称读锁，简称S锁;当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</span><br></pre></td></tr></table></figure>

<p>排他锁(exclusive Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排他锁又称写锁，简称X锁;当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。</span><br></pre></td></tr></table></figure>

<p>表锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问;</span><br><span class="line">特点:粒度大，加锁简单，容易冲突;</span><br></pre></td></tr></table></figure>

<p>行锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问;</span><br><span class="line">特点:粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高;</span><br></pre></td></tr></table></figure>

<p>记录锁(Record Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。</span><br><span class="line">精准条件命中，并且命中的条件字段是唯一索引</span><br><span class="line">加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</span><br></pre></td></tr></table></figure>

<p>页锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</span><br><span class="line">特点:开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般</span><br></pre></td></tr></table></figure>

<p>间隙锁(Gap Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属于行锁中的一种，间隙锁是在事务加锁后其锁化的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。</span><br><span class="line">范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。</span><br><span class="line">触发条件:防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。</span><br><span class="line"></span><br><span class="line">比如表里面的数据ID为1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间(-n代表负无穷大，n代表正无穷大&gt;</span><br><span class="line">选择语言</span><br></pre></td></tr></table></figure>

<p>临建锁(Next-Key Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住</span><br><span class="line">触发条件:范围查询并命中，查询命中了索引。</span><br><span class="line">结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插</span><br><span class="line">入。</span><br></pre></td></tr></table></figure>



<p><strong>如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。</strong></p>
<p>意向共享锁</p>
<p>当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。</p>
<p>意向排他锁</p>
<p>当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。</p>
<h1 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h1><p>事务基本特性ACID分别是:</p>
<p><strong>原子性</strong>指的是一个事务中的操作要么全部成功，要么全部失败。</p>
<p><strong>一致性</strong>指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B 100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证</p>
<p><strong>隔离性</strong>指的是一个事务的修改在最终提交前，对其他事务是不可见的。</p>
<p><strong>持久性</strong>指的是一旦事务提交，所做的修改就会永久保存到数据库中。</p>
<p>隔离性有4个隔离级别，分别是:</p>
<ul>
<li>read uncommit读未提交，可能会读到其他事务未提交的数据，也叫做脏读。</li>
</ul>
<p>  用户本来应该读取到id&#x3D;1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age&#x3D;20，这就是脏读。</p>
<ul>
<li><p>read commit读已提交，两次读取结果不一致，叫做不可重复读。</p>
<p>不可重复读解决了脏读的问题，他只会读取已经提交的事务。</p>
<p>用户开启事务读取id&#x3D;1用户，查询到age&#x3D;10，再次读取发现结果&#x3D;20，在同一个事务里同一个查询读取到不同</p>
</li>
<li><p>repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</p>
</li>
<li><p>serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</p>
</li>
</ul>
<p>脏读(Drity Read):某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<h1 id="关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过"><a href="#关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过" class="headerlink" title="关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?"></a>关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?</h1><p>在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>
<p>慢查询的优化首先要搞明白慢的原因是什么?是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?</p>
<p>所以优化也是针对这三个方向来的，</p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h1 id="ACID靠什么保证的"><a href="#ACID靠什么保证的" class="headerlink" title="ACID靠什么保证的?"></a>ACID靠什么保证的?</h1><p>A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sqlC一致性由其他三大特性保证、程序代码要保证业务上的一致性<br>l隔离性由MVCC来保证</p>
<p>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redolog恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnoDB redo log写盘，InnoDB事务进入 prepare状态。</span><br><span class="line">如果前面 prepare成功，bin1og写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么、InnoDB事务则进入commit 状态(在 redo log里面写一个commit记录)</span><br></pre></td></tr></table></figure>

<p>redolog的刷盘会在系统空闲时进行</p>
<h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><p>多版本并发控制:读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链</p>
<p>MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容,因为READ UNCOMMITTED总是读取最新的数据行,而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>
<p>聚簇索引记录中有两个必要的隐藏列:</p>
<p>trx_id: 用来存储每次对某条聚簇索引记录进行修改的时候的事务id。 </p>
<p>roll _pointer:   每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
<p><strong>已提交读和可重复读的区别就在于它们生成Readview的策略不同。</strong></p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517172428904.png" alt="image-20210517172428904"></p>
<p>开始事务时创建readview, readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组访问数据，获取数据中的事务id(获取的是事务id最大的记录)，对比readview:</p>
<p>如果在readview的左边(比readview都小)，可以访问(在左边意味着该事务已经提交)</p>
<p>如果在readview的右边(比readview都大)或者就在readview中，不可以访问，获取roll_pointer，取上一版本重新对比(在右边意味着，该事务在readview生成之后出现，在readview中意味着该事务还未提交)</p>
<p>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。<br>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读·写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。</p>
<h1 id="mysql主从同步原理"><a href="#mysql主从同步原理" class="headerlink" title="mysql主从同步原理"></a>mysql主从同步原理</h1><p>mysql主从同步的过程:<br>Mysql的主从复制中主要有三个线程: master (binlog dump thread 、slave (I&#x2F;O thread . SQL thread） , Master—条线程和Slave中的两条线程。</p>
<ul>
<li>主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog,是数据库服务器启动的那—刻起，保存所有修改数据库结构或内容的一个文件。</li>
<li>主节点 log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。·从节点Io线程接收binlog内容，并将其写入到relay log 文件中。</li>
<li>从节点的SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性。</li>
</ul>
<p>注:主从节点使用binglog文件+ position偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从position的位置发起同步。</p>
<p>由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。</p>
<p><strong>全同步复制</strong></p>
<p>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</p>
<p><strong>半同步复制</strong></p>
<p>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</p>
<h1 id="简述MylSAM和InnoDB的区别"><a href="#简述MylSAM和InnoDB的区别" class="headerlink" title="简述MylSAM和InnoDB的区别"></a>简述MylSAM和InnoDB的区别</h1><p><strong>MyISAM:</strong></p>
<p>不支持事务，但是每次查询都是原子的:</p>
<p>支持表级锁，即每次操作是对整个表加锁;</p>
<p>存储表的总行数;</p>
<p>一个MYISAM表有三个文件:索引文件、表结构文件、数据文件;</p>
<p>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯—性。</p>
<p><strong>lnnoDb:</strong></p>
<p>支持ACID的事务，支持事务的四种隔离级别;</p>
<p>支持行级锁及外键约束:因此可以支持写并发;</p>
<p>不存储总行数;</p>
<p>一个InnoDb引擎存储在一个文件空间(共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里)，也有可能为多个(设置为独立表空，表大小受操作系统文件大小限制，一般为2G)，受操作系统文件大小的限制;</p>
<p>主键索引采用聚集索引(索引的数据域存储数据文件本身)，辅索引的数据域存储主键的值;因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引;最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</p>
<h1 id="简述mysql中索引类型及对数据库的性能的影响"><a href="#简述mysql中索引类型及对数据库的性能的影响" class="headerlink" title="简述mysql中索引类型及对数据库的性能的影响"></a>简述mysql中索引类型及对数据库的性能的影响</h1><p>普通索引:允许被索引的数据列包含重复的值。</p>
<p>唯一索引:可以保证数据记录的唯一性。</p>
<p>主键:是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY 来创建。</p>
<p>联合索引:索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。</p>
<p>全文索引:通过建立<code>倒排索引</code>,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT(column);创建全文索引</p>
<p>索引可以极大的提高数据的查询速度。</p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。</p>
<h1 id="RDB和AOF机制"><a href="#RDB和AOF机制" class="headerlink" title="RDB和AOF机制"></a>RDB和AOF机制</h1><p><strong>RDB: Redis DataBase</strong></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>优点:</p>
<p>1、整个Redis数据库将只包含一个文件dump.rdb，方便持久化。</p>
<p>2、容灾性好，方便备份。</p>
<p>3、性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能</p>
<p>4.相对于数据集大时，比AOF的启动效率更高。</p>
<p>缺点:</p>
<p>1、数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p>
<p>2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p><strong>AOF: Append only File</strong></p>
<p>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录</p>
<p>优点:</p>
<p>1、数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。</p>
<p>2、通过 append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题。</p>
<p>3、AOF 机制的 rewrite模式。定期对AOF文件进行重写，以达到压缩的目的</p>
<p>缺点:</p>
<p>1、AOF文件比 RDB文件大，且恢复速度慢。</p>
<p>2、数据集大的时候，比rdb启动效率低。</p>
<p>3、运行效率没有RDB高</p>
<p><strong>AOF文件比RDB更新频率高，优先使用AOF还原数据。</strong></p>
<h1 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h1><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<ul>
<li>惰性过期:只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期:每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h1 id="Redis线程模型、单线程快的原因"><a href="#Redis线程模型、单线程快的原因" class="headerlink" title="Redis线程模型、单线程快的原因"></a>Redis线程模型、单线程快的原因</h1><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器file event handler。这个文件事件处理器，它是单线程的，所以Redis 才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。</p>
<p>文件事件处理器的结构包含4个部分:多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等)。<br>多个Socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。<br>然后一个Socket的事件处理完之后，IO多路复用程序才会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件，来选择对应的事件处理器来处理。</p>
<p><strong>单线程快的原因:</strong></p>
<p><strong>1) 纯内存操作</strong></p>
<p><strong>2) 核心是基于非阻塞的IO多路复用机制</strong></p>
<p><strong>3) 单线程反而避免了多线程的频繁上下文切换带来的性能问题</strong></p>
<h1 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h1><p><strong>缓存雪崩</strong>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案:</p>
<ul>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li>
<li>缓存预热</li>
<li>互斥锁</li>
</ul>
<p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案:</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截;</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li>
</ul>
<p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ul>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁</li>
</ul>
<h1 id="Redis的渐进式rehash原理"><a href="#Redis的渐进式rehash原理" class="headerlink" title="Redis的渐进式rehash原理"></a>Redis的渐进式rehash原理</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/01/%E9%9D%A2%E8%AF%952/" data-id="cl0j84jyv00ey04vh5kld1ggt" data-title="面试题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/01/Tomcat%E8%AE%BF%E9%97%AE%E6%B5%8F%E8%A7%88%E5%99%A8html%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Tomcat访问浏览器html文件乱码问题
        
      </div>
    </a>
  
  
    <a href="/2021/05/01/%E9%9D%A2%E8%AF%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面试题</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/concurrency/">concurrency</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/open-source/">open-source</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/" rel="tag">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E9%A1%B9%E7%9B%AE/" rel="tag">Java项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">MySql、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" rel="tag">Redis、面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Java/" rel="tag">Spring Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E3%80%81blog/" rel="tag">hexo、blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm-memory-management/" rel="tag">jvm-memory-management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty-source/" rel="tag">netty-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-intro/" rel="tag">spring-aop-intro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-source/" rel="tag">spring-aop-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="tag">循环依赖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/Java/" style="font-size: 15.56px;">Java</a> <a href="/tags/Java-JVM/" style="font-size: 18.89px;">Java JVM</a> <a href="/tags/Java-Spring/" style="font-size: 13.33px;">Java Spring</a> <a href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.78px;">Java、面试题</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">Java数据结构</a> <a href="/tags/Java%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">Java项目</a> <a href="/tags/MySql/" style="font-size: 20px;">MySql</a> <a href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.11px;">MySql、面试题</a> <a href="/tags/Redis/" style="font-size: 14.44px;">Redis</a> <a href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Redis、面试</a> <a href="/tags/Spring-Java/" style="font-size: 13.33px;">Spring Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/hexo%E3%80%81blog/" style="font-size: 10px;">hexo、blog</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm-memory-management/" style="font-size: 10px;">jvm-memory-management</a> <a href="/tags/netty-source/" style="font-size: 11.11px;">netty-source</a> <a href="/tags/redis/" style="font-size: 17.78px;">redis</a> <a href="/tags/spring-aop-intro/" style="font-size: 10px;">spring-aop-intro</a> <a href="/tags/spring-aop-source/" style="font-size: 10px;">spring-aop-source</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" style="font-size: 10px;">循环依赖</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/09/update%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97%EF%BC%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/Redis_hot/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM类加载机制</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Lee yunbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>