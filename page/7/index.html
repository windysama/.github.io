<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MyHomePage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="MyHomePage">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="MyHomePage">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lee yunbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MyHomePage" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MyHomePage</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-解决GitHub国内打不开的解决方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/21/%E8%A7%A3%E5%86%B3GitHub%E5%9B%BD%E5%86%85%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T16:00:00.000Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/21/%E8%A7%A3%E5%86%B3GitHub%E5%9B%BD%E5%86%85%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">解决GitHub国内打不开的解决方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="解决GitHub国内打不开的解决方法"><a href="#解决GitHub国内打不开的解决方法" class="headerlink" title="解决GitHub国内打不开的解决方法"></a>解决GitHub国内打不开的解决方法</h1><hr>
<p>github最近打不开，很久之前遇到过，但是忘记怎么解决了，查找相关资料后，今天记录在此，以备不时之需。</p>
<p>引用：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36154464">zhbcombbcc：解决浏览器打不开github网站常用方法zhuanlan.zhihu.com<img src="https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg" alt="图标"></a></p>
<p>记住3个关键网址</p>
<p>github网址查询：<a href="https://link.zhihu.com/?target=https://github.com.ipaddress.com/">The world’s leading software development platform · GitHub</a></p>
<p>github域名查询：<a href="https://link.zhihu.com/?target=https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">▷ github.global.ssl.fastly.net Website statistics and traffic analysis</a></p>
<p>github静态资源ip：<a href="https://link.zhihu.com/?target=https://github.com.ipaddress.com/assets-cdn.github.com">https://github.com.ipaddress.com/assets-cdn.github.com</a></p>
<ul>
<li>github网址ip查询</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-53b5000730df685df1d9accd023eab6a_720w.jpg" alt="img"></p>
<ul>
<li>github域名查询</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-d75076591c46cfdaec707b79aff292d5_720w.jpg" alt="img"></p>
<ul>
<li>github静态ip查询</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-9acca3f5bc347ea422373d60a875e1ff_720w.jpg" alt="img"></p>
<p>修改host文件，修改host文件，在最后附上下面的内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">140.82.112.4 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<p>保存并退出</p>
<p>刷新DNS缓存</p>
<p>Windows打开cmd，输入 <code>ipconfig/flushdns</code></p>
<p><img src="https://s1.imagehub.cc/images/2021/03/30/ROnfjGUUwO.png" alt="解决GitHub国内打不开的解决方法"></p>
<p>如果还是无法打开，只能尝试使用github镜像网站</p>
<p>Github镜像网站:</p>
<p><a target="_blank" rel="noopener" href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org</a></p>
<p><a target="_blank" rel="noopener" href="https://hub.fastgit.org/">https://hub.fastgit.org</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/21/%E8%A7%A3%E5%86%B3GitHub%E5%9B%BD%E5%86%85%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" data-id="cl0j84jxr00bj04vhcgg2fgqx" data-title="解决GitHub国内打不开的解决方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线程池的原理及实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-31T16:00:00.000Z" itemprop="datePublished">2021-06-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">线程池的原理及实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线程池的原理及实现"><a href="#线程池的原理及实现" class="headerlink" title="线程池的原理及实现"></a>线程池的原理及实现</h1><p><strong>1、线程池简介：</strong><br>  多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。<br>  假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。</p>
<p>  如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。<br>        一个线程池包括以下四个基本组成部分：<br>        1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；<br>        2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；<br>        3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；<br>        4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</p>
<p>  线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。<br>  线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子：<br>  假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。</p>
<p>  代码实现中并没有实现任务接口，而是把Runnable对象加入到线程池管理器（ThreadPool），然后剩下的事情就由线程池管理器（ThreadPool）来完成了</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mine.util.thread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池类，线程管理器：创建线程，执行任务，销毁线程，获取线程基本信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">	<span class="comment">// 线程池中默认线程的个数为5</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">worker_num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 工作线程</span></span><br><span class="line">	<span class="keyword">private</span> WorkThread[] workThrads;</span><br><span class="line">	<span class="comment">// 未处理的任务</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">finished_task</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 任务队列，作为一个缓冲,List线程不安全</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Runnable&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadPool threadPool;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 创建具有默认线程个数的线程池</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">ThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 创建线程池,worker_num为线程池中工作线程的个数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> worker_num)</span> &#123;</span><br><span class="line">		ThreadPool.worker_num = worker_num;</span><br><span class="line">		workThrads = <span class="keyword">new</span> <span class="title class_">WorkThread</span>[worker_num];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; worker_num; i++) &#123;</span><br><span class="line">			workThrads[i] = <span class="keyword">new</span> <span class="title class_">WorkThread</span>();</span><br><span class="line">			workThrads[i].start();<span class="comment">// 开启线程池中的线程</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 单态模式，获得一个默认线程个数的线程池</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ThreadPool <span class="title function_">getThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getThreadPool(ThreadPool.worker_num);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 单态模式，获得一个指定线程个数的线程池,worker_num(&gt;0)为线程池中工作线程的个数</span></span><br><span class="line">	<span class="comment">// worker_num&lt;=0创建默认的工作线程个数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ThreadPool <span class="title function_">getThreadPool</span><span class="params">(<span class="type">int</span> worker_num1)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (worker_num1 &lt;= <span class="number">0</span>)</span><br><span class="line">			worker_num1 = ThreadPool.worker_num;</span><br><span class="line">		<span class="keyword">if</span> (threadPool == <span class="literal">null</span>)</span><br><span class="line">			threadPool = <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(worker_num1);</span><br><span class="line">		<span class="keyword">return</span> threadPool;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (taskQueue) &#123;</span><br><span class="line">			taskQueue.add(task);</span><br><span class="line">			taskQueue.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable[] task)</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (taskQueue) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Runnable t : task)</span><br><span class="line">				taskQueue.add(t);</span><br><span class="line">			taskQueue.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(List&lt;Runnable&gt; task)</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (taskQueue) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Runnable t : task)</span><br><span class="line">				taskQueue.add(t);</span><br><span class="line">			taskQueue.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (!taskQueue.isEmpty()) &#123;<span class="comment">// 如果还有任务没执行完成，就先睡会吧</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 工作线程停止工作，且置为null</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; worker_num; i++) &#123;</span><br><span class="line">			workThrads[i].stopWorker();</span><br><span class="line">			workThrads[i] = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		threadPool=<span class="literal">null</span>;</span><br><span class="line">		taskQueue.clear();<span class="comment">// 清空任务队列</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 返回工作线程的个数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWorkThreadNumber</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> worker_num;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFinishedTasknumber</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> finished_task;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 返回任务队列的长度，即还没处理的任务个数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWaitTasknumber</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> taskQueue.size();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 覆盖toString方法，返回线程池信息：工作线程个数和已完成任务个数</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;WorkThread number:&quot;</span> + worker_num + <span class="string">&quot;  finished task number:&quot;</span></span><br><span class="line">				+ finished_task + <span class="string">&quot;  wait task number:&quot;</span> + getWaitTasknumber();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 内部类，工作线程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">		<span class="comment">// 该工作线程是否有效，用于结束该工作线程</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 关键所在啊，如果任务队列不空，则取出任务执行，若任务队列空，则等待</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">while</span> (isRunning) &#123;<span class="comment">// 注意，若线程无效则自然结束run方法，该线程就没用了</span></span><br><span class="line">				<span class="keyword">synchronized</span> (taskQueue) &#123;</span><br><span class="line">					<span class="keyword">while</span> (isRunning &amp;&amp; taskQueue.isEmpty()) &#123;<span class="comment">// 队列为空</span></span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							taskQueue.wait(<span class="number">20</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!taskQueue.isEmpty())</span><br><span class="line">						r = taskQueue.remove(<span class="number">0</span>);<span class="comment">// 取出任务</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">					r.run();<span class="comment">// 执行任务</span></span><br><span class="line">				&#125;</span><br><span class="line">				finished_task++;</span><br><span class="line">				r = <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 停止工作，让该线程自然执行完run方法，自然结束</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopWorker</span><span class="params">()</span> &#123;</span><br><span class="line">			isRunning = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mine.util.thread;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPool</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建3个线程的线程池</span></span><br><span class="line">		<span class="type">ThreadPool</span> <span class="variable">t</span> <span class="operator">=</span> ThreadPool.getThreadPool(<span class="number">3</span>);</span><br><span class="line">		t.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>[] &#123; <span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="keyword">new</span> <span class="title class_">Task</span>() &#125;);</span><br><span class="line">		t.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>[] &#123; <span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="keyword">new</span> <span class="title class_">Task</span>() &#125;);</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		t.destroy();<span class="comment">// 所有线程都执行完成才destory</span></span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 任务类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">// 执行任务</span></span><br><span class="line">			System.out.println(<span class="string">&quot;任务 &quot;</span> + (i++) + <span class="string">&quot; 完成&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>WorkThread number:3  finished task number:0  wait task number:6<br>任务 1 完成<br>任务 2 完成<br>任务 3 完成<br>任务 4 完成<br>任务 5 完成<br>任务 6 完成<br>WorkThread number:3  finished task number:6  wait task number:0</p>
<p>分析：由于并没有任务接口，传入的可以是自定义的任何任务，所以线程池并不能准确的判断该任务是否真正的已经完成（真正完成该任务是这个任务的run方法执行完毕），只能知道该任务已经出了任务队列，正在执行或者已经完成。</p>
<p><strong>2、java类库中提供的线程池简介：</strong></p>
<p>   <strong>java提供的线程池更加强大，相信理解线程池的工作原理，看类库中的线程池就不会感到陌生了。</strong></p>
<p><img src="E:\MyBolg\source_posts\线程池的原理及实现\0_1319784225fRSR.jpg" alt="0_1319784225fRSR"></p>
<p><img src="E:\MyBolg\source_posts\线程池的原理及实现\0_1319784243mu5f.jpg" alt="0_1319784243mu5f"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" data-id="cl0j84jxo00bb04vh5cav6g31" data-title="线程池的原理及实现" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-项目并发如何处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/01/%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%8F%91%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-31T16:00:00.000Z" itemprop="datePublished">2021-06-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/01/%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%8F%91%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/">项目并发处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="项目并发处理"><a href="#项目并发处理" class="headerlink" title="项目并发处理"></a>项目并发处理</h1><h2 id="1-什么是高并发及高并发概念"><a href="#1-什么是高并发及高并发概念" class="headerlink" title="1.什么是高并发及高并发概念"></a><strong>1.什么是高并发及高并发概念</strong></h2><p>  高并发（High Concurrency）是互联网分布式系统常出现的一种问题机制，通常是客户端发起过多请求至服务端导致服务端接收过多的请求而形成的线程拥堵、阻塞出现的线程并发现象。高并发常用的一些有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。</p>
<p>响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</p>
<p>吞吐量：单位时间内处理的请求数量。</p>
<p>QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p>
<p>并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p>
<p>压力测试：测试能承受的最大并发，测试最大承受的QPS值，(我常用的压力测试工具为jmeter进行模拟压测)</p>
<h2 id="2-高并发解决方案"><a href="#2-高并发解决方案" class="headerlink" title="2.高并发解决方案"></a><strong>2.高并发解决方案</strong></h2><h3 id="服务端优化：页面静态化，并发处理，队列处理"><a href="#服务端优化：页面静态化，并发处理，队列处理" class="headerlink" title="服务端优化：页面静态化，并发处理，队列处理"></a><strong>服务端优化：页面静态化，并发处理，队列处理</strong></h3><p><em><strong>系统拆分</strong></em>:将一个系统拆分为多个子系统，然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，这样就可以抗高并发。</p>
<p><em><strong>redis缓存</strong></em>:大部分的高并发场景，都是读多写少，完全可以在数据库和缓存里都写一份，然后读取的时候大量走缓存。redis底层是以队列单线程的方式进行处理的可以解决几万的并发请求。所以如果项目中存在大量的请求读场景，可以使用缓存来抗高并发。</p>
<p><em><strong>MQ(消息队列)</strong></em>:可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改。那高并发绝对可能爆掉你的系统，人家是缓存你要是用redis来承载写那肯定不行，数据随时就被LRU(淘汰掉最不经常使用的)了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的。</p>
<h3 id="数据库优化：数据库缓存，分库分表，分区操作，读写分离，负载均衡"><a href="#数据库优化：数据库缓存，分库分表，分区操作，读写分离，负载均衡" class="headerlink" title="数据库优化：数据库缓存，分库分表，分区操作，读写分离，负载均衡"></a><strong>数据库优化：数据库缓存，分库分表，分区操作，读写分离，负载均衡</strong></h3><p><em><strong>分库分表</strong></em>:可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。</p>
<p><em><strong>读写分离</strong></em>:这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p>
<p><em><strong>流量优化：防盗链处理</strong></em></p>
<p><em><strong>防盗链处理：</strong></em>防止别人通过一些技术手段绕过本站的资源展示页面，盗用本站的资源，让绕开本站资源展示页面的资源链接失效，可以大大减轻服务器及带宽的压力</p>
<h3 id="前端优化：减少HTTP请求，合并css或js，添加异步请求，启用浏览器缓存和文件压缩，CDN加速，建立独立图片服务器，"><a href="#前端优化：减少HTTP请求，合并css或js，添加异步请求，启用浏览器缓存和文件压缩，CDN加速，建立独立图片服务器，" class="headerlink" title="前端优化：减少HTTP请求，合并css或js，添加异步请求，启用浏览器缓存和文件压缩，CDN加速，建立独立图片服务器，"></a><strong>前端优化：减少HTTP请求，合并css或js，添加异步请求，启用浏览器缓存和文件压缩，CDN加速，建立独立图片服务器，</strong></h3><p> ***减少HTTP请求:***改善响应时间的最简单途径就是减少组件的数量，并由此减少HTTP请求的数量</p>
<p>图片使用base64编码减少页面请求数：采用base64的编码方式将图片直接嵌入到网页中，而不是从外部载入</p>
<h3 id="web服务器优化：负载均衡，nginx反向代理，7-4层LVS软件"><a href="#web服务器优化：负载均衡，nginx反向代理，7-4层LVS软件" class="headerlink" title="web服务器优化：负载均衡，nginx反向代理，7,4层LVS软件"></a><strong>web服务器优化：负载均衡，nginx反向代理，7,4层LVS软件</strong></h3><p>nginx负载均衡：内置策略：IP Hash，加权轮询；扩展策略：fair策略，通用hash，一致性hash<br>加权轮询：首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器，当所有后端机器都down掉时，nginx会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在timeout的状态；IP Hash：流程和轮询很类似，只是其中的算法和具体的策略有些变化，算法是一种变相的轮询算法；fair：根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流；通用hash，一致性hash：通用hash比较简单，可以以nginx内置的变量为key进行hash，一致性hash采用了nginx内置的一致性hash环，支持memcache</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/01/%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%8F%91%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/" data-id="cl0j84jyd00dm04vhgvf57zr5" data-title="项目并发处理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot导入项目报错" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/01/SpringBoot%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/" class="article-date">
  <time class="dt-published" datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/01/SpringBoot%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/">SpringBoot导入项目报错</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210518222414826.png" alt="image-20210518222414826"></p>
<p>Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom:2.3.0.RELEASE from&#x2F;to alimaven (<a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/repositories/central/">http://maven.aliyun.com/nexus/content/repositories/central/</a>): F:\maven3.6.1\maven_repository\org\springframework\boot\spring-boot-starter-parent\2.3.0.RELEASE\spring-boot-starter-parent-2.3.0.RELEASE.pom.part.lock (系统找不到指定的路径。)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/01/SpringBoot%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/" data-id="cl0j84jww008j04vh6pwd3wj6" data-title="SpringBoot导入项目报错" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Tomcat访问浏览器html文件乱码问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/01/Tomcat%E8%AE%BF%E9%97%AE%E6%B5%8F%E8%A7%88%E5%99%A8html%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/01/Tomcat%E8%AE%BF%E9%97%AE%E6%B5%8F%E8%A7%88%E5%99%A8html%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/">Tomcat访问浏览器html文件乱码问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>做blog开源项目，在启动Tomcat访问html文件的时候出现中英文都是乱码的问题，</p>
<p>一开始不知道什么原因，因为代码都是仿照的写的，检查之后发现并不存在代码问题。</p>
<p>此时就在想是不是某个文件的编码格式与浏览器不符。</p>
<p>查找百度，出现一堆的解决办法，我一个一个尝试，最终解决乱码问题，下面分享一下几个解决方法</p>
<p>1.检查html文件中是否有设置编码格式（这个一般都很好检查出来。笑哭）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果检查代码没有问题，同时代码是导入的别人的，可以尝试把html文件复制到记事本上，去重新编码格式，最后再复制粘贴回文件中</p>
<p>或者</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者在html文件开头加上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上是一种方法，但并不能解决我的问题，继续寻找</p>
<p>2.启动tomcat：通过cmd，路径切换至自己tomcat的安装路径，然后输入startup.bat启动。启动后发现tomcat的页面都是乱码显示，这个就直接通过tomcat文件中config下的logging.properties修改其编码格式为”gbk”</p>
<p><img src="https://pic2.zhimg.com/80/v2-4d12e85db6f5f780af9c8713b9e19231_720w.jpg" alt="img"></p>
<p>修改完成后关闭tomcat再重新启动即可。</p>
<p>这是解决tomcat启动日志文件显示乱码的问题</p>
<p>我们还需要修改config文件下server.xml</p>
<p>添加编码为”utf-8”</p>
<p><img src="https://pic3.zhimg.com/80/v2-bdf4a5371d3024da62116e117950886a_720w.jpg" alt="img"></p>
<p>这种方式一般能解决乱码问题了，但我的还是不行</p>
<p>3.在第二种的基础上，我又去修改了tomcat下 web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fileEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后重启tomcat。</p>
<p>最后在多种尝试下，解决乱码问题，爽！！！！！！</p>
<p>tomcat重启:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果你的toamcat已经启动：在命令行中进入tomcat安装目录</span><br><span class="line">C:\tomcat\bin&gt;shutdown</span><br><span class="line">之后 C:\tomcatbin&gt;startup</span><br><span class="line">这样tomcat完成了一次重启。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/01/Tomcat%E8%AE%BF%E9%97%AE%E6%B5%8F%E8%A7%88%E5%99%A8html%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/" data-id="cl0j84jx6009b04vhe2hldc5e" data-title="Tomcat访问浏览器html文件乱码问题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/01/%E9%9D%A2%E8%AF%952/" class="article-date">
  <time class="dt-published" datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/01/%E9%9D%A2%E8%AF%952/">面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么?"></a>Spring是什么?</h1><p>轻量级的开源的J2EE框架。它是一个容器框架，用来装javabean (java对象)，中间层框架（万能胶)可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁</p>
<ul>
<li>Spring是一个轻量级的控制反转(loC)和面向切面(AOP)的容器框架</li>
<li>从大小与开销两方面而言Spring都是轻量级的。</li>
<li>通过控制反转(IoC)的技术达到松耦合的目的</li>
<li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发</li>
<li>包含并管理应用对象(Bean)的配置和生命周期;这个意义上是一个容器。</li>
<li>将简单的组件配置、组合成为复杂的应用，这个意义上是一个框架。</li>
</ul>
<h1 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h1><p>容器概念、控制反转、依赖注入</p>
<p><strong>ioc容器:</strong><br>实际上就是个map (key,value)，里面存的是各种对象（在xml里配置的bean节点、@repository,@service、@controller、@component)，在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。<br>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入(autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入;id就是对象名）。</p>
<p><strong>控制反转:</strong><br>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建—个对象B注入到对象A需要的地方。<br>通过前后的对比，不难看出来:对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。<br>全部对象的控制权全部上缴给”第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成”粘合剂”的由来。</p>
<p><strong>依赖注入:</strong><br>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<h1 id="谈谈你对AOP的理解"><a href="#谈谈你对AOP的理解" class="headerlink" title="谈谈你对AOP的理解"></a>谈谈你对AOP的理解</h1><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</p>
<p>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</p>
<p>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP:将程序中的交叉业务逻辑（比如安全，日志，事务等)，封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</p>
<h1 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别?"></a>BeanFactory和ApplicationContext有什么区别?</h1><p>ApplicationContext是BeanFactory的子接口<br>ApplicationContext提供了更完整的功能:<br>    ①继承MessageSource，因此支持国际化。<br>    ②统一的资源文件访问方式。<br>    ③提供在监听器中注册bean的事件。<br>    ④同时加载多个配置文件。<br>    ⑤载入多个(有继承关系)上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>区别：<br>1、BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。<br>2、ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。<br>3、相对于基本的BeanFactory，ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。<br>4、BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。<br>5、BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用, 但两者之间的区别是:BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h1 id="描述一下Spring-Bean的生命周期"><a href="#描述一下Spring-Bean的生命周期" class="headerlink" title="描述一下Spring Bean的生命周期?"></a>描述一下Spring Bean的生命周期?</h1><p>01、解析类得到BeanDefinition<br>02、如果有多个构造方法，则要推断构造方法<br>03、确定好构造方法后，进行实例化得到一个对象<br>04、为对象中的加了@Autowired注解的属性进行属性填充<br>05、回调Aware方法，比如BeanNameAware，BeanFactoryAware<br>06、调用BeanPostProcessor的初始化前的方法<br>07、调用初始化方法<br>08、调用BeanPostProcessor的初始化后的方法，在这里会进行AOP<br>09、如果当前创建的bean是单例的则会把bean放入单例池<br>10、使用bean<br>11、Spring容器关闭时调用DisposableBean中destory()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、实例化 Instantiation</span><br><span class="line">2、属性赋值 Populate</span><br><span class="line">3、初始化 Initialization</span><br><span class="line">4、销毁 Destruction</span><br><span class="line"></span><br><span class="line">1、Spring对bean进行实例化；</span><br><span class="line">2、Spring将值和bean的引用注入到bean对应的属性中；</span><br><span class="line">3、如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</span><br><span class="line">4、如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</span><br><span class="line">5、如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</span><br><span class="line">6、如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</span><br><span class="line">7、如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</span><br><span class="line">8、如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</span><br><span class="line">9、此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</span><br><span class="line">10、如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</span><br></pre></td></tr></table></figure>



<h1 id="解释下Spring支持的几种bean的作用域。"><a href="#解释下Spring支持的几种bean的作用域。" class="headerlink" title="解释下Spring支持的几种bean的作用域。"></a>解释下Spring支持的几种bean的作用域。</h1><ul>
<li>singleton:默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建)。</li>
<li>prototype:为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象</li>
<li>request: bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。</li>
<li>session:与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>
<li>application: bean被定义为在ServletContext的生命周期中复用一个单例对象。</li>
<li>websocket: bean被定义为在websocket的生命周期中复用一个单例对象。</li>
</ul>
<p>global-session:全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p>
<h1 id="Spring框架中的单例Bean是线程安全的么"><a href="#Spring框架中的单例Bean是线程安全的么" class="headerlink" title="Spring框架中的单例Bean是线程安全的么?"></a>Spring框架中的单例Bean是线程安全的么?</h1><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。</p>
<p>如果Bean是有状态的那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域把”singleton”改为”protopyte”这样每次请求Bean就相当于是new Bean()这样就可以保证线程的安全了。</p>
<ul>
<li>有状态就是有数据存储功能</li>
<li>无状态就是不会保存数据    controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</li>
</ul>
<p>Dao会操作数据库Connection，Connection是带有状态的，比如说数据库事务，Spring的事务管理器使用Threadlocal为不同线程维护了一套独立的connection副本，保证线程之间不会互相影响(Spring是如何保证事务获取同一个Connection的)</p>
<p>不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法了。</p>
<h1 id="Spring框架中都用到了哪些设计模式"><a href="#Spring框架中都用到了哪些设计模式" class="headerlink" title="Spring框架中都用到了哪些设计模式?"></a>Spring框架中都用到了哪些设计模式?</h1><p>简单工厂:由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p>
<blockquote>
<p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>
</blockquote>
<p>工厂方法:</p>
<blockquote>
<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getobject()方法，所以返回的不是factory这个bean，而是这个bean.getojbect()方法的返回值。</p>
</blockquote>
<p>单例模式:保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<blockquote>
<p>spring对单例的实现: spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</p>
</blockquote>
<p>适配器模式:</p>
<blockquote>
<p>spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVc的扩展了。</p>
</blockquote>
<p>装饰器模式:动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p>
<blockquote>
<p>spring中用到的包装器模式在类名上有两种表现:一种是类名中含有wrapper，另一种是类名中含有Decorator。</p>
</blockquote>
<p>动态代理:</p>
<blockquote>
<p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AoP容器会为目标对象创建动态的创建一个代理对象。springAOP就是以这种方式织入切面的。<br>织入:把切面应用到目标对象并创建新的代理对象的过程。</p>
</blockquote>
<p>观察者模式:</p>
<blockquote>
<p>spring的事件驱动模型使用的是观察者模式，Spring中observer模式常用的地方是listener的实现。</p>
</blockquote>
<p>策略模式:</p>
<blockquote>
<p>spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring框架本身大量使用了Resource接口来访问底层资源。</p>
</blockquote>
<h1 id="Spring事务的实现方式和原理以及隔离级别"><a href="#Spring事务的实现方式和原理以及隔离级别" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别?"></a>Spring事务的实现方式和原理以及隔离级别?</h1><p>在使用Spring框架时，可以有两种使用事务的方式，一种是<strong>编程式</strong>的，一种是<strong>申明式</strong>的，@Transactional注解就是申明式的。</p>
<p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。</p>
<p>比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统—成功或失败。</p>
<p>在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。</p>
<p>当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。</p>
<p>spring事务隔离级别就是数据库的隔离级别:外加一个默认级别</p>
<ul>
<li>read uncommitted(未提交读)</li>
<li>read committed (提交读、不可重复读)</li>
<li>repeatable read(可重复读)</li>
<li>serializable (可串行化)</li>
</ul>
<p>数据库的配置隔离级别是Read commited , 而Spring配置的隔离级别是Repeatable Read，请问这时隔离级别是以哪一个为准?<br>    以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库</p>
<h1 id="说一下Spring的事务机制"><a href="#说一下Spring的事务机制" class="headerlink" title="说一下Spring的事务机制"></a>说一下Spring的事务机制</h1><p>1.Spring事务底层是基于数据库事务和AOP机制的</p>
<p>2.首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean</p>
<p>3.当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解</p>
<p>4.如果加了，那么则利用事务管理器创建一个数据库连接</p>
<p>5.并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步</p>
<p>6.然后执行当前方法，方法中会执行sql</p>
<p>7.执行完当前方法后，如果没有出现异常就直接提交事务</p>
<p>8.如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</p>
<p>9.Spring事务的隔离级别对应的就是数据库的隔离级别</p>
<p>10.Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的</p>
<p>11.spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制衙置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据<br>库连接上执行sql</p>
<h1 id="spring事务传播机制"><a href="#spring事务传播机制" class="headerlink" title="spring事务传播机制"></a>spring事务传播机制</h1><p>多个事务方法相互调用时,事务如何在这些方法间传播</p>
<blockquote>
<p>方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</p>
</blockquote>
<p>REQUIRED(Spring默认的事务传播类型):如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</p>
<p>SUPPORTS:当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</p>
<p>MANDATORY:当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</p>
<p>REQUIRES_NEW:创建一个新事务，如果存在当前事务，则挂起该事务。</p>
<p>NOT_SUPPORTED:以非事务方式执行,如果当前存在事务，则挂起当前事务</p>
<p>NEVER:不使用事务，如果当前事务存在，则抛出异常</p>
<p>NESTED:如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样(开启一个事务)</p>
<blockquote>
<p>和IREQUIRES_NEW的区别<br>REQUIRES_NEWw是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时〈我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务)。在NESTED情况下父事务回滚时，子事务也会回滚，而在REQUIRES_NEw情况下，原有事务回滚，不会影响新开启的事务。</p>
<p>和REQUIRED的区别<br>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚。而在NESTED况下，被调用方发生异常时，调用方可以catch其异常，这样具有子事务回滚，父事务不受影响</p>
</blockquote>
<h1 id="spring事务什么时候会失效"><a href="#spring事务什么时候会失效" class="headerlink" title="spring事务什么时候会失效?"></a>spring事务什么时候会失效?</h1><p>Spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了!</p>
<p>常见情况有如下几种</p>
<p>1、发生自调用，类里面使用this调用本类的方法（this通常省略)，此时这个this对象不是代理类，而是UserService对象本身!<br>    解决方法很简单，让那个this变成UserService的代理类即可!</p>
<p>2、方法不是public的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactiona1只能用于 public的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启Aspectj代理模式。</span><br></pre></td></tr></table></figure>

<p>3、数据库不支持事务</p>
<p>4、没有被spring管理</p>
<p>5、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)</p>
<h1 id="什么是bean的自动装配，有哪些方式"><a href="#什么是bean的自动装配，有哪些方式" class="headerlink" title="什么是bean的自动装配，有哪些方式?"></a>什么是bean的自动装配，有哪些方式?</h1><p>开启自动装配，只需要在xml配置文件&#x3D;&#x3D;<bean>&#x3D;&#x3D;中定义”autowire”属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;cutomer&quot; c1ass=&quot;com.xxx.xxx.Customer&quot; autowire=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>autowire属性有五种装配的方式:</p>
<p>no-缺省情况下，自动配置是通过”ref”属性手动设定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手动装配:以value或ref的方式明确指定属性值都是手动装配。</span><br><span class="line">需要通过‘ref&#x27;属性来连接bean。</span><br></pre></td></tr></table></figure>

<p>byName-根据bean的属性名称进行自动装配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id=&quot;cutomer&quot; c1ass=&quot;com.xxx.xxx.Cutomer&quot; autowire=&quot;byName&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;person&quot; c1ass=&quot;com.xxx.xxx.Person&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>byType-根据bean的类型进行自动装配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id=&quot;cutomer&quot; class=&quot;com.xxx.xxx.cutomer&quot; autowire=&quot;byType&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;person&quot; class=&quot;com.xxx.xxx.Person&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>construltor-类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型形同，则进行自动装配，否则导致异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cutomer构造函数的参数person的类型为Person，spirng会将Person类型通过构造方法进行自动装配。</span><br><span class="line">&lt;bean id=&quot;cutomer&quot; class=&quot;com.xxx.xxx.Cutomer&quot; autowire=&quot;construtor&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;person&quot; c1ass=&quot;com.xxx.xxx.Person&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>autodetect-如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</span><br></pre></td></tr></table></figure>

<p>@Autowired自动装配bean，可以在字段、 setter方法、构造函数上使用。</p>
<h1 id="Spring-Boot、Spring-MVC和Spring-有什么区别"><a href="#Spring-Boot、Spring-MVC和Spring-有什么区别" class="headerlink" title="Spring Boot、Spring MVC和Spring 有什么区别"></a>Spring Boot、Spring MVC和Spring 有什么区别</h1><p><strong>spring</strong>是一个lOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</p>
<p><strong>springmvc</strong>是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet，用来接收请求，然后定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端</p>
<p><strong>springboot</strong>是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc应用，简化了配置(约定了默认配置)，整合了一系列的解决方案(starter机制) 、 redis、mongodb、es，可以开箱即用</p>
<h1 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h1><ol>
<li><p>用户发送请求至前端控制器DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 收到请求调用HandlerMapping处理器映射器。</p>
</li>
<li><p>处理器映射器找到具体的处理器(可以根据 xml配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)—并返回给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 调用HandlerAdapter处理器适配器。</p>
</li>
<li><p>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)</p>
</li>
<li><p>Controller执行完成返回ModelAndView。</p>
</li>
<li><p>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServiet。</p>
</li>
<li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>
</li>
<li><p>ViewReslover解析后返回具体View。</p>
</li>
<li><p>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。</p>
</li>
<li><p>DispatcherServlet响应用户。</p>
</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180803145042704?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxOTEyMjA=" alt="img"></p>
<h1 id="Spring-MVC的主要组件"><a href="#Spring-MVC的主要组件" class="headerlink" title="Spring MVC的主要组件?"></a>Spring MVC的主要组件?</h1><p>Handler:也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler</p>
<p><strong>1、HandlerMapping(主要)</strong><br>initHandlerMappings(context)，处理器映射器，根据用户请求的资源uri来查找Handler的。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行，这就是<br>HandlerMapping需要做的事。</p>
<p><strong>2、HandlerAdapter（主要）</strong><br>initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的servlet处理方法调用灵活的Handler来进行处理呢?这就是HandlerAdapter要做的事情。<br>Handler是用来干活的工具;HandlerMapping用于根据需要干的活找到相应的工具;HandlerAdapter是使用工具干活的人。</p>
<p>3、HandlerExceptionResolver<br>initHandlerExceptionResolvers(context)，其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢?这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是<br>HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。</p>
<p>4、ViewResolver<br>initviewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。Vview是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html(也可能是其它类型)文件。这里就有两个关键问题:使用哪个模板?用什么技术(规则)填入参数?这其实是ViewResolver主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型)进行渲染，具体的渲染过程则交由不同的视图自己完成</p>
<p>5、RequestToViewNameTranslator<br>initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。</p>
<p>6、LocaleResolver<br>initLocaleResolver(context)，解析视图需要两个参数:一是视图名，另一个是Locale。视图名是处理器返回的,Locale是从哪里来的?这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale,Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale:一是ViewResolver视图解析的时候;二是用到国际化资源或者主题的时候。</p>
<p>7、ThemeResolver<br>initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。</p>
<p>8、MultipartResolver<br>initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的request包装成<br>MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</p>
<p>9、FlashMapManager<br>initFlashMapManager(context)，用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</p>
<h1 id="Spring-Boot自动配置原理-高频考点"><a href="#Spring-Boot自动配置原理-高频考点" class="headerlink" title="Spring Boot自动配置原理?(高频考点)"></a>Spring Boot自动配置原理?(高频考点)</h1><p>@lmport +@Configuration + Spring spi</p>
<p>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META-INF&#x2F;spring.factories下使用Spring spi扫描META-INF&#x2F;spring.factories下的配置类</p>
<p>使用@Import导入自动配置类</p>
<p><img src="C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210516214833845.png" alt="image-20210516214833845"></p>
<h1 id="如何理解-Spring-Boot中的Starter"><a href="#如何理解-Spring-Boot中的Starter" class="headerlink" title="如何理解 Spring Boot中的Starter"></a>如何理解 Spring Boot中的Starter</h1><p>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</p>
<p>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在starter包的META-INF&#x2F;spring.factories中写入该配置类，springboot会按照约定来加载该配置类</p>
<p>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置)<br>就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot–starter，spring-boot-starter-redis</p>
<h1 id="什么是嵌入式服务器-为什么要使用嵌入式服务器"><a href="#什么是嵌入式服务器-为什么要使用嵌入式服务器" class="headerlink" title="什么是嵌入式服务器?为什么要使用嵌入式服务器?"></a>什么是嵌入式服务器?为什么要使用嵌入式服务器?</h1><p>节省了下载安装tomcat，应用也不需要再打war包，然后放到webapp目录下再运行</p>
<p>只需要一个安装了Java的虚拟机，就可以直接在上面部署应用程序了</p>
<p>springboot已经内置了tomcat.jar，运行main方法时会去启动tomcat，并利用tomcat的spi机制加载springmvc</p>
<h1 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h1><p>优点:</p>
<p>1、基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在XML里，解除sql与程序代码的耦合，便于统一管理; 提供XML标签，支持编写动态SQL语句，并可重用。</p>
<p>2、与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接;</p>
<p>3、很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要DBC支持的数据库MyBatis都支持)。</p>
<p>4、能够与Spring很好的集成;</p>
<p>5、提供映射标签，支持对象与数据库的ORM字段关系映射;提供对象关系映射标签，支持对象关系组件维护。</p>
<p>缺点:</p>
<p>1、SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>2、SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h1 id="MyBatis-与Hibernate有哪些不同"><a href="#MyBatis-与Hibernate有哪些不同" class="headerlink" title="MyBatis 与Hibernate有哪些不同?"></a>MyBatis 与Hibernate有哪些不同?</h1><p>SQL和ORM的争论，永远都不会终止</p>
<p><strong>开发速度</strong>的对比:<br>Hibernate的真正掌握要比Mybatis难些。Mybatis框架相对简单很容易上手，但也相对简陋些。<br>比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如:一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。</p>
<p><strong>开发工作量</strong>的对比:<br>Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射,可以更专注于业务流程</p>
<p><strong>sql优化</strong>方面:<br>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。</p>
<p>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p>
<p>对象管理的对比:<br>Hibernate是完整的对象&#x2F;关系映射解决方案，它提供了对象状态管理(state management)的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的JDBC&#x2F;SQL持久层方案中需要管理SQL语句，Hibernate采用了更自然的面向对象的视角来持久化Java应用中的数据。<br>换句话说，使用Hibernate的开发者应该总是关注对象的状态（state)，不必考虑SQL语句的执行。这部分细节已经由 Hibernate掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p>
<p>缓存机制对比:<br>相同点:都可以实现自己的缓存或使用其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</p>
<p>不同点: Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是哪种缓存。</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>两者比较:因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>
<p>而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>Hibernate功能强大数据库无关性好，O&#x2F;R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。</p>
<p>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O&#x2F;R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。</p>
<p>MYBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。</p>
<p>MYBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</p>
<h1 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么?"></a>#{}和${}的区别是什么?</h1><p>#{}是预编译处理、是占位符，${}是字符串替换、是拼接符。<br>Mybatis在处理&#x3D;&#x3D;#{}&#x3D;&#x3D;时，会将sql中的&#x3D;&#x3D;#{}&#x3D;&#x3D;替换为?号，调用PreparedStatement来赋值;</p>
<p>Mybatis在处理&#x3D;&#x3D;${}&#x3D;&#x3D;时，就是把&#x3D;&#x3D;${}&#x3D;&#x3D;替换成变量的值，调用Statement来赋值;</p>
<p>#{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号</p>
<p>&#x3D;&#x3D;${}&#x3D;&#x3D;的变量替换是在DBMS外、变量替换后，&#x3D;&#x3D;${}&#x3D;&#x3D;对应的变量不会加上单引号</p>
<p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h1 id="简述Mybatis的插件运行原理，如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，如何编写一个插件。"></a>简述Mybatis的插件运行原理，如何编写一个插件。</h1><p>答: Mybatis 只支持针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的 invoke()方法，拦截那些你指定需要拦截的方法。</p>
<p>编写插件:实现Mybatis 的 Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，在配置文件中配置编写的插件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">    @Signature(type = StatementHandler.c1ass，method = &quot;query&quot;,</span></span><br><span class="line"><span class="meta">               args =&#123;Statement.class, ResultHandler.class]),</span></span><br><span class="line"><span class="meta">	@signature(type = StatementHandler.c1ass，method = &quot;update&quot;,</span></span><br><span class="line"><span class="meta">               args =&#123;Statement.class&#125;,</span></span><br><span class="line"><span class="meta">	@signature(type = StatementHand1er.c1ass，method = &quot;batch&quot;,,</span></span><br><span class="line"><span class="meta">               args = &#123;Statement.c1ass &#125;)</span></span><br><span class="line"><span class="meta">               &#125;)</span></span><br><span class="line"><span class="meta">@component</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">invocation.proceed()执行具体的业务逻辑</span></span><br></pre></td></tr></table></figure>

<h1 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h1><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理:就是把无序的数据变成有序的查询</p>
<ol>
<li><p>把创建了索引的列的内容进行排序</p>
</li>
<li><p>对排序结果生成倒排表</p>
</li>
<li><p>在倒排表内容上拼上数据地址链</p>
</li>
<li><p>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p>
</li>
</ol>
<h1 id="mysql聚簇和非聚簇索引的区别"><a href="#mysql聚簇和非聚簇索引的区别" class="headerlink" title="mysql聚簇和非聚簇索引的区别"></a>mysql聚簇和非聚簇索引的区别</h1><p>都是B+树的数据结构</p>
<ul>
<li>聚簇索引:将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即:只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</li>
<li>非聚簇索引:叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本书的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优势:</span><br><span class="line">1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高</span><br><span class="line">2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的</span><br><span class="line">3、聚簇索引适合用在排序的场合，非聚簇索引不适合</span><br><span class="line"></span><br><span class="line">劣势:</span><br><span class="line">1、维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片</span><br><span class="line">2、表因为使用UUId(随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键</span><br><span class="line">3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值;过长的主键值，会导致非叶子节点占用占用更多的物理空间</span><br></pre></td></tr></table></figure>

<p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏ijd来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>MyISAM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p>如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小,这些操作是需要在内存中完成的。</p>
<h1 id="mysql索引的数据结构，各自优劣"><a href="#mysql索引的数据结构，各自优劣" class="headerlink" title="mysql索引的数据结构，各自优劣"></a>mysql索引的数据结构，各自优劣</h1><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，InnoDB存储引擎的默认索引实现为:B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快; 其余大部分场景，建议选择B+Tree索引。</p>
<p>B+树:<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517162629444.png" alt="image-20210517162629444"></p>
<p>哈希索引:<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快</p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517162818524.png" alt="image-20210517162818524"></p>
<p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值;前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据;</p>
<p>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索;</p>
<p>哈希索引也没办法利用索引完成排序，以及like ‘xxx%’这样的部分模糊查询(这种部分模糊查询，其实本质上也是范围查询);</p>
<p>哈希索引也不支持多列联合索引的最左匹配规则;</p>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。</p>
<h1 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则?"></a>索引设计的原则?</h1><p>查询更快、占用空间更小</p>
<ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、 image和bit的数据类型的列不要建立索引。</li>
</ol>
<h1 id="锁的类型有哪些"><a href="#锁的类型有哪些" class="headerlink" title="锁的类型有哪些"></a>锁的类型有哪些</h1><p>基于锁的属性分类: 共享锁、排他锁。</p>
<p>基于锁的粒度分类: 行级锁(INNODB)、表级锁(INNODB、MYISAM)、页级锁(BDB引擎)、记录锁、间隙锁、临键锁。</p>
<p>基于锁的状态分类: 意向共享锁、意向排它锁。</p>
<p>共享锁(Share Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共享锁又称读锁，简称S锁;当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</span><br></pre></td></tr></table></figure>

<p>排他锁(exclusive Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排他锁又称写锁，简称X锁;当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。</span><br></pre></td></tr></table></figure>

<p>表锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问;</span><br><span class="line">特点:粒度大，加锁简单，容易冲突;</span><br></pre></td></tr></table></figure>

<p>行锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问;</span><br><span class="line">特点:粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高;</span><br></pre></td></tr></table></figure>

<p>记录锁(Record Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。</span><br><span class="line">精准条件命中，并且命中的条件字段是唯一索引</span><br><span class="line">加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</span><br></pre></td></tr></table></figure>

<p>页锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</span><br><span class="line">特点:开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般</span><br></pre></td></tr></table></figure>

<p>间隙锁(Gap Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属于行锁中的一种，间隙锁是在事务加锁后其锁化的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。</span><br><span class="line">范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。</span><br><span class="line">触发条件:防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。</span><br><span class="line"></span><br><span class="line">比如表里面的数据ID为1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间(-n代表负无穷大，n代表正无穷大&gt;</span><br><span class="line">选择语言</span><br></pre></td></tr></table></figure>

<p>临建锁(Next-Key Lock)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住</span><br><span class="line">触发条件:范围查询并命中，查询命中了索引。</span><br><span class="line">结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插</span><br><span class="line">入。</span><br></pre></td></tr></table></figure>



<p><strong>如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。</strong></p>
<p>意向共享锁</p>
<p>当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。</p>
<p>意向排他锁</p>
<p>当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。</p>
<h1 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h1><p>事务基本特性ACID分别是:</p>
<p><strong>原子性</strong>指的是一个事务中的操作要么全部成功，要么全部失败。</p>
<p><strong>一致性</strong>指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B 100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证</p>
<p><strong>隔离性</strong>指的是一个事务的修改在最终提交前，对其他事务是不可见的。</p>
<p><strong>持久性</strong>指的是一旦事务提交，所做的修改就会永久保存到数据库中。</p>
<p>隔离性有4个隔离级别，分别是:</p>
<ul>
<li>read uncommit读未提交，可能会读到其他事务未提交的数据，也叫做脏读。</li>
</ul>
<p>  用户本来应该读取到id&#x3D;1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age&#x3D;20，这就是脏读。</p>
<ul>
<li><p>read commit读已提交，两次读取结果不一致，叫做不可重复读。</p>
<p>不可重复读解决了脏读的问题，他只会读取已经提交的事务。</p>
<p>用户开启事务读取id&#x3D;1用户，查询到age&#x3D;10，再次读取发现结果&#x3D;20，在同一个事务里同一个查询读取到不同</p>
</li>
<li><p>repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</p>
</li>
<li><p>serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</p>
</li>
</ul>
<p>脏读(Drity Read):某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<h1 id="关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过"><a href="#关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过" class="headerlink" title="关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?"></a>关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?</h1><p>在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>
<p>慢查询的优化首先要搞明白慢的原因是什么?是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?</p>
<p>所以优化也是针对这三个方向来的，</p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h1 id="ACID靠什么保证的"><a href="#ACID靠什么保证的" class="headerlink" title="ACID靠什么保证的?"></a>ACID靠什么保证的?</h1><p>A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sqlC一致性由其他三大特性保证、程序代码要保证业务上的一致性<br>l隔离性由MVCC来保证</p>
<p>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redolog恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnoDB redo log写盘，InnoDB事务进入 prepare状态。</span><br><span class="line">如果前面 prepare成功，bin1og写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么、InnoDB事务则进入commit 状态(在 redo log里面写一个commit记录)</span><br></pre></td></tr></table></figure>

<p>redolog的刷盘会在系统空闲时进行</p>
<h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><p>多版本并发控制:读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链</p>
<p>MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容,因为READ UNCOMMITTED总是读取最新的数据行,而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>
<p>聚簇索引记录中有两个必要的隐藏列:</p>
<p>trx_id: 用来存储每次对某条聚簇索引记录进行修改的时候的事务id。 </p>
<p>roll _pointer:   每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
<p><strong>已提交读和可重复读的区别就在于它们生成Readview的策略不同。</strong></p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210517172428904.png" alt="image-20210517172428904"></p>
<p>开始事务时创建readview, readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组访问数据，获取数据中的事务id(获取的是事务id最大的记录)，对比readview:</p>
<p>如果在readview的左边(比readview都小)，可以访问(在左边意味着该事务已经提交)</p>
<p>如果在readview的右边(比readview都大)或者就在readview中，不可以访问，获取roll_pointer，取上一版本重新对比(在右边意味着，该事务在readview生成之后出现，在readview中意味着该事务还未提交)</p>
<p>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。<br>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读·写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。</p>
<h1 id="mysql主从同步原理"><a href="#mysql主从同步原理" class="headerlink" title="mysql主从同步原理"></a>mysql主从同步原理</h1><p>mysql主从同步的过程:<br>Mysql的主从复制中主要有三个线程: master (binlog dump thread 、slave (I&#x2F;O thread . SQL thread） , Master—条线程和Slave中的两条线程。</p>
<ul>
<li>主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog,是数据库服务器启动的那—刻起，保存所有修改数据库结构或内容的一个文件。</li>
<li>主节点 log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。·从节点Io线程接收binlog内容，并将其写入到relay log 文件中。</li>
<li>从节点的SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性。</li>
</ul>
<p>注:主从节点使用binglog文件+ position偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从position的位置发起同步。</p>
<p>由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。</p>
<p><strong>全同步复制</strong></p>
<p>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</p>
<p><strong>半同步复制</strong></p>
<p>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</p>
<h1 id="简述MylSAM和InnoDB的区别"><a href="#简述MylSAM和InnoDB的区别" class="headerlink" title="简述MylSAM和InnoDB的区别"></a>简述MylSAM和InnoDB的区别</h1><p><strong>MyISAM:</strong></p>
<p>不支持事务，但是每次查询都是原子的:</p>
<p>支持表级锁，即每次操作是对整个表加锁;</p>
<p>存储表的总行数;</p>
<p>一个MYISAM表有三个文件:索引文件、表结构文件、数据文件;</p>
<p>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯—性。</p>
<p><strong>lnnoDb:</strong></p>
<p>支持ACID的事务，支持事务的四种隔离级别;</p>
<p>支持行级锁及外键约束:因此可以支持写并发;</p>
<p>不存储总行数;</p>
<p>一个InnoDb引擎存储在一个文件空间(共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里)，也有可能为多个(设置为独立表空，表大小受操作系统文件大小限制，一般为2G)，受操作系统文件大小的限制;</p>
<p>主键索引采用聚集索引(索引的数据域存储数据文件本身)，辅索引的数据域存储主键的值;因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引;最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</p>
<h1 id="简述mysql中索引类型及对数据库的性能的影响"><a href="#简述mysql中索引类型及对数据库的性能的影响" class="headerlink" title="简述mysql中索引类型及对数据库的性能的影响"></a>简述mysql中索引类型及对数据库的性能的影响</h1><p>普通索引:允许被索引的数据列包含重复的值。</p>
<p>唯一索引:可以保证数据记录的唯一性。</p>
<p>主键:是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY 来创建。</p>
<p>联合索引:索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。</p>
<p>全文索引:通过建立<code>倒排索引</code>,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT(column);创建全文索引</p>
<p>索引可以极大的提高数据的查询速度。</p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。</p>
<h1 id="RDB和AOF机制"><a href="#RDB和AOF机制" class="headerlink" title="RDB和AOF机制"></a>RDB和AOF机制</h1><p><strong>RDB: Redis DataBase</strong></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>优点:</p>
<p>1、整个Redis数据库将只包含一个文件dump.rdb，方便持久化。</p>
<p>2、容灾性好，方便备份。</p>
<p>3、性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能</p>
<p>4.相对于数据集大时，比AOF的启动效率更高。</p>
<p>缺点:</p>
<p>1、数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p>
<p>2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p><strong>AOF: Append only File</strong></p>
<p>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录</p>
<p>优点:</p>
<p>1、数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。</p>
<p>2、通过 append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题。</p>
<p>3、AOF 机制的 rewrite模式。定期对AOF文件进行重写，以达到压缩的目的</p>
<p>缺点:</p>
<p>1、AOF文件比 RDB文件大，且恢复速度慢。</p>
<p>2、数据集大的时候，比rdb启动效率低。</p>
<p>3、运行效率没有RDB高</p>
<p><strong>AOF文件比RDB更新频率高，优先使用AOF还原数据。</strong></p>
<h1 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h1><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<ul>
<li>惰性过期:只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期:每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h1 id="Redis线程模型、单线程快的原因"><a href="#Redis线程模型、单线程快的原因" class="headerlink" title="Redis线程模型、单线程快的原因"></a>Redis线程模型、单线程快的原因</h1><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器file event handler。这个文件事件处理器，它是单线程的，所以Redis 才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。</p>
<p>文件事件处理器的结构包含4个部分:多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等)。<br>多个Socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。<br>然后一个Socket的事件处理完之后，IO多路复用程序才会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件，来选择对应的事件处理器来处理。</p>
<p><strong>单线程快的原因:</strong></p>
<p><strong>1) 纯内存操作</strong></p>
<p><strong>2) 核心是基于非阻塞的IO多路复用机制</strong></p>
<p><strong>3) 单线程反而避免了多线程的频繁上下文切换带来的性能问题</strong></p>
<h1 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h1><p><strong>缓存雪崩</strong>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案:</p>
<ul>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li>
<li>缓存预热</li>
<li>互斥锁</li>
</ul>
<p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案:</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截;</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li>
</ul>
<p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ul>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁</li>
</ul>
<h1 id="Redis的渐进式rehash原理"><a href="#Redis的渐进式rehash原理" class="headerlink" title="Redis的渐进式rehash原理"></a>Redis的渐进式rehash原理</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/01/%E9%9D%A2%E8%AF%952/" data-id="cl0j84jyv00ey04vh5kld1ggt" data-title="面试题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/01/%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-30T16:00:00.000Z" itemprop="datePublished">2021-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/01/%E9%9D%A2%E8%AF%95/">面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基础："><a href="#基础：" class="headerlink" title="基础："></a>基础：</h1><h4 id="get和post的区别："><a href="#get和post的区别：" class="headerlink" title="get和post的区别："></a>get和post的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、get是拼接在url后面，post是放在请求体里</span><br><span class="line">2、get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制</span><br><span class="line">3、get安全性非常低，post安全性较高</span><br><span class="line">4、get请求只能进行url编码，而post支持多种编码方式</span><br><span class="line">5、get数会被完整保留在浏览器历史记录里，而post中的参数不会被保留</span><br><span class="line">6、对于get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>get</th>
<th>post</th>
</tr>
</thead>
<tbody><tr>
<td>拼接在url后面</td>
<td>请求里面</td>
</tr>
<tr>
<td>传送数据大小&lt;2kb</td>
<td>无大小限制</td>
</tr>
<tr>
<td>url编码</td>
<td>各种编码</td>
</tr>
<tr>
<td>不安全</td>
<td>安全</td>
</tr>
<tr>
<td>参数保留在浏览器中</td>
<td>不会保留在浏览器中</td>
</tr>
<tr>
<td>heaher、data一并发送，响应200</td>
<td>先发送header，响应100后发送data，响应200</td>
</tr>
</tbody></table>
<h4 id="String、StringBuffer、StringBuilder的区别："><a href="#String、StringBuffer、StringBuilder的区别：" class="headerlink" title="String、StringBuffer、StringBuilder的区别："></a>String、StringBuffer、StringBuilder的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String的值是不可变</span><br><span class="line">StringBuffer的值是可变的，是线程安全的，是多线程操作字符串</span><br><span class="line">StringBuilder的值是可变的，是线程不安全的，是单线程操作字符串，速度比StringBuffer要快。</span><br></pre></td></tr></table></figure>

<h4 id="抽象类和接口的对比："><a href="#抽象类和接口的对比：" class="headerlink" title="抽象类和接口的对比："></a><strong>抽象类和接口的对比：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">***************相同点***************</span><br><span class="line">1.接口和抽象类都不能实例化</span><br><span class="line">2.都位于继承的顶端，用于被其他实现或继承</span><br><span class="line">3.都包含抽象方法，其子类都必须覆写这些抽象方法</span><br><span class="line"></span><br><span class="line">***************不同点***************</span><br><span class="line">从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>实例化</td>
<td>不能</td>
<td>不能</td>
</tr>
<tr>
<td>继承</td>
<td>抽象类可以继承一个类和多个接口；子类只能继承一个抽象类</td>
<td>接口可以继承多个接口；子类也可以继承多个接口</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public、protected、default修饰</td>
<td>接口只能是public</td>
</tr>
<tr>
<td>实现方法</td>
<td>可以定义构造方法，可以有抽象方法和具体方法</td>
<td>只能有抽象方法</td>
</tr>
<tr>
<td>实现方式</td>
<td>extends</td>
<td>implement</td>
</tr>
<tr>
<td>作用</td>
<td>把相同的东西提取出来重用</td>
<td>为了把程序模块固化，降低耦合</td>
</tr>
</tbody></table>
<h4 id="BIO、NIO、AIO的区别："><a href="#BIO、NIO、AIO的区别：" class="headerlink" title="BIO、NIO、AIO的区别："></a>BIO、NIO、AIO的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BIO: 同步阻塞I/O模式。阻塞等待直到处理完成</span><br><span class="line">NIO: 同步非阻塞的I/O模型。通过选择器监听多个通道，非阻塞，处理完成之后就返回</span><br><span class="line">AIO：异步非阻塞的I/O模型。通知回调</span><br></pre></td></tr></table></figure>

<p><strong>1.BIO (同步阻塞I&#x2F;O模式)</strong></p>
<p>数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<p>这里使用那个经典的烧开水例子，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做</p>
<p><strong>2.NIO（同步非阻塞）</strong></p>
<p>同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I&#x2F;O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。</p>
<p><strong>3.AIO （异步非阻塞I&#x2F;O模型）</strong></p>
<p>异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。</p>
<h4 id="Object类有哪些方法："><a href="#Object类有哪些方法：" class="headerlink" title="Object类有哪些方法："></a>Object类有哪些方法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.getClass方法</span><br><span class="line">2.hashCode方法</span><br><span class="line">3.equals方法</span><br><span class="line">4.clone方法</span><br><span class="line">6.wait方法</span><br><span class="line">7.notify方法</span><br><span class="line">8.notifyAll方法</span><br><span class="line">9.finalize</span><br></pre></td></tr></table></figure>

<h4 id="创建对象的几种方式："><a href="#创建对象的几种方式：" class="headerlink" title="创建对象的几种方式："></a>创建对象的几种方式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、用new语句创建对象</span><br><span class="line">2、运用反射手段</span><br><span class="line">3、调用对象的clone()方法</span><br><span class="line">4、运用反序列化手段</span><br></pre></td></tr></table></figure>



<h1 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h1><h4 id="HashMap的实现："><a href="#HashMap的实现：" class="headerlink" title="HashMap的实现："></a>HashMap的实现：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap是数组和链表的结合体，是基于 Hash 算法实现的</span><br><span class="line"></span><br><span class="line">1.当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</span><br><span class="line">2.存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</span><br><span class="line">3.获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</span><br><span class="line"></span><br><span class="line">Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率</span><br></pre></td></tr></table></figure>

<h4 id="HashMap1-7和1-8的区别："><a href="#HashMap1-7和1-8的区别：" class="headerlink" title="HashMap1.7和1.8的区别："></a>HashMap1.7和1.8的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法。</span><br><span class="line">2、扩容后数据存储位置的计算方式不一样。</span><br><span class="line">3、JDK1.7的时候使用的是数组+ 链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210705163522659.png" alt="image-20210705163522659"></p>
<h4 id="HashMap和HashTable的区别："><a href="#HashMap和HashTable的区别：" class="headerlink" title="HashMap和HashTable的区别："></a>HashMap和HashTable的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。</span><br><span class="line">2、效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。</span><br><span class="line">3、对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</span><br><span class="line">4、初始容量大小和每次扩充容量大小的不同： Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。</span><br><span class="line">5、底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</span><br></pre></td></tr></table></figure>

<h4 id="HashMap-和-ConcurrentHashMap-的区别："><a href="#HashMap-和-ConcurrentHashMap-的区别：" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别："></a>HashMap 和 ConcurrentHashMap 的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</span><br><span class="line">2、HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</span><br></pre></td></tr></table></figure>

<h4 id="ConcurrentHashMap-和-Hashtable-的区别："><a href="#ConcurrentHashMap-和-Hashtable-的区别：" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别："></a>ConcurrentHashMap 和 Hashtable 的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable的底层数据结构是采用 数组+链表 的形式；</span><br><span class="line">2、实现线程安全的方式： （1）在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（2）Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-和-LinkedList-的区别是什么："><a href="#ArrayList-和-LinkedList-的区别是什么：" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么："></a>ArrayList 和 LinkedList 的区别是什么：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</span><br><span class="line">随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</span><br><span class="line">增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</span><br><span class="line">内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</span><br><span class="line">线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-和-Vector-的区别："><a href="#ArrayList-和-Vector-的区别：" class="headerlink" title="ArrayList 和 Vector 的区别："></a>ArrayList 和 Vector 的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</span><br><span class="line">性能：ArrayList 在性能方面要优于 Vector。</span><br><span class="line">扩容：ArrayList 和 Vector 初始容量都是10，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</span><br></pre></td></tr></table></figure>

<h4 id="解决哈希冲突的办法："><a href="#解决哈希冲突的办法：" class="headerlink" title="解决哈希冲突的办法："></a>解决哈希冲突的办法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.开放定址法（将key存放到冲突位置的下一个空位置去）</span><br><span class="line">3.拉链法(Java hashmap就是这么做的)</span><br><span class="line">2.再哈希法（再次哈希，直到冲突不再发生）</span><br><span class="line">4.建立一个公共溢出区（建立一个公共溢出区域，就是把冲突的都放在另一个地方，不在表里面）</span><br></pre></td></tr></table></figure>

<h1 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h1><h4 id="sleep-和-wait-有什么区别："><a href="#sleep-和-wait-有什么区别：" class="headerlink" title="sleep() 和 wait() 有什么区别："></a>sleep() 和 wait() 有什么区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</span><br><span class="line">2、是否释放锁：sleep() 不释放锁；wait() 释放锁。</span><br><span class="line">3、用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</span><br></pre></td></tr></table></figure>

<h4 id="wait-和await-区别："><a href="#wait-和await-区别：" class="headerlink" title="wait()和await()区别："></a>wait()和await()区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wait()是Object类提供的，一般与synchronized联合使用。</span><br><span class="line">await()Condition类是当中的，一般与Lock联合使用。</span><br></pre></td></tr></table></figure>

<h4 id="synchronized-和-Lock-有什么区别："><a href="#synchronized-和-Lock-有什么区别：" class="headerlink" title="synchronized 和 Lock 有什么区别："></a>synchronized 和 Lock 有什么区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</span><br><span class="line">2、synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</span><br><span class="line">3、synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁；而 lock 需要自己加锁和释放锁。</span><br><span class="line">4、通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</span><br></pre></td></tr></table></figure>



<h4 id="Synchronized与ReentrantLock的区别："><a href="#Synchronized与ReentrantLock的区别：" class="headerlink" title="Synchronized与ReentrantLock的区别："></a>Synchronized与ReentrantLock的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、底层实现上来说，synchronized 是JVM层面的锁，是Java关键字；ReentrantLock 是从jdk提供的API层面的锁。</span><br><span class="line">2、synchronized 不需要用户去手动获取和释放锁； ReentrantLock则需要用户去手动获取和释放锁。</span><br><span class="line">4、synchronized为非公平锁；ReentrantLock则即可以选公平锁也可以选非公平锁。</span><br><span class="line">5、ReentrantLock通过Condition可以绑定多个条件实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</span><br><span class="line">6、ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>SYCHRONIZED</th>
<th>REENTRANTlOCK</th>
</tr>
</thead>
<tbody><tr>
<td>是java关键字、jvm层面</td>
<td>api层面、lock子类</td>
</tr>
<tr>
<td>不需要手动加锁解锁</td>
<td>需要手动获取和释放锁</td>
</tr>
<tr>
<td>非公平锁</td>
<td>公平和非公平</td>
</tr>
<tr>
<td>使用类、方法、代码块</td>
<td>使用代码块</td>
</tr>
</tbody></table>
<h4 id="锁的类型："><a href="#锁的类型：" class="headerlink" title="锁的类型："></a>锁的类型：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">偏向锁/轻量级锁/重量级锁</span><br><span class="line"></span><br><span class="line">可重入锁/非可重入锁</span><br><span class="line"></span><br><span class="line">共享锁/独占锁</span><br><span class="line"></span><br><span class="line">公平锁/非公平锁</span><br><span class="line"></span><br><span class="line">悲观锁/乐观锁</span><br><span class="line"></span><br><span class="line">自旋锁/非自旋锁</span><br><span class="line"></span><br><span class="line">可中断锁/不可中断锁</span><br></pre></td></tr></table></figure>

<h4 id="synchronized-锁升级的原理："><a href="#synchronized-锁升级的原理：" class="headerlink" title="synchronized 锁升级的原理："></a>synchronized 锁升级的原理：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocal-："><a href="#ThreadLocal-：" class="headerlink" title="ThreadLocal ："></a>ThreadLocal ：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal类主要解决的就是让每个线程绑定自己的值，每个线程拥有自己的专属本地变量。每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对</span><br><span class="line"></span><br><span class="line">ThreadLocal 内存泄露问题：ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</span><br></pre></td></tr></table></figure>

<h4 id="synchronized的底层实现原理："><a href="#synchronized的底层实现原理：" class="headerlink" title="synchronized的底层实现原理："></a>synchronized的底层实现原理：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">synchronized底层是通过一个monitor的对象来实现的。</span><br><span class="line"></span><br><span class="line">每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</span><br><span class="line">1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</span><br><span class="line">2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</span><br><span class="line">3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</span><br><span class="line"></span><br><span class="line">执行monitorexit的线程必须是object所对应的monitor的所有者。</span><br><span class="line">指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock的底层实现原理："><a href="#ReentrantLock的底层实现原理：" class="headerlink" title="ReentrantLock的底层实现原理："></a>ReentrantLock的底层实现原理：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock的底层实现机制是AQS。AQS没有锁之类的概念，它有个state变量，是个int类型，为了好理解，可以把state当成锁，AQS围绕state提供两种基本操作“获取”和“释放”，有条双向队列存放阻塞的等待线程。AQS的功能可以分为独占和共享，ReentrantLock实现了独占功能（每次只能有一个线程能持有锁）。</span><br></pre></td></tr></table></figure>

<h4 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</span><br><span class="line">2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</span><br><span class="line">3. 阻塞(BLOCKED)：表示线程阻塞于锁。</span><br><span class="line">4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</span><br><span class="line">5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</span><br><span class="line">6. 终止(TERMINATED)：表示该线程已经执行完毕。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="进程和线程的区别："><a href="#进程和线程的区别：" class="headerlink" title="进程和线程的区别："></a>进程和线程的区别：</h4><pre><code>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
</code></pre>
<table>
<thead>
<tr>
<th>区别</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>根本区别</td>
<td>操作系统资源分配的基本单位</td>
<td>处理器任务调度和执行的基本单位</td>
</tr>
<tr>
<td>资源开销</td>
<td>独立的代码和数据空间，开销大</td>
<td>独立的运行栈和程序计数器（PC），开销小</td>
</tr>
<tr>
<td>包含关系</td>
<td>一个进程内有多个线程</td>
<td>线程是进程的一部分</td>
</tr>
<tr>
<td>内存分配</td>
<td>进程之间的地址和资源是独立的</td>
<td>一个进程中的线程之间的地址和资源是共享的</td>
</tr>
<tr>
<td>影响关系</td>
<td>一个进程崩溃不影响其他进程</td>
<td>一个线程崩溃整个进程就死掉</td>
</tr>
<tr>
<td>执行过程</td>
<td>每个独立的进程有程序运行的入口、顺序执行序列和程序出口</td>
<td>不能独立执行，必须依存在应用程序中，由应用程序提供多线程控制</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210705191305676.png" alt="image-20210705191305676"></p>
<h4 id="进程间的通信方式：（不熟悉）"><a href="#进程间的通信方式：（不熟悉）" class="headerlink" title="进程间的通信方式：（不熟悉）"></a><strong>进程间的通信方式：</strong>（不熟悉）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">管道/匿名管道(Pipes)：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</span><br><span class="line"></span><br><span class="line">有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</span><br><span class="line"></span><br><span class="line">信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</span><br><span class="line"></span><br><span class="line">消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</span><br><span class="line"></span><br><span class="line">信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</span><br><span class="line"></span><br><span class="line">共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</span><br><span class="line"></span><br><span class="line">套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</span><br></pre></td></tr></table></figure>

<h4 id="进程间的调度算法："><a href="#进程间的调度算法：" class="headerlink" title="进程间的调度算法："></a>进程间的调度算法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</span><br><span class="line"></span><br><span class="line">短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</span><br><span class="line"></span><br><span class="line">时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</span><br><span class="line"></span><br><span class="line">多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</span><br><span class="line"></span><br><span class="line">优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</span><br></pre></td></tr></table></figure>

<h4 id="线程间的通信方式："><a href="#线程间的通信方式：" class="headerlink" title="线程间的通信方式："></a>线程间的通信方式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、使用全局变量</span><br><span class="line">	主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile</span><br><span class="line">2、wait/notify</span><br><span class="line">3、join方式</span><br><span class="line">4、管道</span><br></pre></td></tr></table></figure>

<h4 id="形成死锁的四个必要条件："><a href="#形成死锁的四个必要条件：" class="headerlink" title="形成死锁的四个必要条件："></a>形成死锁的四个必要条件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放</span><br><span class="line"></span><br><span class="line">请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</span><br><span class="line"></span><br><span class="line">不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</span><br><span class="line"></span><br><span class="line">循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</span><br></pre></td></tr></table></figure>

<p>  <strong>可以通过jdk提供的工具jconsole排查死锁问题</strong></p>
<h4 id="如何避免线程死锁："><a href="#如何避免线程死锁：" class="headerlink" title="如何避免线程死锁："></a>如何避免线程死锁：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</span><br><span class="line"></span><br><span class="line">破坏请求与保持条件：一次性申请所有的资源。</span><br><span class="line"></span><br><span class="line">破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</span><br><span class="line"></span><br><span class="line">破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</span><br></pre></td></tr></table></figure>

<h4 id="线程池有哪几种类型："><a href="#线程池有哪几种类型：" class="headerlink" title="线程池有哪几种类型："></a>线程池有哪几种类型：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、newSingleThreadExecutor：创建一个单线程的线程池。</span><br><span class="line">2、newFixedThreadPool：创建固定大小的线程池。</span><br><span class="line">3、newCachedThreadPool：创建一个可缓存的线程池。</span><br><span class="line">4、newScheduledThreadPool：创建一个定时的线程池。</span><br></pre></td></tr></table></figure>

<h4 id="线程池核心参数："><a href="#线程池核心参数：" class="headerlink" title="线程池核心参数："></a>线程池核心参数：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1个参数：corePoolSize: 核心线程数</span><br><span class="line">第2个参数：maximumPoolSize：线程池中允许存在的工作线程的最大数量</span><br><span class="line">第3个参数: keepAliveTime：线程池中的线程空闲时间</span><br><span class="line">第4个参数: Unit：时间单位。</span><br><span class="line">第5个参数: workQueue：缓存队列。</span><br></pre></td></tr></table></figure>

<h4 id="为什么要用线程池："><a href="#为什么要用线程池：" class="headerlink" title="为什么要用线程池："></a>为什么要用线程池：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</span><br><span class="line"></span><br><span class="line">提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行。</span><br><span class="line"></span><br><span class="line">提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</span><br></pre></td></tr></table></figure>

<h1 id="JVM："><a href="#JVM：" class="headerlink" title="JVM："></a>JVM：</h1><h4 id="JVM运行时数据区域："><a href="#JVM运行时数据区域：" class="headerlink" title="JVM运行时数据区域："></a>JVM运行时数据区域：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</span><br><span class="line">2、虚拟机栈用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表主要存放了编译期可知的各种数据类型和对象引用</span><br><span class="line">3、本地方法栈与虚拟机栈作用相似，不过描述的是Native方法执行的内存模型</span><br><span class="line">4、堆用来存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。(从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用(也就是未逃逸出去)，那么对象可以直接在栈上分配内存。)</span><br><span class="line">5、方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</span><br><span class="line">6、运行时常量池。运行时常量池是方法区的一部分</span><br><span class="line">7、直接内存</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210705164807349.png" alt="image-20210705164807349"></p>
<h4 id="堆的内存模型："><a href="#堆的内存模型：" class="headerlink" title="堆的内存模型："></a>堆的内存模型：</h4><p><img src="https://img-blog.csdnimg.cn/20190819171831432.png" alt="img"></p>
<h4 id="堆和栈的区别："><a href="#堆和栈的区别：" class="headerlink" title="堆和栈的区别："></a>堆和栈的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、堆的物理地址分配对对象是不连续的。因此性能慢些。栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</span><br><span class="line">2、堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</span><br><span class="line">3、堆存放的是对象的实例和数组。栈存放：局部变量，操作数栈，返回结果。</span><br><span class="line">4、堆是线程共享的。栈是线程私有的。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td>物理地址、不连续、性能慢</td>
<td>逻辑地址、连续、性能快</td>
</tr>
<tr>
<td>大小不固定、一般堆大小远远大于栈</td>
<td>大小固定</td>
</tr>
<tr>
<td>存放实例、数组</td>
<td>存放局部变量、操作数栈、返回结果</td>
</tr>
<tr>
<td>线程共享</td>
<td>线程私有</td>
</tr>
</tbody></table>
<h4 id="GC触发条件："><a href="#GC触发条件：" class="headerlink" title="GC触发条件："></a>GC触发条件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MinorGC:</span><br><span class="line">当年轻代空间不足时，就会触发MinorGC，这里的年轻代指的是Eden代满，Survivor满不会触发GC。每次MinorGC会清理年轻代的内存。</span><br><span class="line"></span><br><span class="line">MajorGC:</span><br><span class="line">当老年代空间不足，会先尝试触发MinorGC，如果之后空间还不足，则触发MajorGC。如果MajorGC后，内存还不足，就报OOM了</span><br><span class="line"></span><br><span class="line">FullGC:</span><br><span class="line">1、调用System.gc()时，系统建议执行FullGC，但是不必然执行</span><br><span class="line">2、老年代空间不足、方法区空间不足</span><br><span class="line">3、通过MinorGC后进入老年代的平均大小大于老年代的可用内存</span><br><span class="line">4、由Eden区，Survivor from区向Survivor to区复制时，对象的大小大于to区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象的大小</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收器："><a href="#垃圾回收器：" class="headerlink" title="垃圾回收器："></a>垃圾回收器：</h4><p><img src="E:\MyBolg\source_posts\面试必考题垃圾回收机制\垃圾收集器.png" alt="垃圾收集器"></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial是一类用于新生代的单线程收集器，采用&#x3D;&#x3D;复制算法&#x3D;&#x3D;进行垃圾收集。Serial进行垃圾收集时，不仅只用一条单线程执行垃圾收集工作，它还在收集的同时，所用的用户必须暂停。</p>
<ul>
<li>优势：简单高效，由于采用的是单线程的方法，因此与其他类型的收集器相比，对单个cpu来说没有了上下文之间的的切换，效率比较高。</li>
<li>缺点：会在用户不知道的情况下停止所有工作线程，用户体验感极差，令人难以接受。</li>
<li>适用场景：Client 模式（桌面应用）；单核服务器。</li>
<li>参数： 可以使用命令如下开启Serial作为新生代收集器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserSerialGC <span class="comment">#选择Serial作为新生代垃圾收集器</span></span><br></pre></td></tr></table></figure>



<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>parNew收集器其实就是Serial的一个多线程版本，其在单核cpu上的表现并不会比Serail收集器更好，在多核机器上，其默认开启的收集线程数与cpu数量相等。可以通过如下命令进行修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads <span class="comment">#设置JVM垃圾收集的线程数  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：随着cpu的有效利用，对于GC时系统资源的有效利用有好处。</li>
<li>缺点：和Serial是一样的。</li>
<li>适用场景：ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器。因为CMS收集器只能与serial或者parNew联合使用，在当下多核系统环境下，首选的是parNew与CMS配合。ParNew收集器也是使用CMS收集器后默认的新生代收集器。也可以使用如下命令进行强制指定。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseParNewGC <span class="comment">#新生代采用ParNew收集器 </span></span><br></pre></td></tr></table></figure>



<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge也是一款用于新生代的多线程收集器，也是采用&#x3D;&#x3D;复制算法&#x3D;&#x3D;。<em>与ParNew的不同之处在于 Parallel Scavenge收集器的目的是达到一个可控制的吞吐量，而ParNew收集器关注点在于尽可能的缩短垃圾收集时用户线程的停顿时间。</em>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值， 即吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）。</p>
<ul>
<li>优点： 追求高吞吐量，高效利用CPU，是吞吐量优先，且能进行精确控制。</li>
<li>缺点： “”</li>
<li>适用场景：注重吞吐量高效利用CPU，需要高效运算，且不需要太多交互。</li>
<li>参数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMilis: 控制最大垃圾收集停顿时间，参数值是一个大于0的毫秒数，收集器尽可能保证回收花费时间不超过设定值。但将这个值调小，并不一定会使系统垃圾回收速度更快，GC停顿时间是以牺牲吞吐量和新生代空间换来的。</span><br><span class="line"></span><br><span class="line">-XX:GCTimeRadio:     设置吞吐量大小，参数值是一个(0,100)两侧均为开区间的整数。也是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。若把参数设置为19，则允许的最大GC时间就占总时间的5%（1/（1+19））。默认值是99，即允许最大1%的垃圾收集时间。</span><br><span class="line"></span><br><span class="line">-XX:+UserAdaptiveSizePolicy:这是一个开关函数，当打开这个函数，就不需要手动指定新生代的大小，Eden与Survivor区的比例(-XX:SurvivorRatio，默认是8:1:1)，晋升老年代的对象年龄(-XX:PretenureSizeThreshold)等参数。JVM会动态调整这些参数，以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略.</span><br></pre></td></tr></table></figure>



<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法</p>
<ul>
<li>适用场景：Client模式；单核服务器；与Parallel Scavenge收集器搭配；作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure时使用</li>
</ul>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法，可以充分利用多核CPU的计算能力。</p>
<ul>
<li>适用场景：注重吞吐量与CPU资源敏感的场合，与Parallel Scavenge 收集器搭配使用，jdk7和jdk8默认使用该收集器作为老年代收集器。使用参数进行指定</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserParallelOldGC</span><br></pre></td></tr></table></figure>



<h4 id="CMS-Concurrent-Mark-Sweep-并发标记清除-过程：（不熟悉）"><a href="#CMS-Concurrent-Mark-Sweep-并发标记清除-过程：（不熟悉）" class="headerlink" title="CMS(Concurrent-Mark-Sweep,并发标记清除)过程：（不熟悉）"></a>CMS(Concurrent-Mark-Sweep,并发标记清除)过程：（不熟悉）</h4><p>CMS是老年代垃圾收集器，在收集过程中可以与用户线程并发操作。它可以与Serial收集器和Parallel New收集器搭配使用。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。可以通过JVM启动参数：<code>-XX:+UseConcMarkSweepGC</code>来开启CMS。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMS 处理过程有七个步骤：</span><br><span class="line">1、初始标记(CMS-initial-mark) ,会导致stw;</span><br><span class="line">2、并发标记(CMS-concurrent-mark)，与用户线程同时运行；</span><br><span class="line">3、预清理（CMS-concurrent-preclean），与用户线程同时运行；</span><br><span class="line">4、可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</span><br><span class="line">5、重新标记(CMS-remark) ，会导致swt；</span><br><span class="line">6、并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</span><br><span class="line">7、并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：并发收集，低停顿</li>
<li>缺点：<ul>
<li>CMS收集器对CPU资源非常敏感，CMS默认启动对回收线程数(CPU数量+3)&#x2F;4，当CPU数量在4个以上时，并发回收时垃圾收集线程不少于25%，并随着CPU数量的增加而下降，但当CPU数量不足4个时，对用户影响较大。</li>
<li>CMS无法处理浮动垃圾，可能会出现“Concurrent Mode Failure”失败而导致一次FullGC的产生。这时会地洞后备预案，临时用SerialOld来重新进行老年代的垃圾收集。由于CMS并发清理阶段用户线程还在运行，伴随程序运行自然还会有新的垃圾产生，这部分垃圾出现在标记过程之后，CMS无法在当次处理掉，只能等到下一次GC，这部分垃圾就是浮动垃圾。同时也由于在垃圾收集阶段用户线程还需要运行，那也就需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他老年代几乎完全填满再进行收集。可以通过参数-XX:CMSInitiatingOccupancyFraction修改CMS触发的百分比。</li>
<li>因为CMS采用的是标记清除算法，因此垃圾回收后会产生空间碎片。通过参数可以进行优化。</li>
</ul>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><ul>
<li>概念： G1收集器是一款面向服务端应用的垃圾收集器，目前是JDK9的默认垃圾收集器。与其他收集器相比，G1具有如下特点。<ul>
<li>并行与并发。G1能充分利用多CPU，多核环境下的硬件优势。</li>
<li>分代收集。能够采用不同的方式去处理新创建的对象和已经存活了一段时间的对象，不需要与其他收集器进行合作。</li>
<li>空间整合。G1从整体上来看基于“标记-整理”算法实现的收集器，从局部上看是基于复制算法实现的，因此G1运行期间不会产生空间碎片。</li>
<li>可预测的停顿。G1能建立可预测的时间停顿模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
</li>
</ul>
<p>G1收集器将这个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但两者之间不是物理隔离的。他们都是一部分Region的集合。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16289066-8ebd318e3a078ba6.jpg" alt="img"></p>
<p>每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 &#x3D; 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g&#x2F;2048&#x3D;4M。</p>
<p>G1收集器可以有计划地避免在整个Java堆全区域的垃圾收集。G1可以跟踪各个Region里面垃圾堆积的价值大小（回收所获得的空间大小及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，收集加载最大的region，这种方式保证了有限时间内可以获取尽可能多高的收集效率。</p>
<p>为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1 初始标记。标记出GC Roots直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。</span><br><span class="line">2 并发标记。从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。</span><br><span class="line">3 最终标记。修正在并发标记阶段引用户程序执行而产生变动的标记记录。</span><br><span class="line">4 筛选回收。选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First ，第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>适用场景：要求尽可能可控 GC 停顿时间；内存占用较大的应用。可以用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器</p>
<h4 id="垃圾标记算法："><a href="#垃圾标记算法：" class="headerlink" title="垃圾标记算法："></a>垃圾标记算法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标记-引用计数算法：对每个对象保存一个整型的引用计数器属性，用于记录被对象引用的情况，被对象引用了就+1，引用失效就-1,0表示不可能再被使用，可进行回收。它有一个缺点不能解决循环引用的问题；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</span><br><span class="line"></span><br><span class="line">Java中可作为GC Roots 的对象包括：</span><br><span class="line"> 1.虚拟机栈（栈中的本地变量表） 中引用的对象</span><br><span class="line"> 2.方法区中类静态属性引用的对象</span><br><span class="line"> 3.方法区中常量引用的对象</span><br><span class="line"> 4.本地方法栈中JNI（一般说的Native方法）引用的对象</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收算法："><a href="#垃圾回收算法：" class="headerlink" title="垃圾回收算法："></a>垃圾回收算法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">标记清除算法：标记无用对象，然后进行清除回收。</span><br><span class="line"></span><br><span class="line">标记-清除算法将垃圾收集分为两个阶段：标记阶段：标记出可以回收的对象。清除阶段：回收被标记的对象所占用的空间。</span><br><span class="line"></span><br><span class="line">优点：实现简单，不需要对象进行移动。</span><br><span class="line"></span><br><span class="line">缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复制算法：它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</span><br><span class="line"></span><br><span class="line">优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</span><br><span class="line"></span><br><span class="line">缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标记-整理算法</span><br><span class="line">与标记-清除算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</span><br><span class="line"></span><br><span class="line">优点：解决了标记-清理算法存在的内存碎片问题。</span><br><span class="line"></span><br><span class="line">缺点：仍需要进行局部对象移动，一定程度上降低了效率。</span><br></pre></td></tr></table></figure>

<h4 id="双亲委派："><a href="#双亲委派：" class="headerlink" title="双亲委派："></a>双亲委派：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，从应用程序类加载器到扩展类加载器到启动类加载器，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求时，子加载器才会尝试去加载类。</span><br><span class="line"></span><br><span class="line">采取这种机制的目的：1.防止重复加载同一个类。2.保证核心类不能被篡改。</span><br></pre></td></tr></table></figure>

<h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java安全模型的核心就是Java沙箱。沙箱机制就是讲Java代码限定在虚拟机JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</span><br><span class="line"></span><br><span class="line">沙箱主要限制系统资源访问，例如：CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样</span><br><span class="line"></span><br><span class="line">当前最新的安全机制实现，引入了域（Domain）的概念。虚拟机b所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互。而各个域应用部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，</span><br><span class="line"></span><br><span class="line">通俗来说就是虚拟机把代码加载到拥有不同权限的域里，然后代码就拥有了该域的所有权限。这样就能控制不同代码拥有不同调用操作系统和本地资源的权限</span><br></pre></td></tr></table></figure>



<h4 id="类加载过程："><a href="#类加载过程：" class="headerlink" title="类加载过程："></a>类加载过程：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类装载分为以下 5 个步骤：</span><br><span class="line"></span><br><span class="line">加载：根据查找路径找到相应的 class 文件然后导入；</span><br><span class="line">验证：检查加载的 class 文件的正确性；</span><br><span class="line">准备：给类中的静态变量分配内存空间；</span><br><span class="line">解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</span><br><span class="line">初始化：对静态变量和静态代码块执行初始化工作。</span><br></pre></td></tr></table></figure>

<h4 id="为对象分配内存的方式："><a href="#为对象分配内存的方式：" class="headerlink" title="为对象分配内存的方式："></a>为对象分配内存的方式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</span><br><span class="line">空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</span><br></pre></td></tr></table></figure>

<h4 id="JVM调优："><a href="#JVM调优：" class="headerlink" title="JVM调优："></a>JVM调优：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g：初始化推大小为 2g；</span><br><span class="line">-Xmx2g：最大堆内存大小为 2g；</span><br><span class="line">-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</span><br><span class="line">-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br></pre></td></tr></table></figure>

<h4 id="重要知识点：（内存泄漏）"><a href="#重要知识点：（内存泄漏）" class="headerlink" title="重要知识点：（内存泄漏）"></a>重要知识点：（内存泄漏）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java中内存泄露的场景：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。</span><br></pre></td></tr></table></figure>

<h1 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h1><h4 id="事物的四大特性-ACID-介绍一下："><a href="#事物的四大特性-ACID-介绍一下：" class="headerlink" title="事物的四大特性(ACID)介绍一下："></a>事物的四大特性(ACID)介绍一下：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</span><br><span class="line">一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</span><br><span class="line">隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</span><br><span class="line">持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</span><br></pre></td></tr></table></figure>

<h4 id="数据事务的实现原理："><a href="#数据事务的实现原理：" class="headerlink" title="数据事务的实现原理："></a>数据事务的实现原理：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。</span><br><span class="line"></span><br><span class="line">MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性。</span><br><span class="line"></span><br><span class="line">保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</span><br></pre></td></tr></table></figure>

<h4 id="大表怎么优化："><a href="#大表怎么优化：" class="headerlink" title="大表怎么优化："></a>大表怎么优化：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、限定数据的范围</span><br><span class="line">2、读写分离</span><br><span class="line">3、使用缓存</span><br><span class="line">4、分库分表</span><br></pre></td></tr></table></figure>

<h4 id="索引失效的几种情况："><a href="#索引失效的几种情况：" class="headerlink" title="索引失效的几种情况："></a>索引失效的几种情况：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、使用了or</span><br><span class="line">2、不满足最左匹配原则</span><br><span class="line">3、like以%开头;</span><br><span class="line">4、where中索引列使用了函数;</span><br><span class="line">5、where中索引列使用了运算符</span><br></pre></td></tr></table></figure>

<h4 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则:"></a>创建索引的原则:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、满足最左匹配原则</span><br><span class="line">2、较频繁作为查询条件的字段才去创建索引</span><br><span class="line">3、更新频繁字段不适合创建索引</span><br><span class="line">4、若是不能有效区分数据的列不适合做索引列</span><br><span class="line">5、重复值比较多的列不要建立索引</span><br></pre></td></tr></table></figure>

<h4 id="索引的类型："><a href="#索引的类型：" class="headerlink" title="索引的类型："></a>索引的类型：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。</span><br><span class="line">2.唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</span><br><span class="line">3.主键索引：数据列不允许重复，不允许为NULL，一个表只能有一个主键。</span><br><span class="line">4.组合索引：指多个字段上创建的索引</span><br><span class="line">5.全文索引</span><br></pre></td></tr></table></figure>

<h4 id="Innodb和Myisam的区别："><a href="#Innodb和Myisam的区别：" class="headerlink" title="Innodb和Myisam的区别："></a>Innodb和Myisam的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、InnoDB支持事务，MyISAM不支持</span><br><span class="line">2、InnoDB支持外键，而MyISAM不支持</span><br><span class="line">3、InnoDB是聚集索引， MyISAM是非聚集索引</span><br><span class="line">4、InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</span><br><span class="line">5、Innodb不支持全文索引，而MyISAM支持全文索引</span><br><span class="line">6、Innodb支持哈希索引，而MyISAM不支持哈希索引</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Innodb</th>
<th>myisam</th>
</tr>
</thead>
<tbody><tr>
<td>支持事务</td>
<td>不支持事务</td>
</tr>
<tr>
<td>支持主键</td>
<td>不支持主键</td>
</tr>
<tr>
<td>支持聚簇索引</td>
<td>支持非聚簇索引</td>
</tr>
<tr>
<td>支持表、行锁</td>
<td>支持表锁</td>
</tr>
<tr>
<td>不支持全文索引</td>
<td>支持全文索引</td>
</tr>
<tr>
<td>支持哈希 索引</td>
<td>不支持哈希索引</td>
</tr>
</tbody></table>
<h4 id="日志："><a href="#日志：" class="headerlink" title="日志："></a>日志：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一、重做日志（redo log）</span><br><span class="line">作用：</span><br><span class="line">确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</span><br><span class="line"></span><br><span class="line">二、回滚日志（undo log）</span><br><span class="line">作用：</span><br><span class="line">保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</span><br><span class="line"></span><br><span class="line">三、二进制日志（binlog）：</span><br><span class="line">作用：</span><br><span class="line">用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原。</span><br></pre></td></tr></table></figure>

<h4 id="binlog的三种格式："><a href="#binlog的三种格式：" class="headerlink" title="binlog的三种格式："></a>binlog的三种格式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Statement：每一条会修改数据的sql都会记录在binlog中。</span><br><span class="line">2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。</span><br><span class="line">3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种</span><br></pre></td></tr></table></figure>

<h4 id="B树和B-树："><a href="#B树和B-树：" class="headerlink" title="B树和B+树："></a>B树和B+树：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">区别：</span><br><span class="line"></span><br><span class="line">B树将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</span><br><span class="line"></span><br><span class="line">B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">为什么使用B+树而不是B树：</span><br><span class="line"></span><br><span class="line">1、B树只适合随机检索，而B+树同时支持随机检索和顺序检索</span><br><span class="line">2、B+的磁盘读写代价更低</span><br><span class="line">3、B+树的查询效率更加稳定。</span><br><span class="line">4、解决元素遍历效率低下的问题</span><br><span class="line">5、增删节点时，效率更高。</span><br></pre></td></tr></table></figure>

<h4 id="主从复制："><a href="#主从复制：" class="headerlink" title="主从复制："></a>主从复制：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***************主从复制的作用***************</span><br><span class="line"></span><br><span class="line">主数据库出现问题，可以切换到从数据库。</span><br><span class="line">可以进行数据库层面的读写分离。</span><br><span class="line">可以在从数据库上进行日常备份。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">***************主从复制解决的问题***************</span><br><span class="line"></span><br><span class="line">数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</span><br><span class="line">负载均衡：降低单个服务器的压力</span><br><span class="line">高可用和故障切换：帮助应用程序避免单点失败</span><br><span class="line">升级测试：可以用更高版本的MySQL作为从库</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***************主从复制原理***************</span><br><span class="line"></span><br><span class="line">在主库上把数据更新记录到二进制日志</span><br><span class="line">从库将主库的日志复制到自己的中继日志</span><br><span class="line">从库读取中继日志的事件，将其重放到从库数据中</span><br></pre></td></tr></table></figure>

<h4 id="脏读，不可重复读，幻读："><a href="#脏读，不可重复读，幻读：" class="headerlink" title="脏读，不可重复读，幻读："></a>脏读，不可重复读，幻读：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个回滚了操作，则后一个事务所读取的数据就会是不正确的。</span><br><span class="line">2、不可重复读:在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新了原有的数据。</span><br><span class="line">3、幻读:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</span><br></pre></td></tr></table></figure>

<h4 id="隔离级别："><a href="#隔离级别：" class="headerlink" title="隔离级别："></a>隔离级别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</span><br><span class="line">READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</span><br><span class="line">REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</span><br><span class="line">SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</span><br></pre></td></tr></table></figure>

<p>​       <strong>Mysql 默认采用的可重复读隔离级别</strong></p>
<p><strong>MySQL 中是如何实现事务隔离的</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先说读未提交，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</span><br><span class="line"></span><br><span class="line">再来说串行化。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。</span><br><span class="line"></span><br><span class="line">为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。</span><br></pre></td></tr></table></figure>



<h4 id="Redis缓存和MySQL数据一致性方案："><a href="#Redis缓存和MySQL数据一致性方案：" class="headerlink" title="Redis缓存和MySQL数据一致性方案："></a>Redis缓存和MySQL数据一致性方案：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种方案：采用延时双删策略：（1）先删除缓存   （2）再写数据库  （3）休眠500毫秒   （4）再次删除缓存</span><br><span class="line">第二种方案：异步更新缓存策略：（1）读Redis：热数据基本都在Redis  （2）写MySQL:增删改都是操作MySQL  （3）更新Redis数据：MySQ的数据操作binlog，来更新到Redis</span><br></pre></td></tr></table></figure>

<h4 id="InnoDB三种行锁算法："><a href="#InnoDB三种行锁算法：" class="headerlink" title="InnoDB三种行锁算法："></a>InnoDB三种行锁算法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Record lock：单个行记录上的锁</span><br><span class="line">Gap lock：间隙锁，锁定一个范围，不包括记录本身</span><br><span class="line">Next-key lock：record+gap 锁定一个范围，包含记录本身（当查询的索引含有唯一属性的时候，Next-Key Lock会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。）</span><br></pre></td></tr></table></figure>

<h4 id="MVCC如何工作："><a href="#MVCC如何工作：" class="headerlink" title="MVCC如何工作："></a>MVCC如何工作：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MVCC在每行记录后面都保存着两个隐藏的列：创建版本号和删除版本号。</span><br><span class="line"></span><br><span class="line">1. SELECT</span><br><span class="line">InnoDB会根据以下条件检查每一行记录：</span><br><span class="line">	a. InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的，在事务开始之后才插入的行，事务不会看到。</span><br><span class="line">	b. 行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除，在事务开始之前就已经过期的数据行，该事务也不会看到。</span><br><span class="line">只有符合上述两个条件的才会被查询出来</span><br><span class="line"></span><br><span class="line">2. INSERT</span><br><span class="line">将当前系统版本号作为数据行的创建版本号。</span><br><span class="line"></span><br><span class="line">3. DELETE</span><br><span class="line">将当前系统版本号作为数据行的删除版本号。</span><br><span class="line"></span><br><span class="line">4. UPDATE</span><br><span class="line">将当前系统版本号作为更新前的数据行的删除版本号，并将当前系统版本号作为更新后的数据行的创建版本号。 可以理解为先执行 DELETE 后执行 INSERT。</span><br></pre></td></tr></table></figure>

<h4 id="重要知识点："><a href="#重要知识点：" class="headerlink" title="重要知识点："></a>重要知识点：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">悲观锁大多数情况下依靠数据库的锁机制实现；乐观锁大多数基于数据版本（Version）记录机制实现： 具体可通过给表加一个版本号或时间戳字段实现，当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断当前版本信息与第一次取出来的版本值大小，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据，拒绝更新，让用户重新操作。</span><br><span class="line"></span><br><span class="line">InnoDB是基于索引来完成行锁</span><br><span class="line"></span><br><span class="line">MVCC在读取已提交和可重复读级别下工作，MVCC+next-key locks解决幻读</span><br><span class="line"></span><br><span class="line">hash索引进行等值查询更快(一般情况下，如果发生了hash碰撞，效率可能更差)，但是却无法进行范围查询。</span><br><span class="line"></span><br><span class="line">数据库分片的两种常见方案：客户端代理和中间件代理</span><br></pre></td></tr></table></figure>

<h1 id="计网："><a href="#计网：" class="headerlink" title="计网："></a>计网：</h1><h4 id="HTTPS的工作原理："><a href="#HTTPS的工作原理：" class="headerlink" title="HTTPS的工作原理："></a>HTTPS的工作原理：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</span><br><span class="line"></span><br><span class="line">（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</span><br><span class="line"></span><br><span class="line">（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</span><br><span class="line"></span><br><span class="line">（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</span><br><span class="line"></span><br><span class="line">（5）Web服务器利用自己的私钥解密出会话密钥。</span><br><span class="line"></span><br><span class="line">（6）Web服务器利用会话密钥加密与客户端之间的通信。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="从输入URL到页面加载发生了什么："><a href="#从输入URL到页面加载发生了什么：" class="headerlink" title="从输入URL到页面加载发生了什么："></a>从输入URL到页面加载发生了什么：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、DNS解析</span><br><span class="line">2、TCP连接</span><br><span class="line">3、发送HTTP请求</span><br><span class="line">4、服务器处理请求并返回HTTP报文</span><br><span class="line">5、浏览器解析渲染页面</span><br><span class="line">6、连接结束</span><br></pre></td></tr></table></figure>

<h4 id="拥塞避免："><a href="#拥塞避免：" class="headerlink" title="拥塞避免："></a>拥塞避免：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">慢开始：拥塞窗口cwnd设置为1，接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2，下一次变成4……………… 当拥塞窗口的值为16等于慢开始门限值，之后改用拥塞避免算法。</span><br><span class="line">拥塞避免：每个传输轮次，拥塞窗口cwnd只能线性加1.当发生超时重传时，将门限值设为发生重传时拥塞窗口的一半，拥塞窗口值设置为1，并开始慢开始算法。</span><br><span class="line">快重传：要求接收方在收到一个失序的报文段后就立即发出重复确认。</span><br><span class="line">快恢复算法：当发送方连续收到三个重复确认时，将门限值和拥塞窗口都设置为当前窗口的一半，开始执行拥塞避免。</span><br></pre></td></tr></table></figure>

<h1 id="Redis："><a href="#Redis：" class="headerlink" title="Redis："></a>Redis：</h1><h4 id="哨兵模式："><a href="#哨兵模式：" class="headerlink" title="哨兵模式："></a>哨兵模式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</span><br><span class="line"></span><br><span class="line">集群监控：负责监控 redis master 和 slave 进程是否正常工作。</span><br><span class="line">消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</span><br><span class="line">故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</span><br><span class="line">配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</span><br></pre></td></tr></table></figure>

<h4 id="介绍一下Redis："><a href="#介绍一下Redis：" class="headerlink" title="介绍一下Redis："></a>介绍一下Redis：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis是一个使用C语言编写的，开源的高性能非关系型（NoSQL）的键值对数据库。</span><br><span class="line">Redis的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。</span><br></pre></td></tr></table></figure>

<h4 id="Redis为什么快："><a href="#Redis为什么快：" class="headerlink" title="Redis为什么快："></a>Redis为什么快：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</span><br><span class="line"></span><br><span class="line">2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</span><br><span class="line"></span><br><span class="line">3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</span><br><span class="line"></span><br><span class="line">4、使用多路 I/O 复用模型，非阻塞 IO；</span><br></pre></td></tr></table></figure>

<h4 id="Redis持久化机制："><a href="#Redis持久化机制：" class="headerlink" title="Redis持久化机制："></a>Redis持久化机制：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis 提供两种持久化机制 RDB 和 AOF 两种机制:</span><br><span class="line">RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中</span><br><span class="line">AOF则是将Redis执行的每次写命令记录到单独的日志文件中</span><br></pre></td></tr></table></figure>

<h4 id="Redis有哪些优缺点："><a href="#Redis有哪些优缺点：" class="headerlink" title="Redis有哪些优缺点："></a>Redis有哪些优缺点：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">***************优点***************</span><br><span class="line"></span><br><span class="line">1、读写性能优异</span><br><span class="line">2、支持数据持久化，支持AOF和RDB两种持久化方式。</span><br><span class="line">3、支持事务</span><br><span class="line">4、数据结构丰富</span><br><span class="line">5、支持主从复制</span><br><span class="line"></span><br><span class="line">***************缺点***************</span><br><span class="line"></span><br><span class="line">1、数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</span><br><span class="line">2、Redis 不具备自动容错和恢复功能。</span><br><span class="line">3、主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</span><br><span class="line">4、Redis 较难支持在线扩容。</span><br></pre></td></tr></table></figure>

<h4 id="Redis有哪些数据类型："><a href="#Redis有哪些数据类型：" class="headerlink" title="Redis有哪些数据类型："></a>Redis有哪些数据类型：</h4><p><img src="E:\MyBolg\source_posts\Redis数据类型.png" alt="Redis数据类型"></p>
<h4 id="Redis底层原理："><a href="#Redis底层原理：" class="headerlink" title="Redis底层原理："></a>Redis底层原理：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简单动态字符串（SDS）</span><br><span class="line">链表</span><br><span class="line">字典</span><br><span class="line">跳跃表</span><br><span class="line">整数集合</span><br><span class="line">压缩列表</span><br></pre></td></tr></table></figure>

<h4 id="Redis缓存淘汰策略："><a href="#Redis缓存淘汰策略：" class="headerlink" title="Redis缓存淘汰策略："></a>Redis缓存淘汰策略：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LRU（最近最少使用）：首先淘汰最长时间未被使用的。由hashmap+双向链表实现</span><br><span class="line">LFU（最不经常使用）：淘汰一定时期内被访问次数最少的。由两个hashmap实现</span><br></pre></td></tr></table></figure>

<h4 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line"></span><br><span class="line">1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</span><br><span class="line">2、分布式</span><br><span class="line">3、限流</span><br></pre></td></tr></table></figure>

<h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line"></span><br><span class="line">1、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</span><br><span class="line">2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line">3、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</span><br></pre></td></tr></table></figure>

<h4 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line"></span><br><span class="line">1、设置热点数据永远不过期。</span><br><span class="line">2、加互斥锁</span><br></pre></td></tr></table></figure>

<h1 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h1><h4 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</span><br><span class="line"></span><br><span class="line">JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</span><br><span class="line"></span><br><span class="line">就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</span><br></pre></td></tr></table></figure>

<h4 id="Spring-Bean的生命周期："><a href="#Spring-Bean的生命周期：" class="headerlink" title="Spring Bean的生命周期："></a>Spring Bean的生命周期：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、实例化 Instantiation</span><br><span class="line">2、属性赋值 Populate</span><br><span class="line">3、初始化 Initialization</span><br><span class="line">4、销毁 Destruction</span><br><span class="line"></span><br><span class="line">1、Spring对bean进行实例化；</span><br><span class="line">2、Spring将值和bean的引用注入到bean对应的属性中；</span><br><span class="line">3、如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</span><br><span class="line">4、如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</span><br><span class="line">5、如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</span><br><span class="line">6、如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</span><br><span class="line">7、如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</span><br><span class="line">8、如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</span><br><span class="line">9、此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</span><br><span class="line">10、如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</span><br></pre></td></tr></table></figure>

<h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot:"></a>Springboot:</h1><h4 id="Springboot比Spring好在哪里："><a href="#Springboot比Spring好在哪里：" class="headerlink" title="Springboot比Spring好在哪里："></a>Springboot比Spring好在哪里：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、快速整合第三方框架，比如redis，mybatis等等</span><br><span class="line"></span><br><span class="line">2、全部采用注解方式，没有繁琐的xml配置。</span><br><span class="line"></span><br><span class="line">3、内置http服务器，比如jetty，tomcat。不需要额外的去集成下载tomcat。</span><br></pre></td></tr></table></figure>

<h1 id="Mybatis："><a href="#Mybatis：" class="headerlink" title="Mybatis："></a>Mybatis：</h1><h4 id="和-的区别："><a href="#和-的区别：" class="headerlink" title="#{}和${}的区别："></a>#{}和${}的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、#&#123;&#125;是占位符，预编译处理；$&#123;&#125;是拼接符，字符串替换，没有预编译处理。</span><br><span class="line">2、#&#123;&#125;会在sql中加上&#x27; &#x27;单引号,所以会相对安全,不会有sql注入问题。$&#123;&#125;直接作为SQL本身,不会加单引号,所以有sql注入问题</span><br><span class="line">3、mybatis在处理#&#123;&#125;的时候,会将sql中的#&#123;&#125;替换为?号。mybatis在处理$&#123;&#125;的时候,会将$&#123;&#125;的变量,原原本本的赋值到sql里面</span><br></pre></td></tr></table></figure>

<h1 id="Nginx："><a href="#Nginx：" class="headerlink" title="Nginx："></a>Nginx：</h1><h4 id="Nginx-有哪些负载均衡策略："><a href="#Nginx-有哪些负载均衡策略：" class="headerlink" title="Nginx 有哪些负载均衡策略："></a>Nginx 有哪些负载均衡策略：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、轮询（默认）：每个请求会按时间顺序逐一分配到不同的后端服务器。</span><br><span class="line">2、weight：权重方式，在轮询策略的基础上指定轮询的几率</span><br><span class="line">3、IP 哈希 ip_hash：每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题。</span><br><span class="line">4、最少连接 least_conn：下一个请求将被分派到活动连接数量最少的服务器</span><br><span class="line">5、第三方策略：（1）fair：按照服务器端的响应时间来分配请求，响应时间短的优先分配。（2）url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。</span><br></pre></td></tr></table></figure>

<h1 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h1><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pwd 获取当前工作目录的绝对路径。</span><br><span class="line"></span><br><span class="line">ls ls命令用于显示指定工作目录下的内容</span><br><span class="line"></span><br><span class="line">cd 改变所在目录</span><br><span class="line"></span><br><span class="line">cat 显示文件的内容</span><br><span class="line"></span><br><span class="line">grep 在文件中查找某字符</span><br><span class="line"></span><br><span class="line">cp 复制文件</span><br><span class="line"></span><br><span class="line">touch 创建文件</span><br><span class="line"></span><br><span class="line">mv 移动文件</span><br><span class="line"></span><br><span class="line">rm 删除文件</span><br><span class="line"></span><br><span class="line">rmdir 删除目录</span><br><span class="line"></span><br><span class="line">vi 编辑文件</span><br><span class="line"></span><br><span class="line">zip/unzip 扩展名为zip的压缩/解压缩工具</span><br><span class="line"></span><br><span class="line">ps 查看目前程序执行的情况</span><br><span class="line"></span><br><span class="line">top 查看目前程序执行的情景和内存使用的情况</span><br><span class="line"></span><br><span class="line">kill 终止一个进程</span><br><span class="line"></span><br><span class="line">chmod 用来改变权限</span><br><span class="line"></span><br><span class="line">useradd 用来增加用户</span><br><span class="line"></span><br><span class="line">su 用来修改用户</span><br><span class="line"></span><br><span class="line">head 查看文件的开头部分</span><br><span class="line"></span><br><span class="line">tail 查看文件结尾的10行</span><br><span class="line"></span><br><span class="line">less less是一个分页工具，它允许一页一页地(或一个屏幕一个屏幕地)查看信息</span><br><span class="line"></span><br><span class="line">more more是一个分页工具，它允许一页一页地(或一个屏幕一个屏幕地)查看信息</span><br></pre></td></tr></table></figure>

<h1 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、使用模板模式优化审批过程</span><br><span class="line">原来的审批方法比较臃肿，因为每个流程进行审批操作都是进入这个方法，里面有大量的if、else来判断当前是哪个流程，每个流程又分为申请、变更、关闭，还有对应的业务逻辑，维护、扩展和可读性都比较差。所以对这方面进行了一个优化，就是使用了模板方法模式，定义一个抽象类，包括初始化参数（比如任务信息、流程信息）的方法、审批前的操作、审批后的操作、驳回的操作、任务最后一步处理完的操作。然后每个流程定义一个实现类来继承这个抽象类，这样每个流程可以在自己的实现类里面定义自己的业务逻辑，处理方法里面只要根据流程的标识来获取对应的实现类对象，然后调用方法就行。可扩展性、可读性就比较好。</span><br><span class="line"></span><br><span class="line">2、使用注解优化测试环境的返回结果</span><br><span class="line">我们自己也要进行一些本地测试，为了对线上环境和测试环境进行区分不影响，自定义一个注解，在需要返回结果给前端的方法上加上这个注解，就可以自定义测试结果，然后通过aop做一个环绕通知，通过读取区分环境的标志位，就可以决定是直接调用原有的方法逻辑，还是本地测试，本地测试的话ProceedingJoinPoint对象拿到方法对象，然后再通过反射拿到注解里面的信息，就可以返回我们定义的测试结果。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210705190836903.png" alt="image-20210705190836903"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/01/%E9%9D%A2%E8%AF%95/" data-id="cl0j84jz100fa04vhggbn90ch" data-title="面试题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java深拷贝和浅拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T03:25:03.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">java深拷贝和浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="深拷贝和浅拷贝概念"><a href="#深拷贝和浅拷贝概念" class="headerlink" title="深拷贝和浅拷贝概念"></a>深拷贝和浅拷贝概念</h2><p><strong>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的</strong>。</p>
<p>深拷贝和浅拷贝的示意图大致如下：</p>
<p><img src="/%E6%8B%B7%E8%B4%9D.jpg" alt="拷贝"></p>
<p><img src="E:\MyBolg\source_posts\java深拷贝和浅拷贝\拷贝.jpg" alt="拷贝"></p>
<p><strong>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</strong></p>
<h2 id="赋值和浅拷贝的区别"><a href="#赋值和浅拷贝的区别" class="headerlink" title="赋值和浅拷贝的区别"></a>赋值和浅拷贝的区别</h2><ul>
<li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象的在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>
<li>浅拷贝是按位拷贝对象，<strong>它会创建一个新对象</strong>，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="cl0j84jvr004504vh0t75gf5o" data-title="java深拷贝和浅拷贝" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot记录的一个问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/27/SpringBoot%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-04-27T02:35:02.000Z" itemprop="datePublished">2021-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/27/SpringBoot%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/">SpringBoot记录的一个问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="E:\MyBolg\source_posts\SpringBoot记录的一个问题\1620570426(1).jpg" alt="1620570426(1)"></p>
<p><strong>Cannot resolve method ‘isNotEmpty’ in ‘StringUtils’</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/27/SpringBoot%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/" data-id="cl0j84jwx008l04vhhk02ar1t" data-title="SpringBoot记录的一个问题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Spring中的循环依赖" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/27/Spring%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" class="article-date">
  <time class="dt-published" datetime="2021-04-27T02:35:02.000Z" itemprop="datePublished">2021-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/27/Spring%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">Spring中的循环依赖</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h2><p>很简单，就是A对象依赖了B对象，B对象依赖了A对象。</p>
<p>⽐如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A依赖了B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B依赖了A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么循环依赖是个问题吗？ 如果不考虑Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。 ⽐如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">a.b = b;</span><br><span class="line">b.a = a;</span><br></pre></td></tr></table></figure>

<p>但是，在Spring中循环依赖就是⼀个问题了，为什么？ 因为，在Spring中，⼀个对象并不是简单new出来了，⽽是会经过⼀系列的Bean的⽣命周期，就是因为 Bean的⽣命周期所以才会出现循环依赖问题。当然，在Spring中，出现循环依赖的场景很多，有的场景 Spring⾃动帮我们解决了，⽽有的场景则需要程序员来解决，下⽂详细来说。 要明⽩Spring中的循环依赖，得先明⽩Spring中Bean的⽣命周期。</p>
<h2 id="Bean的⽣命周期"><a href="#Bean的⽣命周期" class="headerlink" title="Bean的⽣命周期"></a>Bean的⽣命周期</h2><p>这里不会对Bean的生命周期进行详细的描述，只描述一下大概的过程。<br>Bean的生命周期指的就是:在Spring中，Bean是如何生成的?<br>被Spring管理的对象叫做Bean。Bean的生成步骤如下:</p>
<ol>
<li>Spring扫描class得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean</li>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象)</li>
<li>填充原始对象中的属性（依赖注入)</li>
<li>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</li>
<li>把最终生成的代理对象放入单例池（源码中叫做singletonObjects)中，下次getBean时就直接从单例池拿即可</li>
</ol>
<p><img src="/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Bean的生命周期"></p>
<p><img src="E:\MyBolg\source_posts\Spring中的循环依赖\Bean的生命周期.png" alt="Bean的生命周期"></p>
<p>可以看到，对于Spring中的Bean的生成过程，步骤还是很多的，并且不仅仅只有上面的7步，还有很多很多，比如Aware回调、初始化等等，这里不详细讨论。</p>
<p>可以发现，在Spring中，构造一个Bean，包括了new这个步骤（第4步构造方法反射)。</p>
<p>得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的?</p>
<p>比如上文说的A类，A类中存在一个B类的b属性，所以，当A类生成了一个原始对象之后，就会去给b属性去赋值，此时就会根据b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean。如果此时BeanFactory中存在B对应的Bean，那么直接拿来赋值给b属性﹔如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的Bean，然后赋值给b属性。</p>
<p>问题就出现在第二种情况，如果此时B类在BeanFactory中还没有生成对应的Bean，那么就需要去生成，就会经过B的Bean的生命周期。</p>
<p>那么在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么在创建B的Bean的过程中就需要A类对应的Bean，但是，触发B类Bean的创建的条件是A类Bean在创建过程中的依赖注入，所以这里就出现了循环依赖:</p>
<p>ABean创建–&gt;依赖了B属性–&gt;触发BBean创建—&gt;B依赖了A属性—&gt;需要ABean(但ABean还在创建过程中)</p>
<p>从而导致ABean创建不出来，BBean也创建不出来。</p>
<p>这是循环依赖的场景，但是上文说了，在Spring中，通过某些机制帮开发者解决了部分循环依赖的问题，这个机制就是<strong>三级缓存</strong>。</p>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>三级缓存是通用的叫法。</p>
<p>​        一级缓存为: singletonObjects</p>
<p>​        二级缓存为: earlySingletonObjects</p>
<p>​        三级缓存为: singletonFactories</p>
<p>先稍微解释一下这三个缓存的作用，后面详细分析:</p>
<p> singletonObjects中缓存的是已经经历了完整生命周期的bean对象。</p>
<p> earlySingletonObjects比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思? 表示Bean的生命周期还没走完就把这个Bean放入了earlySingletonObjects</p>
<p>singletonFactories中缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的。</p>
<h2 id="解决循环依赖思路分析"><a href="#解决循环依赖思路分析" class="headerlink" title="解决循环依赖思路分析"></a>解决循环依赖思路分析</h2><p>先来分析为什么缓存能解决循环依赖。</p>
<p> 上⽂分析得到，之所以产⽣循环依赖的问题，主要是： </p>
<p> A创建时—&gt;需要B—-&gt;B去创建—&gt;需要A，从⽽产⽣了循环</p>
<p>那么如何打破这个循环，加个中间⼈（缓存）</p>
<p>![循环依赖 (1)](循环依赖 (1).png)</p>
<p>![循环依赖 (1)](E:\MyBolg\source_posts\Spring中的循环依赖\循环依赖 (1).png)</p>
<p>A的Bean在创建过程中，在进⾏依赖注⼊之前，先把A的原始Bean放⼊缓存（提早暴露，只要放到缓存 了，其他Bean需要时就可以从缓存中拿了），放⼊缓存后，再进⾏依赖注⼊，此时A的Bean依赖了B的 Bean，如果B的Bean不存在，则需要创建B的Bean，⽽创建B的Bean的过程和A⼀样，也是先创建⼀个B 的原始对象，然后把B的原始对象提早暴露出来放⼊缓存中，然后在对B的原始对象进⾏依赖注⼊A，此时 能从缓存中拿到A的原始对象（虽然是A的原始对象，还不是最终的Bean），B的原始对象依赖注⼊完了之 后，B的⽣命周期结束，那么A的⽣命周期也能结束。</p>
<p>因为整个过程中，都只有⼀个A原始对象，所以对于B⽽⾔，就算在属性注⼊时，注⼊的是A原始对象，也 没有关系，因为A原始对象在后续的⽣命周期中在堆中没有发⽣变化。 </p>
<p>从上⾯这个分析过程中可以得出，只需要⼀个缓存就能解决循环依赖了，那么为什么Spring中还需要 singletonFactories呢？ </p>
<p><strong>这是难点，基于上⾯的场景想⼀个问题：如果A的原始对象注⼊给B的属性之后，A的原始对象进⾏了AOP 产⽣了⼀个代理对象，此时就会出现，对于A⽽⾔，它的Bean对象其实应该是AOP之后的代理对象，⽽B 的a属性对应的并不是AOP之后的代理对象，这就产⽣了冲突。</strong></p>
<p><strong>B依赖的A和最终的A不是同⼀个对象</strong></p>
<p> 那么如何解决这个问题？</p>
<p>这个问题可以说没有办法解决。 因为在⼀个Bean的⽣命周期最后，Spring提供了BeanPostProcessor可以去对Bean进⾏加⼯，这个加⼯ 不仅仅只是能修改Bean的属性值，也可以替换掉当前Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LubanBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>&#123;</span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> 0bject <span class="title function_">postProcessAfterInitialization</span><span class="params">(0bject bean，String beanName )</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//注意这里，生成了一个新的User对象</span></span><br><span class="line">    <span class="keyword">if</span> ( beanName.equals ( <span class="string">&quot;user&quot;</span> )) &#123;</span><br><span class="line">        System.out.println( bean ) ;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>( );</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.</span><br><span class="line">    class);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运⾏main⽅法，得到的打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.luban.service.User@5e025e70</span><br><span class="line">com.luban.service.User@1b0375b3</span><br></pre></td></tr></table></figure>

<p>所以在BeanPostProcessor中可以完全替换掉某个beanName对应的bean对象。 </p>
<p>⽽BeanPostProcessor的执⾏在Bean的⽣命周期中是处于属性注⼊之后的，循环依赖是发⽣在属性注⼊ 过程中的，所以很有可能导致，注⼊给B对象的A对象和经历过完整⽣命周期之后的A对象，不是⼀个对 象。这就是有问题的。 </p>
<p><strong>所以在这种情况下的循环依赖，Spring是解决不了的，因为在属性注⼊时，Spring也不知道A对象后续会 经过哪些BeanPostProcessor以及会对A对象做什么处理。</strong></p>
<h2 id="Spring到底解决了哪种情况下的循环依赖"><a href="#Spring到底解决了哪种情况下的循环依赖" class="headerlink" title="Spring到底解决了哪种情况下的循环依赖"></a>Spring到底解决了哪种情况下的循环依赖</h2><p>虽然上⾯的情况可能发⽣，但是肯定发⽣得很少，我们通常在开发过程中，不会这样去做，但是，某个 beanName对应的最终对象和原始对象不是⼀个对象却会经常出现，这就是AOP。</p>
<p> AOP就是通过⼀个BeanPostProcessor来实现的，这个BeanPostProcessor就是 AnnotationAwareAspectJAutoProxyCreator，它的⽗类是AbstractAutoProxyCreator，⽽在Spring中 AOP利⽤的要么是JDK动态代理，要么CGLib的动态代理，所以如果给⼀个类中的某个⽅法设置了切⾯， 那么这个类最终就需要⽣成⼀个代理对象。</p>
<p> ⼀般过程就是：A类—&gt;⽣成⼀个普通对象–&gt;属性注⼊–&gt;基于切⾯⽣成⼀个代理对象–&gt;把代理对象放 ⼊singletonObjects单例池中。</p>
<p> ⽽AOP可以说是Spring中除开IOC的另外⼀⼤功能，⽽循环依赖⼜是属于IOC范畴的，所以这两⼤功能想 要并存，Spring需要特殊处理。 </p>
<p>如何处理的，就是利⽤了第三级缓存singletonFactories。</p>
<p> ⾸先，singletonFactories中存的是某个beanName对应的ObjectFactory，在bean的⽣命周期中，⽣成 完原始对象之后，就会构造⼀个ObjectFactory存⼊singletonFactories中。这个ObjectFactory是⼀个函 数式接⼝，所以⽀持Lambda表达式：() -&gt; getEarlyBeanReference(beanName, mbd, bean) </p>
<p>上⾯的Lambda表达式就是⼀个ObjectFactory，执⾏该Lambda表达式就会去执⾏ getEarlyBeanReference⽅法，⽽该⽅法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProces</span><br><span class="line">    <span class="title function_">sors</span><span class="params">()</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProc</span><br><span class="line">        essor) &#123;</span><br><span class="line">            <span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            exposedObject=ibp.getEarlyBeanReference(exposed Object, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该⽅法会去执⾏SmartInstantiationAwareBeanPostProcessor中的getEarlyBeanReference⽅法，⽽这个接⼝下的实现类中只有两个类实现了这个⽅法，⼀个是AbstractAutoProxyCreator，⼀个是InstantiationAwareBeanPostProcessorAdapter，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessorAdapter@0verride</span></span><br><span class="line"><span class="keyword">public</span> 0bject <span class="title function_">getEarlyBeanReference</span><span class="params">(0bject bean，String beanName)</span><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="keyword">return</span> bean ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> 0bject <span class="title function_">getEarlyBeanReference</span><span class="params">(0bject bean，String beanName)</span>&#123;</span><br><span class="line">	0<span class="type">bject</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getcacheKey ( bean.getClass( ), beanName ) ;</span><br><span class="line">    <span class="built_in">this</span>.earlyProxyReferences.put( cachekey, bean) ;</span><br><span class="line">	<span class="keyword">return</span> wrapIfNecessary ( bean, beanName,cacheKey ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以很明显，在整个Spring中，默认就只有AbstractAutoProxyCreator真正意义上实现了getEarlyBeanReference⽅法，⽽该类就是⽤来进⾏AOP的。上⽂提到的<br>AnnotationAwareAspectJAutoProxyCreator的⽗类就AbstractAutoProxyCreator。</p>
<p>那么getEarlyBeanReference⽅法到底在⼲什么？</p>
<p>⾸先得到⼀个cachekey，cachekey就是beanName。</p>
<p>然后把beanName和bean（这是原始对象）存⼊earlyProxyReferences中</p>
<p>调⽤wrapIfNecessary进⾏AOP，得到⼀个代理对象。</p>
<p>那么，什么时候会调⽤getEarlyBeanReference⽅法呢？回到循环依赖的场景中</p>
<p>左边⽂字： 这个ObjectFactory就是上⽂说的labmda表达式，中间有getEarlyBeanReference⽅法，注意存⼊ singletonFactories时并不会执⾏lambda表达式，也就是不会执⾏getEarlyBeanReference⽅法 </p>
<p>右边⽂字： 从singletonFactories根据beanName得到⼀个ObjectFactory，然后执⾏ObjectFactory，也就是执⾏ getEarlyBeanReference⽅法，此时会得到⼀个A原始对象经过AOP之后的代理对象，然后把该代理对象 放⼊earlySingletonObjects中，注意此时并没有把代理对象放⼊singletonObjects中，那什么时候放⼊ 到singletonObjects中呢？</p>
<p> 我们这个时候得来理解⼀下earlySingletonObjects的作⽤，此时，我们只得到了A原始对象的代理对象， 这个对象还不完整，因为A原始对象还没有进⾏属性填充，所以此时不能直接把A的代理对象放⼊ singletonObjects中，所以只能把代理对象放⼊earlySingletonObjects，假设现在有其他对象依赖了A， 那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同⼀个代理对象。 </p>
<p>当B创建完了之后，A继续进⾏⽣命周期，⽽A在完成属性注⼊后，会按照它本身的逻辑去进⾏AOP，⽽此 时我们知道A原始对象已经经历过了AOP，所以对于A本身⽽⾔，不会再去进⾏AOP了，那么怎么判断⼀个 对象是否经历过了AOP呢？会利⽤上⽂提到的earlyProxyReferences，在AbstractAutoProxyCreator的 postProcessAfterInitialization⽅法中，会去判断当前beanName是否在earlyProxyReferences，如果 在则表示已经提前进⾏过AOP了，⽆需再次进⾏AOP。</p>
<p> 对于A⽽⾔，进⾏了AOP的判断后，以及BeanPostProcessor的执⾏之后，就需要把A对应的对象放⼊ singletonObjects中了，但是我们知道，应该是要A的代理对象放⼊singletonObjects中，所以此时需要 从earlySingletonObjects中得到代理对象，然后⼊singletonObjects中。</p>
<p><strong>整个循环依赖解决完毕。</strong></p>
<p>总结<br>至此,总结一下三级缓存:</p>
<ol>
<li>singletonObjects:缓存某个beanName对应的经过了完整生命周期的bean</li>
<li>earlySingletonObjects︰缓存提前拿原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</li>
<li>singletonFactories︰缓存的是一个ObjectFactory，主要用来去生成原始对象进行了AOP之后得到的代理对象，在每个Bean的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则另外那个bean执行ObjectFactory提交得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)。</li>
<li>其实还要一个缓存，就是earlyProxyReferences，它用来记录某个原始对象是否进行过AOP了。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/27/Spring%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" data-id="cl0j84jx3009304vh5cvk13ye" data-title="Spring中的循环依赖" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="tag">循环依赖</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/concurrency/">concurrency</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/open-source/">open-source</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/" rel="tag">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E9%A1%B9%E7%9B%AE/" rel="tag">Java项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">MySql、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" rel="tag">Redis、面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Java/" rel="tag">Spring Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E3%80%81blog/" rel="tag">hexo、blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm-memory-management/" rel="tag">jvm-memory-management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty-source/" rel="tag">netty-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-intro/" rel="tag">spring-aop-intro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-source/" rel="tag">spring-aop-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="tag">循环依赖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/Java/" style="font-size: 15.56px;">Java</a> <a href="/tags/Java-JVM/" style="font-size: 18.89px;">Java JVM</a> <a href="/tags/Java-Spring/" style="font-size: 13.33px;">Java Spring</a> <a href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.78px;">Java、面试题</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">Java数据结构</a> <a href="/tags/Java%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">Java项目</a> <a href="/tags/MySql/" style="font-size: 20px;">MySql</a> <a href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.11px;">MySql、面试题</a> <a href="/tags/Redis/" style="font-size: 14.44px;">Redis</a> <a href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Redis、面试</a> <a href="/tags/Spring-Java/" style="font-size: 13.33px;">Spring Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/hexo%E3%80%81blog/" style="font-size: 10px;">hexo、blog</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm-memory-management/" style="font-size: 10px;">jvm-memory-management</a> <a href="/tags/netty-source/" style="font-size: 11.11px;">netty-source</a> <a href="/tags/redis/" style="font-size: 17.78px;">redis</a> <a href="/tags/spring-aop-intro/" style="font-size: 10px;">spring-aop-intro</a> <a href="/tags/spring-aop-source/" style="font-size: 10px;">spring-aop-source</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" style="font-size: 10px;">循环依赖</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/09/update%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97%EF%BC%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/Redis_hot/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM类加载机制</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Lee yunbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>