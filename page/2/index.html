<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MyHomePage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="MyHomePage">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="MyHomePage">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lee yunbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MyHomePage" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MyHomePage</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-KMP算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/KMP%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.484Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/KMP%E7%AE%97%E6%B3%95/">KMP算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="kmp算法-重点：以dp和状态机方式讲解"><a href="#kmp算法-重点：以dp和状态机方式讲解" class="headerlink" title="kmp算法(重点：以dp和状态机方式讲解)"></a>kmp算法(重点：以dp和状态机方式讲解)</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr">28.实现 strStr()</a></p>
<p>KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。</p>
<p><strong>先在开头约定，本文用 <code>pat</code> 表示模式串，长度为 <code>M</code>，<code>txt</code> 表示文本串，长度为 <code>N</code>。KMP 算法是在 <code>txt</code> 中查找子串 <code>pat</code>，如果存在，返回这个子串的起始索引，否则返回 -1</strong>。</p>
<p><strong>本文则用一个二维的 <code>dp</code> 数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高</strong>。</p>
<h3 id="一、KMP-算法概述"><a href="#一、KMP-算法概述" class="headerlink" title="一、KMP 算法概述"></a><strong>一、KMP 算法概述</strong></h3><p>首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。</p>
<p>暴力的字符串匹配算法很容易写，看一下它的运行逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力匹配（伪码）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(String pat, String txt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> pat.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> txt.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N - M; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[j] != txt[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pat 全都匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// txt 中不存在 pat 子串</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于暴力算法，如果出现不匹配字符，同时回退 <code>txt</code> 和 <code>pat</code> 的指针，嵌套 for 循环，时间复杂度 <code>O(MN)</code>，空间复杂度<code>O(1)</code>。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。</p>
<p>比如 txt &#x3D; “aaacaaab” pat &#x3D; “aaab”：</p>
<p><img src="/kmp1.gif" alt="kmp1"></p>
<p>很明显，<code>pat</code> 中根本没有字符 c，根本没必要回退指针 <code>i</code>，暴力解法明显多做了很多不必要的操作。</p>
<p>KMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：</p>
<p><img src="/kmp2.gif" alt="kmp2"></p>
<p>再比如类似的 txt &#x3D; “aaaaaaab” pat &#x3D; “aaab”，暴力解法还会和上面那个例子一样蠢蠢地回退指针 <code>i</code>，而 KMP 算法又会耍聪明：</p>
<p><img src="/kmp3.gif" alt="kmp3"></p>
<p>因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。</p>
<p><strong>KMP 算法永不回退 <code>txt</code> 的指针 <code>i</code>，不走回头路（不会重复扫描 <code>txt</code>），而是借助 <code>dp</code> 数组中储存的信息把 <code>pat</code> 移到正确的位置继续匹配</strong>，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。</p>
<p>KMP 算法的难点在于，如何计算 <code>dp</code> 数组中的信息？如何根据这些信息正确地移动 <code>pat</code> 的指针？这个就需要<strong>确定有限状态自动机</strong>来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 <code>dp</code> 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。</p>
<p>还有一点需要明确的是：<strong>计算这个 <code>dp</code> 数组，只和 <code>pat</code> 串有关</strong>。意思是说，只要给我个 <code>pat</code>，我就能通过这个模式串计算出 <code>dp</code> 数组，然后你可以给我不同的 <code>txt</code>，我都不怕，利用这个 <code>dp</code> 数组我都能在 O(N) 时间完成字符串匹配。</p>
<p>具体来说，比如上文举的两个例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txt1 = &quot;aaacaaab&quot; </span><br><span class="line">pat = &quot;aaab&quot;</span><br><span class="line">txt2 = &quot;aaaaaaab&quot; </span><br><span class="line">pat = &quot;aaab&quot;</span><br></pre></td></tr></table></figure>

<p>我们的 <code>txt</code> 不同，但是 <code>pat</code> 是一样的，所以 KMP 算法使用的 <code>dp</code> 数组是同一个。</p>
<p>只不过对于 <code>txt1</code> 的下面这个即将出现的未匹配情况：</p>
<p><img src="/kmp4.jpg" alt="kmp4"></p>
<p><code>dp</code> 数组指示 <code>pat</code> 这样移动：</p>
<p><img src="/kmp5.jpg" alt="kmp5"></p>
<p>PS：这个<code>j</code> 不要理解为索引，它的含义更准确地说应该是<strong>状态</strong>（state），所以它会出现这个奇怪的位置，后文会详述。</p>
<p>而对于 <code>txt2</code> 的下面这个即将出现的未匹配情况：</p>
<p><img src="/kmp6.jpg" alt="kmp6"></p>
<p><code>dp</code> 数组指示 <code>pat</code> 这样移动：</p>
<p><img src="/kmp7.jpg" alt="kmp7"></p>
<p>明白了 <code>dp</code> 数组只和 <code>pat</code> 有关，那么我们这样设计 KMP 算法就会比较漂亮：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KMP</span><span class="params">(String pat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pat = pat;</span><br><span class="line">        <span class="comment">// 通过 pat 构建 dp 数组</span></span><br><span class="line">        <span class="comment">// 需要 O(M) 时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String txt)</span> &#123;</span><br><span class="line">        <span class="comment">// 借助 dp 数组去匹配 txt</span></span><br><span class="line">        <span class="comment">// 需要 O(N) 时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当我们需要用同一 <code>pat</code> 去匹配不同 <code>txt</code> 时，就不需要浪费时间构造 <code>dp</code> 数组了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KMP</span> <span class="variable">kmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KMP</span>(<span class="string">&quot;aaab&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">pos1</span> <span class="operator">=</span> kmp.search(<span class="string">&quot;aaacaaab&quot;</span>); <span class="comment">//4</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pos2</span> <span class="operator">=</span> kmp.search(<span class="string">&quot;aaaaaaab&quot;</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h3 id="二、状态机概述"><a href="#二、状态机概述" class="headerlink" title="二、状态机概述"></a><strong>二、状态机概述</strong></h3><p>为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 <code>pat</code> 的匹配就是状态的转移。比如当 pat &#x3D; “ABABC”：</p>
<p><img src="/kmp8.jpg" alt="kmp8"></p>
<p>如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（<code>pat.length</code>）是终止状态。开始匹配时 <code>pat</code> 处于起始状态，一旦转移到终止状态，就说明在 <code>txt</code> 中找到了 <code>pat</code>。比如说当前处于状态 2，就说明字符 “AB” 被匹配：</p>
<p><img src="/kmp9.jpg" alt="kmp9"></p>
<p>另外，处于不同状态时，<code>pat</code> 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：</p>
<p><img src="/kmp10.jpg" alt="kmp10"></p>
<p>具体什么意思呢，我们来一个个举例看看。用变量 <code>j</code> 表示指向当前状态的指针，当前 <code>pat</code> 匹配到了状态 4：</p>
<p><img src="/kmp11.jpg" alt="kmp11"></p>
<p>如果遇到了字符 “A”，根据箭头指示，转移到状态 3 是最聪明的：</p>
<p><img src="/kmp12.jpg" alt="kmp12"></p>
<p>如果遇到了字符 “B”，根据箭头指示，只能转移到状态 0（一夜回到解放前）：</p>
<p><img src="/kmp13.jpg" alt="kmp13"></p>
<p>如果遇到了字符 “C”，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：</p>
<p><img src="/kmp14.jpg" alt="kmp14"></p>
<p>当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 <code>pat</code> 中根本都没有字符 Z：</p>
<p><img src="/kmp16.jpg" alt="kmp16"></p>
<p>这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 <code>pat</code> 中出现的字符的状态转移：</p>
<p><img src="/kmp17.jpg" alt="kmp17"></p>
<p>KMP 算法最关键的步骤就是构造这个状态转移图。<strong>要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。</p>
<p>下面看一下 KMP 算法根据这幅状态转移图匹配字符串 <code>txt</code> 的过程：</p>
<p><img src="/kmp18.gif" alt="kmp18"></p>
<p><strong>请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑</strong>！</p>
<p>为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dp[j][c] = next</span><br><span class="line"><span class="number">0</span> &lt;= j &lt; M，代表当前的状态</span><br><span class="line"><span class="number">0</span> &lt;= c &lt; <span class="number">256</span>，代表遇到的字符（ASCII 码）</span><br><span class="line"><span class="number">0</span> &lt;= next &lt;= M，代表下一个状态</span><br><span class="line"></span><br><span class="line">dp[<span class="number">4</span>][<span class="string">&#x27;A&#x27;</span>] = <span class="number">3</span> 表示：</span><br><span class="line">当前是状态 <span class="number">4</span>，如果遇到字符 A，</span><br><span class="line">pat 应该转移到状态 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span> 表示：</span><br><span class="line">当前是状态 <span class="number">1</span>，如果遇到字符 B，</span><br><span class="line">pat 应该转移到状态 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 KMP 算法的 search 函数代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String txt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> pat.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> txt.length();</span><br><span class="line">    <span class="comment">// pat 的初始态为 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前是状态 j，遇到字符 txt[i]，</span></span><br><span class="line">        <span class="comment">// pat 应该转移到哪个状态？</span></span><br><span class="line">        j = dp[j][txt.charAt(i)];</span><br><span class="line">        <span class="comment">// 如果达到终止态，返回匹配开头的索引</span></span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没到达终止态，匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，应该还是很好理解的吧，<code>dp</code> 数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 GIF 的算法演进过程。下面讲解：如何通过 <code>pat</code> 构建这个 <code>dp</code> 数组？</p>
<h3 id="三、构建状态转移图"><a href="#三、构建状态转移图" class="headerlink" title="三、构建状态转移图"></a><strong>三、构建状态转移图</strong></h3><p>回想刚才说的：<strong>要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>，而且我们已经根据这个逻辑确定了 <code>dp</code> 数组的含义，那么构造 <code>dp</code> 数组的框架就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= j &lt; M: # 状态</span><br><span class="line">    <span class="keyword">for</span> <span class="number">0</span> &lt;= c &lt; <span class="number">256</span>: # 字符</span><br><span class="line">        dp[j][c] = next</span><br></pre></td></tr></table></figure>

<p>这个 next 状态应该怎么求呢？显然，<strong>如果遇到的字符 <code>c</code> 和 <code>pat[j]</code> 匹配的话</strong>，状态就应该向前推进一个，也就是说 <code>next = j + 1</code>，我们不妨称这种情况为<strong>状态推进</strong>：</p>
<p><img src="/kmp19.jpg" alt="kmp19"></p>
<p><strong>如果字符 <code>c</code> 和 <code>pat[j]</code> 不匹配的话</strong>，状态就要回退（或者原地不动），我们不妨称这种情况为<strong>状态重启</strong>：</p>
<p><img src="/kmp20.jpg" alt="kmp20"></p>
<p>那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字：<strong>影子状态</strong>（我编的名字），用变量 <code>X</code> 表示。<strong>所谓影子状态，就是和当前状态具有相同的前缀</strong>。比如下面这种情况：</p>
<p><img src="/kmp21.jpg" alt="kmp21"></p>
<p>当前状态 <code>j = 4</code>，其影子状态为 <code>X = 2</code>，它们都有相同的前缀 “AB”。因为状态 <code>X</code> 和状态 <code>j</code> 存在相同的前缀，所以当状态 <code>j</code> 准备进行状态重启的时候（遇到的字符 <code>c</code> 和 <code>pat[j]</code> 不匹配），可以通过 <code>X</code> 的状态转移图来获得<strong>最近的重启位置</strong>。</p>
<p>比如说刚才的情况，如果状态 <code>j</code> 遇到一个字符 “A”，应该转移到哪里呢？首先只有遇到 “C” 才能推进状态，遇到 “A” 显然只能进行状态重启。**状态 <code>j</code> 会把这个字符委托给状态 <code>X</code> 处理，也就是 <code>dp[j][&#39;A&#39;] = dp[X][&#39;A&#39;]</code>**：</p>
<p><img src="/kmp22.jpg" alt="kmp22"></p>
<p>为什么这样可以呢？因为：既然 <code>j</code> 这边已经确定字符 “A” 无法推进状态，<strong>只能回退</strong>，而且 KMP 就是要<strong>尽可能少的回退</strong>，以免多余的计算。那么 <code>j</code> 就可以去问问和自己具有相同前缀的 <code>X</code>，如果 <code>X</code> 遇见 “A” 可以进行「状态推进」，那就转移过去，因为这样回退最少。</p>
<p><img src="/kmp23.gif" alt="kmp23"></p>
<p>当然，如果遇到的字符是 “B”，状态 <code>X</code> 也不能进行「状态推进」，只能回退，<code>j</code> 只要跟着 <code>X</code> 指引的方向回退就行了：</p>
<p><img src="/kmp24.jpg" alt="kmp24"></p>
<p>你也许会问，这个 <code>X</code> 怎么知道遇到字符 “B” 要回退到状态 0 呢？因为 <code>X</code> 永远跟在 <code>j</code> 的身后，状态 <code>X</code> 如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？</p>
<p>这样，我们就细化一下刚才的框架代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> X # 影子状态</span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= j &lt; M:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">0</span> &lt;= c &lt; <span class="number">256</span>:</span><br><span class="line">        <span class="type">if</span> <span class="variable">c</span> <span class="operator">=</span>= pat[j]:</span><br><span class="line">            # 状态推进</span><br><span class="line">            dp[j][c] = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            # 状态重启</span><br><span class="line">            # 委托 X 计算重启位置</span><br><span class="line">            dp[j][c] = dp[X][c] </span><br></pre></td></tr></table></figure>

<h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a><strong>四、代码实现</strong></h3><p>如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态 <code>X</code> 是如何得到的呢？下面先直接看完整代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KMP</span><span class="params">(String pat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pat = pat;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> pat.length();</span><br><span class="line">        <span class="comment">// dp[状态][字符] = 下个状态</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[M][<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 影子状态 X 初始为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">X</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前状态 j 从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">256</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pat.charAt(j) == c) </span><br><span class="line">                    dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[j][c] = dp[X][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新影子状态</span></span><br><span class="line">            X = dp[X][pat.charAt(j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String txt)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先解释一下这一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case</span></span><br><span class="line">dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这行代码是 base case，只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）。</p>
<p>影子状态 <code>X</code> 是先初始化为 0，然后随着 <code>j</code> 的前进而不断更新的。下面看看到底应该**如何更新影子状态 <code>X</code>**：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">X</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 更新影子状态</span></span><br><span class="line">    <span class="comment">// 当前是状态 X，遇到字符 pat[j]，</span></span><br><span class="line">    <span class="comment">// pat 应该转移到哪个状态？</span></span><br><span class="line">    X = dp[X][pat.charAt(j)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新 <code>X</code> 其实和 <code>search</code> 函数中更新状态 <code>j</code> 的过程是非常相似的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="comment">// 当前是状态 j，遇到字符 txt[i]，</span></span><br><span class="line">    <span class="comment">// pat 应该转移到哪个状态？</span></span><br><span class="line">    j = dp[j][txt.charAt(i)];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中的原理非常微妙</strong>，注意代码中 for 循环的变量初始值，可以这样理解：后者是在 <code>txt</code> 中匹配 <code>pat</code>，前者是在 <code>pat</code> 中匹配 <code>pat[1..end]</code>，状态 <code>X</code> 总是落后状态 <code>j</code> 一个状态，与 <code>j</code> 具有最长的相同前缀。所以我把 <code>X</code> 比喻为影子状态，似乎也有一点贴切。</p>
<p>另外，构建 dp 数组是根据 base case <code>dp[0][..]</code> 向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。</p>
<p>下面来看一下状态转移图的完整构造过程，你就能理解状态 <code>X</code> 作用之精妙了：</p>
<p><img src="/kmp25.gif" alt="kmp25"></p>
<p>至此，KMP 算法的核心终于写完啦啦啦啦！看下 KMP 算法的完整代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KMP</span><span class="params">(String pat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pat = pat;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> pat.length();</span><br><span class="line">        <span class="comment">// dp[状态][字符] = 下个状态</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[M][<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 影子状态 X 初始为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">X</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 构建状态转移图（稍改的更紧凑了）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">256</span>; c++)</span><br><span class="line">                dp[j][c] = dp[X][c];</span><br><span class="line">            dp[j][pat.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新影子状态</span></span><br><span class="line">            X = dp[X][pat.charAt(j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String txt)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> pat.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> txt.length();</span><br><span class="line">        <span class="comment">// pat 的初始态为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算 pat 的下一个状态</span></span><br><span class="line">            j = dp[j][txt.charAt(i)];</span><br><span class="line">            <span class="comment">// 到达终止态，返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没到达终止态，匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 KMP 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？</p>
<h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a><strong>五、最后总结</strong></h3><p>传统的 KMP 算法是使用一个一维数组 <code>next</code> 记录前缀信息，而本文是使用一个二维数组 <code>dp</code> 以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) &#x3D; O(M)。</p>
<p>在 <code>pat</code> 匹配 <code>txt</code> 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。</p>
<p>对于一个模式串 <code>pat</code>，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组 <code>dp[M][256]</code> 来包含所有情况，并且明确 <code>dp</code> 数组的含义：</p>
<p><code>dp[j][c] = next</code> 表示，当前是状态 <code>j</code>，遇到了字符 <code>c</code>，应该转移到状态 <code>next</code>。</p>
<p>明确了其含义，就可以很容易写出 search 函数的代码。</p>
<p>对于如何构建这个 <code>dp</code> 数组，需要一个辅助状态 <code>X</code>，它永远比当前状态 <code>j</code> 落后一个状态，拥有和 <code>j</code> 最长的相同前缀，我们给它起了个名字叫「影子状态」。</p>
<p>在构建当前状态 <code>j</code> 的转移方向时，只有字符 <code>pat[j]</code> 才能使状态推进（<code>dp[j][pat[j]] = j+1</code>）；而对于其他字符只能进行状态回退，应该去请教影子状态 <code>X</code> 应该回退到哪里（<code>dp[j][other] = dp[X][other]</code>，其中 <code>other</code> 是除了 <code>pat[j]</code> 之外所有字符）。</p>
<p>对于影子状态 <code>X</code>，我们把它初始化为 0，并且随着 <code>j</code> 的前进进行更新，更新的方式和 search 过程更新 <code>j</code> 的过程非常相似（<code>X = dp[X][pat[j]]</code>）。</p>
<p>KMP 算法也就是动态规划那点事，我们的公众号文章目录有一系列专门讲动态规划的，而且都是按照一套框架来的，无非就是描述问题逻辑，明确 <code>dp</code> 数组含义，定义 base case 这点破事。希望这篇文章能让大家对动态规划有更深的理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/KMP%E7%AE%97%E6%B3%95/" data-id="cl0j84jyj00dy04vh21n18cri" data-title="KMP算法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-KMP算法2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/KMP%E7%AE%97%E6%B3%952/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.471Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/KMP%E7%AE%97%E6%B3%952/">KMP算法2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="KMP算法2（常用讲解方式）"><a href="#KMP算法2（常用讲解方式）" class="headerlink" title="KMP算法2（常用讲解方式）"></a>KMP算法2（常用讲解方式）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Java实现KMP算法</span></span><br><span class="line"><span class="comment">	思想：</span></span><br><span class="line"><span class="comment">	每当一趟匹配的过程中出现字符比较不相等，不需要回溯指针</span></span><br><span class="line"><span class="comment">	二是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较</span></span><br><span class="line"><span class="comment">	时间复杂度O(n+m)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String s= <span class="string">&quot;&quot;</span>;</span><br><span class="line">		String t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">		<span class="type">char</span>[] tt = t.toCharArray();</span><br><span class="line">		System.out.println(KMP_Index(ss,tt));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 获得字符串的next函数值</span></span><br><span class="line"><span class="comment">	 t 字符串</span></span><br><span class="line"><span class="comment">	 return next函数值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next(<span class="type">char</span>[] t)&#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[t.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; t.length - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == -<span class="number">1</span> || t[i] == t[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">				<span class="keyword">if</span> (t[i] != t[j]) &#123;</span><br><span class="line">					next[i] = j;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					next[i] = next[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	KMP匹配字符串</span></span><br><span class="line"><span class="comment">		s 主串</span></span><br><span class="line"><span class="comment">		t 模式串</span></span><br><span class="line"><span class="comment">		匹配成功返回下标，否者返回-1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">KMP_Index</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] t)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] next = next(t);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= s.length - <span class="number">1</span> &amp;&amp; j &lt;= t.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == t[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; t.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> i - t.length; <span class="comment">// 返回模式串在主串中的头下标</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/KMP%E7%AE%97%E6%B3%952/" data-id="cl0j84jvt004d04vh1rrdhupd" data-title="KMP算法2" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JVM沙箱安全机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/JVM%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.445Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/JVM%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/">Java沙箱安全机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java安全模型的核心就是Java沙箱。沙箱机制就是讲Java代码限定在虚拟机JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</p>
<p>沙箱主要限制系统资源访问，例如：CPU、内存、文件系统、网络。不同级别的啥想对这些资源访问的限制也可以不一样</p>
<p>当前最新的安全机制实现，引入了域（Domain）的概念。虚拟机吧所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互。而各个域应用部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，</p>
<p>通俗来说就是虚拟机把代码加载到拥有不同权限的域里，然后代码就拥有了该域的所有权限。这样就能控制不同代码拥有不同调用操作系统和本地资源的权限</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/JVM%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" data-id="cl0j84jvd002r04vh7wb9ewzx" data-title="Java沙箱安全机制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux指令入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/Linux%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.371Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/Linux%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8/">Linux指令入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p>命令描述：tree命令用于以树状图列出目录的内容。</p>
<p>tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br></pre></td></tr></table></figure>

<p>命令使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree /usr/share/wallpapers/</span><br></pre></td></tr></table></figure>

<p>命令输出结果：</p>
<p><img src="https://img.alicdn.com/tfs/TB1FuM_Hvb2gK0jSZK9XXaEgFXa-533-237.png" alt="img"></p>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>命令描述： ls命令用于显示指定工作目录下的内容。</p>
<p>命令格式：<code>ls [参数] [目录名]</code>。</p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-a</td>
<td align="left">显示所有文件及目录（包括隐藏文件）</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">将文件的权限、拥有者、文件大小等详细信息列出（<code>ll</code>等同于<code>ls -l</code>）</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">将文件反序列出（默认按英文字母正序）</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">将文件按创建时间正序列出</td>
</tr>
<tr>
<td align="left">-R</td>
<td align="left">递归遍历目录下文件</td>
</tr>
</tbody></table>
<p>命令使用示例：</p>
<p>查看当前目录下的所有文件（包括隐藏文件）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll -a</span><br></pre></td></tr></table></figure>

<p>命令输出结果：</p>
<p><img src="https://img.alicdn.com/tfs/TB10gRXHQP2gK0jSZPxXXacQpXa-546-381.png" alt="img"></p>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>命令描述：获取当前工作目录的绝对路径。</p>
<p>命令使用示例：</p>
<p><img src="https://img.alicdn.com/tfs/TB1UJhXHHr1gK0jSZR0XXbP8XXa-452-68.png" alt="img"> </p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>命令描述：cd命令用于切换工作目录。</p>
<p>命令使用示例：</p>
<p><img src="https://img.alicdn.com/tfs/TB16qddHHH1gK0jSZFwXXc7aXXa-412-217.png" alt="img"></p>
<p>在路径表示中：</p>
<ul>
<li>一个半角句号（<code>.</code>）表示当前目录，例如路径.&#x2F;app&#x2F;log等同于app&#x2F;log。</li>
<li>两个半角句号（<code>..</code>）表示上级目录，例如路径&#x2F;usr&#x2F;local&#x2F;..&#x2F;src等同于&#x2F;usr&#x2F;src，其中local和src目录同级。</li>
</ul>
<p><code>cd</code>命令的默认参数为<code>~</code>，符号<code>~</code>表示当前用户的家目录，即在root用户登录时，命令<code>cd</code>、<code>cd ~</code>和<code>cd /root</code>执行效果相同。</p>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>命令格式：<code>touch [参数] [文件]</code>。</p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-c</td>
<td align="left">如果指定文件不存在，不会建立新文件</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">使用参考文件的时间记录</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">设置文件的时间记录</td>
</tr>
</tbody></table>
<p>命令使用示例：</p>
<ul>
<li>创建两个空文件。</li>
</ul>
<p><img src="https://img.alicdn.com/tfs/TB1X_Z.HuT2gK0jSZFvXXXnFXXa-466-133.png" alt="img"></p>
<ul>
<li>修改demo1.txt的时间记录为当前系统时间。</li>
</ul>
<p><img src="https://img.alicdn.com/tfs/TB1kdaraaNj0u4jSZFyXXXgMVXa-478-128.png" alt="img"></p>
<ul>
<li>更新demo2.txt的时间记录，使其和demo1.txt的时间记录相同。</li>
</ul>
<p><img src="https://img.alicdn.com/tfs/TB1iMpXHUT1gK0jSZFrXXcNCXXa-499-132.png" alt="img"></p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>命令描述：mkdir命令用于新建子目录。<code>-p</code>参数确保目录名称存在，不存在的就新建一个。</p>
<p>命令使用示例：</p>
<p>新建目录a&#x2F;b&#x2F;c&#x2F;d，并使用tree命令查看创建后的目录结构。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://img.alicdn.com/tfs/TB1s2vcjcKfxu4jSZPfXXb3dXXa-510-254.png" alt="img"></h2><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>命令描述：rm命令用于删除一个文件或者目录。</p>
<p>命令格式：<code>rm [参数] [文件]</code>。</p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i</td>
<td align="left">删除前逐一询问确认</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">无需确认，直接删除</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">删除目录下所有文件</td>
</tr>
</tbody></table>
<p>命令使用示例：</p>
<p>无需确认直接删除文件。</p>
<p><img src="https://img.alicdn.com/tfs/TB1vLo8HqL7gK0jSZFBXXXZZpXa-522-213.png" alt="img"></p>
<p>无需确认直接删除目录a及其目录下所有子目录和文件。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://img.alicdn.com/tfs/TB1asFeHQT2gK0jSZFkXXcIQFXa-415-85.png" alt="img"></h2><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>命令描述： cp命令主要用于复制文件或目录。</p>
<p>命令格式：<code>cp [参数] [源文件] [目标文件]</code>。</p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-d</td>
<td align="left">复制时保留链接</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">覆盖已经存在的目标文件而不给出提示</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">覆盖前询问</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">复制目录及目录内的所有项目</td>
</tr>
</tbody></table>
<p>命令使用示例：</p>
<p>将目录c&#x2F;d中的所有内容复制到目录a&#x2F;b下。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://img.alicdn.com/tfs/TB10Ck3HuL2gK0jSZPhXXahvXXa-673-465.png" alt="img"></h2><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<p>命令格式：<code>mv [参数] [源文件] [目标文件]</code></p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i</td>
<td align="left">若指定目录已有同名文件，则先询问是否覆盖旧文件</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">如果目标文件已经存在，不会询问而直接覆盖</td>
</tr>
</tbody></table>
<p>命令使用示例：</p>
<ul>
<li><p>将文件名a.txt改为b.txt。<br><img src="https://img.alicdn.com/tfs/TB1z1M_Hvb2gK0jSZK9XXaEgFXa-348-151.png" alt="img"></p>
</li>
<li><p>将c目录移动到a&#x2F;b&#x2F;c&#x2F;d&#x2F;下。<br><img src="https://img.alicdn.com/tfs/TB1M9BiHRr0gK0jSZFnXXbRRXXa-387-276.png" alt="img"></p>
</li>
<li><p>将当前目录内容全部移动到&#x2F;tmp目录中。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv ./* /tmp</span><br></pre></td></tr></table></figure>

<h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><p>命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。</p>
<p>命令使用示例：</p>
<ul>
<li><p>将当前目录下所有文件名中的字符串demo改为大写的字符串DEMO。<br><img src="https://img.alicdn.com/tfs/TB164qEaepyVu4jSZFhXXbBpVXa-410-150.png" alt="img"></p>
</li>
<li><p>将当前目录下所有<code>.txt</code>文件后缀都改为<code>text</code>。<br><img src="https://img.alicdn.com/tfs/TB1l3pXHUT1gK0jSZFrXXcNCXXa-386-84.png" alt="img"></p>
</li>
</ul>
<h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>ls命令可以查看Linux系统上的文件、目录和设备的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /boot/</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB12gXcHND1gK0jSZFKXXcJrVXa-869-420.png" alt="img"></p>
<p>上述<code>ls -l</code>命令中显示的第一列就是文件权限信息，共11位字符，分5部分。</p>
<ul>
<li>第1位表示存档类型，<code>d</code>表示目录，<code>-</code>表示一般文件。</li>
<li>第2~4位表示当前用户的权限（属主权限）。</li>
<li>第5~7位表示同用户组的用户权限（属组权限）。</li>
<li>第8~10位表示不同用户组的用户权限（其他用户权限）。</li>
<li>第11位是一个半角句号<code>.</code>，表示SELinux安全标签。</li>
</ul>
<p>用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。</p>
<p>例如efi目录的root用户权限为<code>drwxr-xr-x.</code>。</p>
<ul>
<li>该目录对root用户具有读写和执行所有权限。</li>
<li>该目录对root组其他用户有读和执行权限。</li>
<li>该目录对其他用户有读和执行权限。</li>
</ul>
<p>所以该权限表示对应八进制权限表示为：</p>
<ul>
<li>属主权限：<code>4+2+1=7</code>。</li>
<li>属组权限：<code>4+1=5</code>。</li>
<li>其他用户权限：4+1&#x3D;5。</li>
</ul>
<p>即755。</p>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>chmod命令用于修改文件权限mode，<code>-R</code>参数以递归方式对子目录和文件进行修改。</p>
<p>命令使用示例：</p>
<p>\1. 新建名为hello.sh的Shell脚本，该脚本将会输出<code>Hello World</code>。用<code>ll</code>命令可以看到新建的脚本没有执行权限，其权限用八进制表示为644。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;echo &#x27;Hello World&#x27;&quot; &gt; hello.sh</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1XPRcHNv1gK0jSZFFXXb0sXXa-520-111.png" alt="img"></p>
<p>\2. 将hello.sh文件增加属主的执行权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x hello.sh</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1RX7nXSRLWu4jSZKPXXb6BpXa-469-110.png" alt="img"></p>
<p>\3. 将hello.sh文件撤销属主的执行权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u-x hello.sh</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1.q8XHFP7gK0jSZFjXXc5aXXa-458-108.png" alt="img"></p>
<p>\4. 将hello.sh文件权限修改为八进制表示的744权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 hello.sh</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1cq..HpT7gK0jSZFpXXaTkpXa-445-110.png" alt="img"></p>
<p>\5. 使用bash命令解释器执行hello.sh脚本文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash hello.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1mIFeHQT2gK0jSZFkXXcIQFXa-448-67.png" alt="img"></p>
<p>其中，<code>u+x</code>表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。</p>
<h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>chown命令修改文件的属主和属组；<code>-R</code>参数以递归方式对子目录和文件进行修改；<code>ls -l</code>命令显示的第三列和第四列就是文件的属主和属组信息。</p>
<p>命令使用示例：</p>
<p>\1. 新建一个文本文件test.txt，用<code>ll</code>命令可以看到该文件的属主和属组是root。<code>whoami</code>命令可以查看当前Shell环境登录的用户名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">touch test.txt</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1Xq..HpT7gK0jSZFpXXaTkpXa-457-153.png" alt="img"></p>
<p>\2. 创建两个用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd test</span><br><span class="line">useradd admin</span><br></pre></td></tr></table></figure>

<p>\3. 修改test.txt文件的属主用户为test。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown test test.txt</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<h3 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://img.alicdn.com/tfs/TB1IHVfHHj1gK0jSZFuXXcrHpXa-477-106.png" alt="img"></h3><p>\4. 修改test.txt文件的属主和属组为admin。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown admin:admin test.txt</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1KbVfHHj1gK0jSZFuXXcrHpXa-471-108.png" alt="img"></p>
<h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><p>chgrp命令用于修改文件的属组。</p>
<p>命令使用示例：</p>
<p>将test.txt文件的属组改为root。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp root test.txt</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://img.alicdn.com/tfs/TB1uLg.HxD1gK0jSZFsXXbldVXa-522-108.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/Linux%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8/" data-id="cl0j84jvt004f04vhfihr7hyf" data-title="Linux指令入门" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JAVA必背面试题和项目面试通关要点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/JAVA%E5%BF%85%E8%83%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E9%80%9A%E5%85%B3%E8%A6%81%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.351Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/JAVA%E5%BF%85%E8%83%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E9%80%9A%E5%85%B3%E8%A6%81%E7%82%B9/">JAVA必背面试题和项目面试通关要点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一-数据库"><a href="#一-数据库" class="headerlink" title="一 数据库"></a>一 数据库</h2><h3 id="1．常问数据库查询、修改（SQL查询包含筛选查询、聚合查询和链接查询和优化问题，手写SQL语句，例如四个球队比赛，用SQL显示所有比赛组合；举例2：选择重复项，然后去掉重复项；）-数据库里的密码如何加密（md5）；"><a href="#1．常问数据库查询、修改（SQL查询包含筛选查询、聚合查询和链接查询和优化问题，手写SQL语句，例如四个球队比赛，用SQL显示所有比赛组合；举例2：选择重复项，然后去掉重复项；）-数据库里的密码如何加密（md5）；" class="headerlink" title="1．常问数据库查询、修改（SQL查询包含筛选查询、聚合查询和链接查询和优化问题，手写SQL语句，例如四个球队比赛，用SQL显示所有比赛组合；举例2：选择重复项，然后去掉重复项；） 数据库里的密码如何加密（md5）；"></a>1．常问数据库查询、修改（SQL查询包含筛选查询、聚合查询和链接查询和优化问题，手写SQL语句，例如四个球队比赛，用SQL显示所有比赛组合；举例2：选择重复项，然后去掉重复项；） 数据库里的密码如何加密（md5）；</h3><p>​    (1)数据库的密码加密:单向加密,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into users (username,password) values (‘mike’,MD5(‘guessme’));</span><br></pre></td></tr></table></figure>

<p>​    (2)双向加密:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into users (username ,password) values (‘mike’,ENCODE(‘guessme’,’abanaafn’));</span><br></pre></td></tr></table></figure>

<p>​    (3)SQL筛选查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where user_id in (select user_id from user group by user_id having count(user_id)&gt;1) order by user_id desc;</span><br></pre></td></tr></table></figure>

<p>​    (4)SQL聚合查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id from user group by user_id;</span><br></pre></td></tr></table></figure>

<p>​    (5)SQL衔接查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内连接:  select s.name,m.mess from student s inner join mark m on s.id=m.studentid;</span><br><span class="line">左外连接:select s.name, m.mess from student s left join mark m on s.id=m.studentid;</span><br><span class="line">右外连接:select s.name, m.mess from student s right join mark m on s.id=m.studentid;</span><br><span class="line">全外连接:select s.name ,m.mess from student s full join mark m on s.id=m.studentid;</span><br></pre></td></tr></table></figure>

<p>(6)球队比赛组合:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from department as a ,department as b a.name&lt;&gt;b.name;</span><br></pre></td></tr></table></figure>

<p>(7)SQL选择重复语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id ,name from user where id in (select id from user group by id having count(1)&gt;2);</span><br></pre></td></tr></table></figure>

<p>去除重复语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from user group by id having count(*)&gt;1;</span><br></pre></td></tr></table></figure>

<p>(8)数据库优化:prepareStatement比Statement性能高,一个sql发给服务器去执行.涉及步骤:语法检查,语义定义,编译和缓存.有外检约束会影响插入和删除功能,如果程序能保证数据的完整性,那么设计数据库的时候就去掉外键.sql语句全部大写,特别是列名和表名.</p>
<h3 id="2-如何实现数据库分页功能？-SQL语句复杂的关联表查询，累计求和。"><a href="#2-如何实现数据库分页功能？-SQL语句复杂的关联表查询，累计求和。" class="headerlink" title="2.如何实现数据库分页功能？ SQL语句复杂的关联表查询，累计求和。"></a>2.如何实现数据库分页功能？ SQL语句复杂的关联表查询，累计求和。</h3><p>在不使用框架情况下，如何连接数据库？</p>
<p>数据库连接完之后，需要关闭的两个接口是什么？</p>
<p>关闭数据库过程中最容易抛出的异常是什么？</p>
<p>(1)分页:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">”select * from user limit “+(pageNo-1)*pageSize+”,”+pageSize;</span><br></pre></td></tr></table></figure>

<p>(2)求和:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user1 union select * from user2;</span><br></pre></td></tr></table></figure>

<p>(3)手动连接数据库:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Connection cn=<span class="literal">null</span>;</span><br><span class="line">PreparedStatement pst=<span class="literal">null</span>;</span><br><span class="line">Result rs=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	Class.forname(driverClassName);</span><br><span class="line">	cn=DriverManager.getConnection(url,username,password);</span><br><span class="line">	pst=cn.prepareStatement(“sql”);</span><br><span class="line">    pst.setString(<span class="number">1</span>,studentName);</span><br><span class="line">	Result rs=pst.executeQuery();</span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        system.out.println()</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rs!=<span class="literal">null</span>)&#123;</span><br><span class="line">		rs.close();</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(pst!=<span class="literal">null</span>)&#123;</span><br><span class="line">			pst.close()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cn!=<span class="literal">null</span>)&#123;</span><br><span class="line">			cn.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)Result prepareStatement 结果集和sql传输</p>
<p>(5)Exception</p>
<h3 id="3-Oracle索引的优缺点、视图和存储过程、连接符是什么？默认端口是什么？MySQL什么是左链接、右链接和内链接？数据库中查询左链接、右链接和内链接结果是什么？数据库的存储原理，讲一讲"><a href="#3-Oracle索引的优缺点、视图和存储过程、连接符是什么？默认端口是什么？MySQL什么是左链接、右链接和内链接？数据库中查询左链接、右链接和内链接结果是什么？数据库的存储原理，讲一讲" class="headerlink" title="3. Oracle索引的优缺点、视图和存储过程、连接符是什么？默认端口是什么？MySQL什么是左链接、右链接和内链接？数据库中查询左链接、右链接和内链接结果是什么？数据库的存储原理，讲一讲?"></a>3. Oracle索引的优缺点、视图和存储过程、连接符是什么？默认端口是什么？<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/14">MySQL</a>什么是左链接、右链接和内链接？数据库中查询左链接、右链接和内链接结果是什么？数据库的存储原理，讲一讲?</h3><p>(1)端口:1521;</p>
<p>(2)内连接就是左表和右表相同的数据.</p>
<p>外连接分为：左外连接、右外连接、全外连接</p>
<p>左外连接就是以左表为准，去匹配右表，左表有多少条数据，结果就是多少条数据</p>
<p>右外连接就是与左外连接反之，以右表为准，去匹配左表，右表有多少条数据，结果就是多少条数据。</p>
<p>全外连接数据条数不一定，相当与是左外连接 和右外连接 的综合。</p>
<p>(3)oracle索引分为:聚集索引,非聚集索引,唯一索引;优点:方便查询,在数据量大时排序更宜查询;缺点:查询时需要进行重新排序，减少了效率。物理索引缺点 建立索引效率低，只能建一个更有说服力的;</p>
<p>(4)连接符为”||”或CONCAT();</p>
<p>(5)视图:其实就是一条查询sql语句，用于显示一个或多个表或其他视图中的相关数据。视图将一个查询的结果作为一个表来使用，因此视图可以被看作是存储的查询 或一个虚拟表。视图来源于表，所有对视图数据的修改最终都会被反映到视图的基表中，这些修改必须服从基表的完整性约束，并同样会触发定义在基表上的触发器</p>
<p>(6)存储过程:oracle有系统存储过程和自定义存储过程，为了完成特定功能的sql语句集，经编译后存储在数据库中，用户通过特定的存储过程名来执行</p>
<p>(7)存储原理:当用户创建索引时,oracle会自动的在表空间里创建索引段来存储索引的数据;</p>
<h3 id="4-Char里面可以存放汉字吗？"><a href="#4-Char里面可以存放汉字吗？" class="headerlink" title="4. Char里面可以存放汉字吗？"></a>4. Char里面可以存放汉字吗？</h3><p>(1)char型变量就是用来存储Unicode编码字符的,Unicode编码字符集中包含了汉字,所以可以存储汉字,如果某个特殊的汉字没有包含在Unicode编码字符集中,那么char型变量就不能存储,Unicode占用两个字节,所以char型的变量也是占用两个字节.</p>
<h2 id="二-Java基础"><a href="#二-Java基础" class="headerlink" title="二 Java基础"></a>二 Java基础</h2><h3 id="1-说一下多态的表现形式？"><a href="#1-说一下多态的表现形式？" class="headerlink" title="1. 说一下多态的表现形式？"></a>1. 说一下多态的表现形式？</h3><p>(1)重载,重写,重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同</p>
<p>(2)重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现,只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常,子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法</p>
<h3 id="2-数据的加密模式？加密模式的顺序？"><a href="#2-数据的加密模式？加密模式的顺序？" class="headerlink" title="2. 数据的加密模式？加密模式的顺序？"></a>2. 数据的加密模式？加密模式的顺序？</h3><p>对称式和非对称式,顺序:传输加密,数据存储加密,数据完整型的鉴别,密钥管理;</p>
<h3 id="3-问到hasshmap底层数据结构，arraylist-linklist区别和为什么有这样的区别；数组的比较方法；基本类型和引用数据类型的区别；问接口和抽象类的区别；"><a href="#3-问到hasshmap底层数据结构，arraylist-linklist区别和为什么有这样的区别；数组的比较方法；基本类型和引用数据类型的区别；问接口和抽象类的区别；" class="headerlink" title="3. 问到hasshmap底层数据结构，arraylist-linklist区别和为什么有这样的区别；数组的比较方法；基本类型和引用数据类型的区别；问接口和抽象类的区别；"></a>3. 问到hasshmap底层数据结构，arraylist-linklist区别和为什么有这样的区别；数组的比较方法；基本类型和引用数据类型的区别；问接口和抽象类的区别；</h3><p>(1)HashMap是线程序不安全的，不是同步的</p>
<p>HashMap可以让你将空值作为一个表的条目的key或value</p>
<p>Hashmap实际上是一个数组和链表的结合体,在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体.</p>
<p>(2)区别:ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构,对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针,.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据,若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批 量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 这一点我做了实验。在分别有200000条“记录”的ArrayList和LinkedList的首位插入20000条数据，LinkedList耗时约 是ArrayList的20分之1。</p>
<h3 id="4-如何配置安装jdk？如何判断其配置成功？"><a href="#4-如何配置安装jdk？如何判断其配置成功？" class="headerlink" title="4. 如何配置安装jdk？如何判断其配置成功？"></a>4. 如何配置安装jdk？如何判断其配置成功？</h3><p>(1)首先安装<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=JDK&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dWmH9hPW0srADLrywBnyfL0AP8IA3qPjfsn1bkrjKxmLKz0ZNzUjdCIZwsrBtEXh9GuA7EQhF9pywdQhPEUiqkIyN1IA-EUBtkPHfknjDYP1Rzrj03P1m3njmL">JDK</a>要看你电脑的位数，选择32位或64位的<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=jdk&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dWmH9hPW0srADLrywBnyfL0AP8IA3qPjfsn1bkrjKxmLKz0ZNzUjdCIZwsrBtEXh9GuA7EQhF9pywdQhPEUiqkIyN1IA-EUBtkPHfknjDYP1Rzrj03P1m3njmL">jdk</a>版本，建议使用1.6版本以上，1.7版本一下;</p>
<p>(2)从Oracle官网下载JDK安装包。</p>
<p>(3)安装包下载完成后，双击安装包进行安装，安装路径可以使用默认路径。</p>
<p>(4)安装完成后，还需要进行环境变量的配置，在系统环境变量的用户变量里面添加一个变量名为 JAVA_HOME环境变量，然后在变量值处填写上JDK安装目录的bin文件夹的路径，如：C:\ProgramFiles\Java \jdk1.7.0_79，然后再添加一个变量名为Path的变量，变量值填写为%JAVA_HOME%\bin;即可。</p>
<p>(5)可以写一个简单的java程序来测试JDK是否已安装成功：public class Test{public static void main(String args[]){System.out.println(“This is a test program.”);}}将上面的这段程序保存为文件名为Test.java的文件。(注意Test是程序的公共类，必须和文件名一致，包括大小写)然后打开命令提示符窗口，cd到你的Test.java所在目录，然后键入下面的命令 ：javac Test.java （回车）java Test 此时如果看到打印出来This is a test program.的话说明安装成功了，如果没有打印出这句话，你需要仔细检查一下你的配置情况。</p>
<h3 id="5-手写单例模式（饿汉和饱汉模式）和工厂模式？"><a href="#5-手写单例模式（饿汉和饱汉模式）和工厂模式？" class="headerlink" title="5. 手写单例模式（饿汉和饱汉模式）和工厂模式？"></a>5. 手写单例模式（饿汉和饱汉模式）和工厂模式？</h3><p>(1)单例饿汉模式:&#x2F;&#x2F;饿汉式单例类.在类初始化时，已经自行实例化 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">   <span class="comment">//私有的默认构造子</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">   <span class="comment">//已经自行实例化 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">   <span class="comment">//静态工厂方法 </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> single;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>(2)懒汉模式:&#x2F;&#x2F;懒汉式单例类.在第一次调用的时候实例化 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">  <span class="comment">//私有的默认构造子</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="comment">//注意，这里没有final  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 single=<span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//静态工厂方法 </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (single == <span class="literal">null</span>) &#123; </span><br><span class="line">      single = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)工厂模式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> IProduct <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">Class Factory <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> IProduct <span class="title function_">createProduct</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Public <span class="keyword">class</span> <span class="title class_">client</span>&#123;</span><br><span class="line">	Public Static <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">		IFactory factory=<span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">		IProduct product=factory.createProduct();</span><br><span class="line">		product.ProductMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-手写创建list，定义list，泛型？"><a href="#6-手写创建list，定义list，泛型？" class="headerlink" title="6. 手写创建list，定义list，泛型？"></a>6. 手写创建list，定义list，泛型？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)List list=new ArrayList();</span><br><span class="line">(2)List&lt;Student&gt; list=new ArrayList&lt;Student&gt;();</span><br><span class="line">(3)Student s=new Student();</span><br><span class="line">(4)List.add(s);</span><br></pre></td></tr></table></figure>

<h3 id="7-安全：hassmap和hasstable的区别？那个不安全？为什么？怎么遍历hashmap？线程方面：线程有几种状态？谈谈多线程的安全问题；问到线程和同步？写一个生产者和消费者模式-考虑高并发的问题。"><a href="#7-安全：hassmap和hasstable的区别？那个不安全？为什么？怎么遍历hashmap？线程方面：线程有几种状态？谈谈多线程的安全问题；问到线程和同步？写一个生产者和消费者模式-考虑高并发的问题。" class="headerlink" title="7. 安全：hassmap和hasstable的区别？那个不安全？为什么？怎么遍历hashmap？线程方面：线程有几种状态？谈谈多线程的安全问题；问到线程和同步？写一个生产者和消费者模式; 考虑高并发的问题。"></a>7. 安全：hassmap和hasstable的区别？那个不安全？为什么？怎么遍历hashmap？线程方面：线程有几种状态？谈谈多线程的安全问题；问到线程和同步？写一个生产者和消费者模式; 考虑高并发的问题。</h3><p>(1)区别:</p>
<p>一。历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现;</p>
<p>二。同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的</p>
<p>三。值：只有HashMap可以让你将空值作为一个表的条目的key或value</p>
<p>四。为什么?最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash&#x2F;rehash算法都大概一样，所以性能不会有很大的差异</p>
<p>(2)遍历hashmap:两种方式,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Iterator iter=map.entrySet().iterator();</span><br><span class="line">Iterator iter=map.keySet().iterator();</span><br></pre></td></tr></table></figure>

<p>(3)线程通常有五种状态,创建,就绪,运行,阻塞,和死亡;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一是创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态手写字符串反转和冒泡排序；</span><br><span class="line"></span><br><span class="line">第二是就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</span><br><span class="line"></span><br><span class="line">第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</span><br><span class="line"></span><br><span class="line">第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</span><br><span class="line"></span><br><span class="line">第五是死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</span><br></pre></td></tr></table></figure>

<p>(4)多线程的安全问题:</p>
<p>总结来说，多个线程在执行同一段代码的时候，每次的执行结果和单线程执行的结果都是一样的，不存在执行结果的二义性，就可以称作是线程安全的。线程安全问 题多是由全局变量和静态变量引起的，当多个线程对共享数据只执行读操作，不执行写操作时，一般是线程安全的；当多个线程都执行写操作时，需要考虑线程同步 来解决线程安全问题。</p>
<p>(5)线程和同步:</p>
<p>说明Java线程的两个特性，可见性和有序性。多个线程之间是不能直接传递数据交互的，它们之间的交互只能通过共享变量来实现.</p>
<p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， </p>
<p>将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用， </p>
<p>从而保证了该变量的唯一性和准确性</p>
<p>(6)生产者和消费者模式:</p>
<p>存储空间已满，而生产者占用着它，消费者等着生产者让出空间从而去除产品，生产者等着消费者消费产品，从而向空间中添加产品。互相等待，从而发生死锁。</p>
<p>(7)模式:</p>
<p>​    1.wait()和notify();</p>
<p>​    2.await()和signal()，即线程锁的方式;</p>
<p>​    3.阻塞队列的方式;</p>
<p>(8)高并发:</p>
<p>手段无非是切割（纵向，横向）和负载均衡。纵向分隔主要是按业务（功能）来分，也就是所谓面向服务架构，横向分隔方式比较多，主要依赖于所处理的对象属性负载均衡则可以是镜像（部署）分布（同样的功能部署几份）和计算分布（一个问题分几个子问题在不同的机器上运行，然后合并结果）。当然，这些手段是可以综合利用的，最终可以做成多流水线分布式计算模式;</p>
<h3 id="8-list、map和set什时候用？彼此间的区别和联系？"><a href="#8-list、map和set什时候用？彼此间的区别和联系？" class="headerlink" title="8. list、map和set什时候用？彼此间的区别和联系？"></a>8. list、map和set什时候用？彼此间的区别和联系？</h3><p>(1)list列表是顺序存放对象的，可以有相同的对象，通过索引存取；一般在能直接使用数组的时候，就有使用列表</p>
<p>(2)set集合:集合是无序存放对象的，其中不能有重复的对象（唯一的，回忆高中时候数学中学习的集合特性），集合没有索引，只能遍历次存取；一般用于存放无序的（指顺序不重要）不能重复的对象</p>
<p>(3)Map映射:映射，存放的是键与值的映射，其中键是唯一的（不能有重复对象），而值可以有重复的对象，存的时候，需要指定键和对应的值，取的时候可以根据键名取到值，也可以遍历;一般在用于存放具有对应关系的键值对的时候用;</p>
<p>(4)三者的区别和联系:三者都是接口,List与Set具有相似性，它们都是单列元素的集合,list,set是继承自collection,而map不是,list里可以有重复元素,有先后顺手,Set里面不允许有重复的元素,而且无序,Map 保存key-value值，value可多值。</p>
<h3 id="9-java常见的数据类型是什么和对应的包装类是什么？java的隐式类型？assert什么时候使用？"><a href="#9-java常见的数据类型是什么和对应的包装类是什么？java的隐式类型？assert什么时候使用？" class="headerlink" title="9. java常见的数据类型是什么和对应的包装类是什么？java的隐式类型？assert什么时候使用？"></a>9. java常见的数据类型是什么和对应的包装类是什么？java的隐式类型？assert什么时候使用？</h3><p>(1)int, double, float, long, short, boolean, byte, char</p>
<p>(2)Integer.Double,Float,Long,Short,Boolean,Byte,Characher.</p>
<p>(3)java的隐式类型是int,byte,short,char都可以隐含转换为int ,</p>
<p>(4)一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的;</p>
<h3 id="10-object类型中有哪些方法？"><a href="#10-object类型中有哪些方法？" class="headerlink" title="10. object类型中有哪些方法？"></a>10. object类型中有哪些方法？</h3><p>equals()、hashCode()、wait()、toString()、finalize()、notify()、notifyAll()</p>
<h3 id="11-final、finally和finalize的区别？"><a href="#11-final、finally和finalize的区别？" class="headerlink" title="11. final、finally和finalize的区别？"></a>11. final、finally和finalize的区别？</h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 </p>
<p>内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……</p>
<p>finally是异常处理语句结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法</p>
<h3 id="12-LinkedList和ArrayList的区别？继承的接口？"><a href="#12-LinkedList和ArrayList的区别？继承的接口？" class="headerlink" title="12. LinkedList和ArrayList的区别？继承的接口？"></a>12. LinkedList和ArrayList的区别？继承的接口？</h3><p>(1)ArrayList是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢</p>
<p>LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用</p>
<p>(2)list接口：</p>
<p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问;</p>
<p> Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p>
<p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，接口中没有定义的方法 get，remove，insertList，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。LinkedList没有同步方法。如果 多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建 List时构造一个同步的List：</p>
<h3 id="13-int和string是如何转化的？"><a href="#13-int和string是如何转化的？" class="headerlink" title="13. int和string是如何转化的？"></a>13. int和string是如何转化的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String转int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt([String]);</span><br><span class="line">i = Integer.parseInt([String],[<span class="type">int</span> radix]);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(my_str).intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int转String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + i;</span><br></pre></td></tr></table></figure>

<h3 id="15-谈谈你对面向对象编程的理解？"><a href="#15-谈谈你对面向对象编程的理解？" class="headerlink" title="15. 谈谈你对面向对象编程的理解？"></a>15. 谈谈你对面向对象编程的理解？</h3><p>(1)Java语言是纯粹的面向对象的程序设计语言，这主要表现为Java完全支持面向对象的三种基本特征：继承、封装和多态。Java语言完全以对象为中心，Java程序的最小程序单位是类，整个Java程序由一个一个的类组成;Java完全支持使用对象、类、继承、封装、消息等基本概念来进行程序设计，允许从现实世界中客观存在的事物（即对象）出发来构造软件系统，在系统构造中 尽可能运用人类的自然思维方式。实际上，这些优势是所有面向对象编程语言的共同特征。而面向对象的方式实际上由OOA（面向对象分析）、OOD（面向对象 设计）和OOP（面向对象编程）三个部分有机组成，其中，OOA和OOD的结构需要使用一种方式来描述并记录，目前业界统一采用UML（统一建模语言）来 描述并记录OOA和OOD的结果。目前UML的最新版是2.0它一共包括13种类型的图形，使用这13种图形中的某些就可以很好地描述并记录软件分析、设 计的结果</p>
<h3 id="16-重写和重载的区别？"><a href="#16-重写和重载的区别？" class="headerlink" title="16. 重写和重载的区别？"></a>16. 重写和重载的区别？</h3><p>(1)重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）;</p>
<p>(2)重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现;只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常;子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法;</p>
<h3 id="17-sleep-amp-wait区别和联系？"><a href="#17-sleep-amp-wait区别和联系？" class="headerlink" title="17. sleep&amp;wait区别和联系？"></a>17. sleep&amp;wait区别和联系？</h3><p>(1)这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类;sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</p>
<p>(2)最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的 运行资源不够，再出来也没用，要等待其他线程调用notify&#x2F;notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。 sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断;</p>
<h3 id="18-string、stringbuffer和stringbuilder的区别？哪个更安全？为什么？hashmap为什么查询的比较快？"><a href="#18-string、stringbuffer和stringbuilder的区别？哪个更安全？为什么？hashmap为什么查询的比较快？" class="headerlink" title="18. string、stringbuffer和stringbuilder的区别？哪个更安全？为什么？hashmap为什么查询的比较快？"></a>18. string、stringbuffer和stringbuilder的区别？哪个更安全？为什么？hashmap为什么查询的比较快？</h3><p>(1)JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法;而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</p>
<p>(2)StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改;通过某些方法调用可以改变该序列的长度和内容，可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致;</p>
<p>(3)StringBuilder一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。（如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。但将 StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用 StringBuffer。）;</p>
<p>(4)HashMap是Hashtable的轻量级实现（非同步非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。</p>
<h3 id="19-hashmap的数组是hashcode定位的，有很多key得到的hashcode是相同的，这时候如何定位？"><a href="#19-hashmap的数组是hashcode定位的，有很多key得到的hashcode是相同的，这时候如何定位？" class="headerlink" title="19. hashmap的数组是hashcode定位的，有很多key得到的hashcode是相同的，这时候如何定位？"></a>19. hashmap的数组是hashcode定位的，有很多key得到的hashcode是相同的，这时候如何定位？</h3><p>(1)Java采用了哈希表的原理。哈希算法也称为散列算法，就是集合首先会调用该对象的hashcode方法;是将数据依特定算法直接指定到一个地址上。关于哈希算法，这里就不详细介绍。可以这样简单理解，hashCode方法实际上返回的就是对象存储位置的映像;hashcode相同但是对象并不同,所有存储位置也不同;对于List集合、数组而言，他就是一个累赘，不重要；但是对于HashMap、HashSet、HashTable而言，它变得异常重要。</p>
<h3 id="20-string是否是基本数据类型？int和string是如何转化的？"><a href="#20-string是否是基本数据类型？int和string是如何转化的？" class="headerlink" title="20. string是否是基本数据类型？int和string是如何转化的？"></a>20. string是否是基本数据类型？int和string是如何转化的？</h3><p>(1)基本数据类型包括byte、int、char、long、float、double、boolean和short;java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类;</p>
<p>(2)int i &#x3D; Integer.parseInt([String]);i &#x3D; Integer.parseInt([String],[int radix]);或者int i &#x3D; Integer.valueOf(my_str).intValue();int转StringString s &#x3D; String.valueOf(i);String s &#x3D; Integer.toString(i);String s &#x3D; “” + i;</p>
<h2 id="三-Java-Web"><a href="#三-Java-Web" class="headerlink" title="三 Java Web"></a>三 Java Web</h2><h3 id="1-Jsp页面遍历集合？"><a href="#1-Jsp页面遍历集合？" class="headerlink" title="1. Jsp页面遍历集合？"></a>1. Jsp页面遍历集合？</h3><p>(1)List<String> names &#x3D; new LinkedList<String>();</p>
<p>(2)Set<String> set &#x3D; new TreeSet<String>();</p>
<p>(3)Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</p>
<h3 id="2-tomcat核心项目：tomacate出现乱码如何解决？如何增加tomcat和jdk的内存？jdk的版本？"><a href="#2-tomcat核心项目：tomacate出现乱码如何解决？如何增加tomcat和jdk的内存？jdk的版本？" class="headerlink" title="2. tomcat核心项目：tomacate出现乱码如何解决？如何增加tomcat和jdk的内存？jdk的版本？"></a>2. tomcat核心项目：tomacate出现乱码如何解决？如何增加tomcat和jdk的内存？jdk的版本？</h3><p>(1)Java的内核和class文件是基于unicode的，这使Java程序具有良好的跨平台性，但也带来了一些中文乱码问题的麻烦。原因主要有两方面，Java和JSP文件本身编译时产生的乱码问题和Java程序于其他媒介交互产生的乱码问题。</p>
<p>(2)更改 D:\Tomcat\conf\server.xml，指定浏览器的编码格式为“简体中文;方法是找到 server.xml 中的:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;25&quot;</span> <span class="attr">maxSpareThreads</span>=<span class="string">&quot;75&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">disableUploadTimeout</span>=<span class="string">&quot;true&quot;</span> <span class="attr">URIEncoding</span>=<span class="string">&#x27;GBK&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>(3)另一种方法:更该 Java 程序，我的程序是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ThreeParams extends HttpServlet &#123;</span><br><span class="line"> 	public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"> 	 	throws ServletException, IOException &#123;</span><br><span class="line">   			response.setContentType(&quot;text/html; charset=GBK&quot;);</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>

<p>(4)增加tomcat内存的方法:linux下，在文件{tomcat_home}&#x2F;bin&#x2F;catalina.sh的前面，增加如下设置：SET JAVA_OPTS&#x3D;-Xms512m -Xmx1024m;表示初始化内存为512MB，可以使用的最大内存为1024MB;windows下，在tomcat_home}&#x2F;bin&#x2F;catalina.bat的前面，增加如下设置：SET JAVA_OPTS&#x3D;-Xms512m -Xmx1024m;</p>
<p>(5)Jdk的版本:JDK分为三种不同的版本 JAVA SE(标准版）Java EE（企业版）Java ME(微型版)。</p>
<p>Java SE 以前称为J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE是基础包，但是也包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。</p>
<p>JavaEE:这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。</p>
<p>JavaME:这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</p>
<h3 id="3-谈谈对MVC的理解以及它的工作流程；"><a href="#3-谈谈对MVC的理解以及它的工作流程；" class="headerlink" title="3. 谈谈对MVC的理解以及它的工作流程；"></a>3. 谈谈对MVC的理解以及它的工作流程；</h3><p>(1)MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务;</p>
<p>jsp+Servlet+JavaBean 就是一种基础的基于mvc的开发模式;在MVC结构中，模型（Model）代表应用程序的数据（data）和用于控制访问和修改这些数据的业务规则（business rule）。通常模型被用来作为对现实世界中一个处理过程的软件近似，当定义一个模型时，可以采用一般的简单的建模技术。</p>
<p>当模型发生改变时，它会通知视（View），并且为视提供查询模型相关状态的能力。同时，它也为控制器（Controller）提供访问封装在模型内部的应用程序功能的能力。</p>
<p>一个视（View）用来组织模型的内容。它从模型那里获得数据并指定这些数据如何表现。当模型变化时，视负责维持数据表现的一致性。视同时将用户要求告知控制器（Controller）。</p>
<p>控制器（Controller）定义了应用程序的行为；它负责对来自视的用户要求进行解释，并把这些要求映射成相应的行为，这些行为由模型负责实现。在独立运行的GUI客户端，用户要求可能是一些鼠标单击或是菜单选择操作。在一个Web应用程序中，它们的表现形式可能是一些来自客户端的GET或POST的HTTP请求。模型所实现的行为包括处理业务和修改模型的状态。根据用户要求和模型行为的结果，控制器选择一个视作为对用户请求的应答。通常一组相关功能集对应一个控制器。</p>
<p>工作流程：一个请求发送到action(作用：MVC中的C),action控制它发送到哪个biz处理,如果用到数据库，那么biz在连接dao，然后返回要的数据，最后action在返回响应的页面(比如jsp),因为是面向对象,所以实体domain在中间传递数据。</p>
<h3 id="4-post和get以及get和load的区别？使用get应注意什么？"><a href="#4-post和get以及get和load的区别？使用get应注意什么？" class="headerlink" title="4. post和get以及get和load的区别？使用get应注意什么？"></a>4. post和get以及get和load的区别？使用get应注意什么？</h3><p>(1)Get 方法通过 URL 请求来传递用户的数据，将表单内各字段名称与其内容，以成对的字符串连接，以URL字串本身传递数据参数，在服务器端可以从’QUERY_STRING’这个变量中直接读取，效率较高，但缺乏安全性，也无法来处理复杂的数据（只能是字符串，比如在servlet&#x2F;jsp中就无法处理发挥java的比如vector之类的功能,输的数据量非常小，一般限制在 2 KB 左右）；</p>
<p>(2)Post 方法通过 HTTP post 机制，将表单内各字段名称与其内容放置在 HTML 表头(header)内一起传送给服务器端交由 action 属性能所指的程序处理，该程序会通过标准输入(stdin)方式，将表单的数据读出并加以处理post方式：就传输方式讲参数会被打包在数据报中传输，从CONTENT_LENGTH这个环境变量中读取，便于传送较大一些的数据，同时因为不暴露数据在浏览器的地址栏中，安全性相对较高，但这样的处理效率会受到影响。接收的最大数据有限制，IIS 4 中为 80 KB 字节，IIS 5 中为 100 KB 字节</p>
<p>(3)建议：除非你肯定你提交的数据可以一次性提交，否则请尽量用 Post 方法;Get 方式提交数据，会带来安全问题;通过 Get 方式提交数据时，用户名和密码将出现在 URL 上;所以表单提交建议使用 Post 方法；Post 方法提交的表单页面常见的问题是，该页面如果刷新的时候，会弹出一个对话框;</p>
<p>(4)Get与load的区别:总之对于get和load的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方法，hibernate一定要获取到真实的数据，否则返回null;</p>
<h3 id="5-java的九大内置对象和四大作用域；"><a href="#5-java的九大内置对象和四大作用域；" class="headerlink" title="5. java的九大内置对象和四大作用域；"></a>5. java的九大内置对象和四大作用域；</h3><p>(1)九大内置对象</p>
<ol>
<li>request 用户端请求，一次请求.此请求会包含来自GET&#x2F;POST请求的参数</li>
<li>response 网页传回用户端的回应</li>
<li>pageContext 网页的属性是在这里管理</li>
<li>session 与请求有关的会话期 </li>
<li>application servlet 正在执行的内容</li>
<li>out 用来传送回应的输出 </li>
<li>config servlet的构架部件</li>
<li>page JSP网页本身 </li>
<li>exception 针对错误网页，未捕捉的例外</li>
</ol>
<p>(2)四大作用域:</p>
<ol>
<li>page对象表示当前一个JSP页面，可以理解为一个对象本身,是代表与一个页面相关的对象和属性;一个页面由一个编译好的 Java servlet 类表示,</li>
<li>request是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）;用户端请求</li>
<li>session是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求 与请求有关的会话期 </li>
<li>application是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域 正在执行的内容</li>
</ol>
<h2 id="四-Ajax"><a href="#四-Ajax" class="headerlink" title="四 Ajax"></a>四 Ajax</h2><h3 id="1-js里面的button方法，提交的时候，如何将数据传递到数据库？"><a href="#1-js里面的button方法，提交的时候，如何将数据传递到数据库？" class="headerlink" title="1. js里面的button方法，提交的时候，如何将数据传递到数据库？"></a>1. js里面的button方法，提交的时候，如何将数据传递到数据库？</h3><p>(1)单击button的时候，先执行客户端的javascript代码，将JavaScript里面的值赋值到form表单里，然后通过表单提交的方式将数据提交到后台，交给java方法处理,然后调用业务层和数据库交互;</p>
<h3 id="2-Ajax与jquery区别？ajax和servelet生命周期？"><a href="#2-Ajax与jquery区别？ajax和servelet生命周期？" class="headerlink" title="2. Ajax与jquery区别？ajax和servelet生命周期？"></a>2. Ajax与jquery区别？ajax和servelet生命周期？</h3><p>(1)区别:Ajax是一门技术，它提供了异步更新的机制，使用客户端与服务器间交换数据而非整个页面文档，实现页面的局部更新。</p>
<p>​            jQuery是一个框架，它对JS (JS是一门前端语言) 进行了封装，使其更方便使用。jQuery使得JS与Ajax的使用更方便jsp负责客户端显示</p>
<p>servlet负责控制，转向等</p>
<p>(2)生命周期:</p>
<p>Servlet 生命周期：Servlet 加载—&gt;实例化—&gt;服务—&gt;销毁;</p>
<p>init（）：在Servlet的生命周期中，仅执行一次init()方法。它是在服务器装入Servlet时执行的，负责初始化Servlet对象。可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。</p>
<p>service（）：它是Servlet的核心，负责响应客户的请求。每当一个客户请求一个HttpServlet对象，该对象的Service()方法 就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在 HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。</p>
<p>destroy（）： 仅执行一次，在服务器端停止且卸载Servlet时执行该方法。当Servlet对象退出生命周期时，负责释放占用的资源。一个 Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。</p>
<p>Ajax:ajax负责客户端与服务器直接联系，而不用jsp提交表单。一般ajax与servlet联系，也可直接与javabean联系</p>
<h3 id="3-Jquery的常用标签，常用选择器。"><a href="#3-Jquery的常用标签，常用选择器。" class="headerlink" title="3. Jquery的常用标签，常用选择器。"></a>3. Jquery的常用标签，常用选择器。</h3><p>(1)标签: jquery常用标签 (document)&#x2F;&#x2F;选择整个文档对象;(document)&#x2F;&#x2F;选择整个文档对象;(‘#myId’) &#x2F;&#x2F;选择ID为myId的网页元素; (′div.myClass′)&#x2F;&#x2F;选择class为myClass的div元素;(′div.myClass′)&#x2F;&#x2F;选择class为myClass的div元素;(‘input[name&#x3D;first]’) &#x2F;&#x2F; 选择name属性等于first的input元素;</p>
<p>(2)常用函数:val() 用来获得value属性的值;html() 获得元素标签内的所有信息;包裹标签和文本,相当于DOM中的innerHTML;size()获得集合&#x2F;数组的长度;</p>
<p>(2)常用选择器: 基本选择器; 层次选择器; 过滤选择器; 表单选择器;</p>
<p>(2)#id : 根据给定的id匹配一个元素，返回单个匹配的元素：</p>
<p>(3).class:根据给定的类名匹配元素,返回集合元素</p>
<p>(4)*：匹配所有的元素,返回集合元素</p>
<p>(5)elements：根据给定的元素名匹配元素，返回集合元素</p>
<p>(6)Selector1选择器匹配：将每一个选择器匹配到的元素合并后一起返回</p>
<h3 id="4-JQ-封装ajax；异步通讯；从前台传过去jason，后台如何解析？"><a href="#4-JQ-封装ajax；异步通讯；从前台传过去jason，后台如何解析？" class="headerlink" title="4. JQ(封装ajax；异步通讯；从前台传过去jason，后台如何解析？"></a>4. JQ(封装ajax；异步通讯；从前台传过去jason，后台如何解析？</h3><p>(1)method：请求方式(GET&#x2F;POST)</p>
<p>*　　url：目标URL</p>
<p>*　　content：用POST方式发出请求时想传给服务器的数据，</p>
<p>*　　　　　　　　　数据以查询字串的方式列出，如：name&#x3D;value&amp;anothername&#x3D;othervalue。</p>
<p>*　　　　　　若用GET方式：请传null</p>
<p>*　　responseType：响应内容的格式(text&#x2F;xml)</p>
<p>*　　callback：要回调的函数</p>
<p>(2)异步通讯: </p>
<p>I:初始化对象并发送XMLHttpRequest请求(针对IE7.0、8.0、firefox、mozillar、opera、safari浏览器;var xmlhr&#x3D;new XMLHttpRequest;针对IE5.0、5.5、6.0,var xmlhr&#x3D;new ActiveXObject( );)</p>
<p>II:指定响应处理函数(onreadystatechange)</p>
<p>III:发出HTTP请求(send)</p>
<p>IIII:处理服务器返回的数据(responseXML)</p>
<p>(3)解析:首先，我们要在前台引入json的脚本，以便于把js对象序列化</p>
<script type="text/javascript" src="/js/jquery.json-2.4.min.js"></script>

<p>然后我们在前台声明一个类,将你要保存的值放到类里面，最后序列化</p>
<p>然后我们在后台，进行反序列化，并使用值.因为我们使用ajax所以要在后台的方法上加上[Ajax.AjaxMethod]特性，并且在你前台所在页面的cs里面也要加上Ajax的注册;</p>
<h3 id="五-框架"><a href="#五-框架" class="headerlink" title="五 框架"></a>五 框架</h3><h3 id="1-三大框架使用的版本？三大框架各核心组件及作用；如果不用三大框架，jdbc能不能下出来？"><a href="#1-三大框架使用的版本？三大框架各核心组件及作用；如果不用三大框架，jdbc能不能下出来？" class="headerlink" title="1. 三大框架使用的版本？三大框架各核心组件及作用；如果不用三大框架，jdbc能不能下出来？"></a>1. 三大框架使用的版本？三大框架各核心组件及作用；如果不用三大框架，jdbc能不能下出来？</h3><p>(1)三大框架的版本:struts 2;  spring 3;  hibernate 3.3;</p>
<p>(2)组件及作用:Java三大框架主要用来做WEb应用; Struts主要负责表示层的显示;Spring利用它的IOC和AOP来处理控制业务（负责对数据库的操作）;Hibernate主要是数据持久化到数据库;</p>
<p>(3)Struts的组件:Struts对Model，View和Controller都提供了对应的组件;</p>
<ul>
<li>Model部分：由JavaBean组成，ActionForm用于封装用户的请求参数，封装成ActionForm对象，该对象被ActionServlet转发给Action，Action根据ActionFrom里面的请求参数处理用户的请求。JavaBean则封装了底层的业务逻辑，包括数据库访问等。</li>
<li>View部分：该部分采用JSP实现。Struts提供了丰富的标签库，通过标签库可以减少脚本的使用，自定义的标签库可以实现与Model的有效交互，并增加了现实功能。对应上图的JSP部分。</li>
<li>Controller组件：Controller组件有两个部分组成——系统核心控制器，业务逻辑控制器。 　系统核心控制器，对应上图的ActionServlet。该控制器由Struts框架提供，继承HttpServlet类，因此可以配置成标注的Servlet。该控制器负责拦截所有的HTTP请求，然后根据用户请求决定是否要转给业务逻辑控制器。业务逻辑控制器，负责处理用户请求，本身不具备处理能力，而是调用Model来完成处理。对应Action部分。</li>
</ul>
<p>(4)Spring的组件:1、工厂类BeanFactory;  2、反转控制IOC;  3、面向切面编程AOP</p>
<ul>
<li>Spring实现了工厂模式的工厂类BeanFactory,在程序中通常BeanFactory的子类ApplicationContext。Spring相当于一个大的工厂类，在其配置文件中通过<bean>元素配置用于创建实例对象的类名和实例对象的属性。</li>
<li>Spring提供了对IOC良好支持，IOC是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦</li>
<li>Spring提供了对AOP技术的良好封装， AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码;例如，加入日志，加入权限判断，加入异常处理，这种应用称为AOP;</li>
</ul>
<p>(5)Hibernate的组件:五个核心接口:session接口,sessionFactory接口,configuration接口,transaction接口,query和criteria接口;</p>
<ul>
<li>Session接口：负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的SQL语句。)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSession对象称为用户session。</li>
<li>SessionFactory接口：负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。</li>
<li>Configuration接口：负责配置并启动Hibernate，创建SessionFactory对象。在Hibernate的启动的过程中，Configuration类的实例首先定位映射文档位置、读取配置，然后创建SessionFactory对象。</li>
<li>Transaction接口：负责事务相关的操作。它是可选的，开发人员也可以设计编写自己的底层事务处理代码。</li>
<li>Query和Criteria接口：负责执行各种数据库查询。它可以使用HQL语言或SQL语句两种表达方式.</li>
</ul>
<p>JDBC:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection cn=null;</span><br><span class="line">PreparedStatement pst=null;</span><br><span class="line">ResultSet rs=null;</span><br><span class="line">Try&#123;Class.forname(driverClassName);</span><br><span class="line">cn=DriverManager.getStatement(“sql”);</span><br><span class="line">pst.setString(1,statementName);</span><br><span class="line">rs=pst.executeQuery();</span><br><span class="line">While(rs.next())&#123;</span><br><span class="line">System.out.println();&#125;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">If(rs!=null)&#123;rs.close()&#125;;</span><br><span class="line">If(pst!=null)&#123;pst.close()&#125;;</span><br><span class="line">If(cn!=null)&#123;cn.close()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-hql语句是如何查询的？hql语句中内切和外切的区别？"><a href="#2-hql语句是如何查询的？hql语句中内切和外切的区别？" class="headerlink" title="2. hql语句是如何查询的？hql语句中内切和外切的区别？"></a>2. hql语句是如何查询的？hql语句中内切和外切的区别？</h3><p>(1):hql是面向对象的类名,属性区分大小写;from+你的实体类;</p>
<p>(2)内切:利用内连接可获取两表的公共部分的记录;采用左外连接查询返回的结果集中包含的是对象数组，对象数组中的每个元素存放了一对相互关联的Customer对象和Order对象，而迫切左外连接会返 回Customer对象，与Customer对象相关联的Order对象存放在Customer对象的集合元素对象中，这就是迫切左外连接和左外连接查询 的其中一个区别;另一个区别是当使用左外连接时，对关联对象的检索会依照实体映射配置文件所指定的策略，而不会像迫切左外连接那样忽略它，比如此时对Customer对象关联的Order对象采用延迟加载，那么左外连接检索也会使用延迟加载机制检索 Order对象。</p>
<p>(3)采用迫切内连接检索，对集合元素的检索策略以及返回结果集中的对象类型都采用与迫切左外连接一样的方式，QBC查询不支持迫切内连接检索.</p>
<h3 id="3-多表关联什么情况下用hashmap？"><a href="#3-多表关联什么情况下用hashmap？" class="headerlink" title="3. 多表关联什么情况下用hashmap？"></a>3. 多表关联什么情况下用hashmap？</h3><p>(1)Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据(class,interface,array )，但key不能重复。所以通过指定的key就可以取出对应的value。HashMap可以让你将空值作为一个表的条目的key或value，HashMap最多只有一个key值为null，但可以有无数多个value值为null。</p>
<p>spring mvc工作机制？MVC里面视图的好处？</p>
<p>工作机制:客户端请求提交到DispatcherServlet</p>
<p>由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller</p>
<p>DispatcherServlet将请求提交到Controller</p>
<p>Controller调用业务逻辑处理后，返回ModelAndView</p>
<p>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</p>
<p>视图负责将结果显示到客户端</p>
<p>视图的好处:视图对象的定义比实体定义还要简单，不需要注解，不需要映射,但是唯一不同的是我们需要额外构造一个带有字段初始化的构造函数</p>
<h3 id="4-hibernat和mybaitis的优势和区别？haibernate的缓存机制有没有了解过？如何使用hibernate将数据永久保存到数据库中？mybaitates是如何实现查询的？hibernate有很多数据操作时候如何优化？"><a href="#4-hibernat和mybaitis的优势和区别？haibernate的缓存机制有没有了解过？如何使用hibernate将数据永久保存到数据库中？mybaitates是如何实现查询的？hibernate有很多数据操作时候如何优化？" class="headerlink" title="4. hibernat和mybaitis的优势和区别？haibernate的缓存机制有没有了解过？如何使用hibernate将数据永久保存到数据库中？mybaitates是如何实现查询的？hibernate有很多数据操作时候如何优化？"></a>4. hibernat和mybaitis的优势和区别？haibernate的缓存机制有没有了解过？如何使用hibernate将数据永久保存到数据库中？mybaitates是如何实现查询的？hibernate有很多数据操作时候如何优化？</h3><p>  (1)mybaitis 的优势:· </p>
<ul>
<li><p>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。· </p>
</li>
<li><p>MyBatis容易掌握，而Hibernate门槛较高。</p>
<p>(2)hibernate的优势:· </p>
</li>
<li><p>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射； </p>
</li>
<li><p>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便；</p>
</li>
<li><p>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</p>
</li>
<li><p>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p>
<p>(3)区别:</p>
</li>
<li><p>Hibernate功能强大，数据库无关性好，O&#x2F;R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。·</p>
</li>
<li><p>MYBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。</p>
</li>
</ul>
<p>(4) Hibernate一级缓存是Session缓存，利用好一级缓存就需要对Session的生命周期进行管理好。建议在一个Action操作中使用一个Session。一级缓存需要对Session进行严格管理。Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存。内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定SQL语句等),对于应用程序来说,它是只读的。外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备。二级缓存称为进程级缓存或SessionFactory级缓存，它可以被所有session共享，它的生命周期伴随着SessionFactory的生命周期存在和消亡。</p>
<p> (5) mybatitis的查询:Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。mybatis是数据映射器（数据映射器层：用于在对象和数据库之间搬运数据，同时保证对象、数据库和数据映射器层本身相对独立。Martin Fowler 《企业应用架构模式》）把sql语句的参数与结果（即输入与输出）映射为类。为如何在类和数据库间建立映射带来了更大的灵活性。同时也更好的隔离了数据库设计和应用程序中使用的对象模型。</p>
<p> (6) hibernate 的持久化:Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。</p>
<p> (7) mybatis的调优:MyBatis在Session方面和Hibernate的Session生命周期是一致的，同样需要合理的Session管理机制。MyBatis同样具有二级缓存机制。 MyBatis可以进行详细的SQL优化设计。</p>
<p>(8) hibernate如何实现优化:· </p>
<ul>
<li>制定合理的缓存策略；</li>
<li>尽量使用延迟加载特性；· </li>
<li>采用合理的Session管理机制；· </li>
<li>使用批量抓取，设定合理的批处理参数（batch_size）;· </li>
<li>进行合理的O&#x2F;R映射设计</li>
</ul>
<h3 id="5-spring、hibernate、Struts的工作原理，为什么使用这些框架？简单说下struts2中数据传递情况？-hibernate的三种状态和彼此的区别？使用hibernate如何分页？spring的事务隔离级别？ssh如何整合（spring核心流程）？"><a href="#5-spring、hibernate、Struts的工作原理，为什么使用这些框架？简单说下struts2中数据传递情况？-hibernate的三种状态和彼此的区别？使用hibernate如何分页？spring的事务隔离级别？ssh如何整合（spring核心流程）？" class="headerlink" title="5. spring、hibernate、Struts的工作原理，为什么使用这些框架？简单说下struts2中数据传递情况？ hibernate的三种状态和彼此的区别？使用hibernate如何分页？spring的事务隔离级别？ssh如何整合（spring核心流程）？"></a>5. spring、hibernate、Struts的工作原理，为什么使用这些框架？简单说下struts2中数据传递情况？ hibernate的三种状态和彼此的区别？使用hibernate如何分页？spring的事务隔离级别？ssh如何整合（spring核心流程）？</h3><p>(1)spring的工作原理:</p>
<ol>
<li>Spring内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行 时动态的区创建、调用对象，Spring就是在运行时，跟xmlSpring的配置文件来动态的创建对象，和调用对象里的方法。</li>
<li>Spring工作原理还有一个核心就是Aop这个就是面向切面的编程，可以为某一类对象进行监督和控制(也就是在调用这类对象的具体方法的前后去调用你指定的模块)从而达到对一个模块扩充的功能这些都是通过配置类达到的。</li>
<li>Spring目的：就是让对象与对象(模块与模块)之间的关系没有通过代码来关联，都是通过配置类说明管理的(主要是通过反射机制)。</li>
</ol>
<p>(2)hibernate的工作原理:</p>
<ol>
<li>读取并解析hibernate.cfg.xml配置文件</li>
<li>读取并解析映射信息</li>
<li>创建SessionFactory</li>
<li>负责被持久化对象CRUD操作,打开Sesssion</li>
<li>创建并启动事务Transation</li>
<li>操作数据，持久化操作</li>
<li>提交事务,关闭Session,关闭SesstionFactory;</li>
</ol>
<p>(3)struts的工作原理同下:</p>
<ol>
<li>客户端浏览器发出HTTP请求。</li>
<li>根据web.xml配置，该请求被FilterDispatcher接收。</li>
<li>根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。</li>
<li>Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。</li>
<li>Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。</li>
<li>返回HTTP响应到客户端浏览器。</li>
</ol>
<p>(4)使用原因:</p>
<ul>
<li>struts是开源软件。使用Struts的目的是为了帮助我们减少在运用MVC设计模型来开发Web应用的时间。如果我们想混合使用Servlets和JSP的优点来建立可扩展的应用，struts是一个不错的选择。</li>
<li>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet&#x2F;JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任;</li>
<li>Spring:Spring是一个开源框架,它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益.</li>
</ul>
<p>(5)struts数据传递:可以直接基于应用程序域对象转移，验证数据，数据绑定，动作把从请求接收到的所有数据放在简单的JavaBean上。除了单独接受每个数 据，struts2最优雅的地方时可以创建一个对象来放置这些琐碎的数据，我们可以把复杂对象本身提供给平台的数据转移机制。这不但节省时间，而且也能节 省工作量。</p>
<p>(6)hibernate的三种状态和区别:</p>
<ul>
<li>瞬时(transient)：也叫自由状态.<a target="_blank" rel="noopener" href="http://www.2cto.com/database/">数据库</a>中没有数据与之对应，超过作用域会被JVM垃圾回收器回收，一般是new出来且与session没有关联的对象。</li>
<li>持久(persistent)：数据库中可能有数据与之对应(save)，当前与session有关联，并且相关联的session没有关闭，事务没有提交；持久对象状态发生改变，在事务提交时会影响到数据库(hibernate能检测到)。</li>
<li>脱管(detached)：也叫游离状态.数据库中可能有数据与之对应，但当前没有session与之关联，但是有oid；托管对象状态发生改变，hibernate不能检测到。</li>
<li>区别:Transient状态的实体缺乏与数据库表记录之间的联系,而Detached状态的实体恰恰相反.只不过是脱离了session这个数据库操作平台而已.</li>
</ul>
<p>(7)hibernate分页:</p>
<p>1.HQL查询:Query query&#x3D;session.createQuery(from 实体类);</p>
<p>2.从第几条开始:query.setFirstResult(mini);</p>
<p>3.每次最多提取多少条数据:query.setMaxResults(max);</p>
<p>接收返回的结果集:List&lt;实体类&gt; HousesList&#x3D;query.list();</p>
<p>代码如下(Query query &#x3D; session.createQuery(hql); </p>
<p>query.setParameter(0, userId); </p>
<p>query.setMaxResults(maxCount); </p>
<p>query.setFirstResult(firstResult); </p>
<p>return query.list();</p>
<p>)</p>
<p>(8)ssh整合步骤:</p>
<ul>
<li>1.导入struts2的jar包以及struts2-spring-plugin-2.0.11.2.jar; </li>
<li>2.在web.xml中分别配置struts2与spring相关信息;</li>
<li>3.struts中原有的Action需要继承ActionSupport;</li>
<li>4.在Spring配置Action Bean;</li>
<li>5.在Struts2的配置文件中，调用Spring中配置的Bean;</li>
<li>6.Spring与Hibernate整合，只需要在Spring配置文件配置SessionFactory即可</li>
</ul>
<p>(9)Spring的隔离级别:Default默认的事务隔离级别</p>
<ul>
<li>READ_UNCOMMITTED读未提交，一个事务可以操作另外一个未提交的事务，不能避免脏读，不可重复读，幻读，隔离级别最低，并发性 能最高</li>
<li>READ_COMMITTED读已提交，一个事务不可以操作另外一个未提交的事务， 能防止脏读，不能避免不可重复读，幻读。</li>
<li>repeatable_read能够避免脏读，不可重复读，不能避免幻读</li>
<li>SERIALIZABLE隔离级别最高，消耗资源最低，代价最高，能够防止脏读， 不可重复读，幻读。</li>
</ul>
<h3 id="6-Struts的工作流程；"><a href="#6-Struts的工作流程；" class="headerlink" title="6. Struts的工作流程；"></a>6. Struts的工作流程；</h3><p>工作流程:</p>
<ul>
<li>(1)客户端提交一个HttpServletRequest请求（action或JSP页面）。</li>
<li>(2)请求被提交到一系列Filter过滤器，如ActionCleanUp和FilterDispatcher等。</li>
<li>(3)FilterDispatcher是Struts2控制器的核心，它通常是过滤器链中的最后一个过滤器.</li>
<li>(4)请求被发送到FilterDispatcher后，FilterDispatcher询问ActionMapper时候需要调用某个action来处理这个Request。</li>
<li>(5)如果ActionMapper决定需要调用某个action，FilterDispatcher则把请求交给ActionProxy进行处理.</li>
<li>(6)ActionProxy通过Configuration Manager询问框架的配置文件struts.xml，找到调用的action类。</li>
<li>(7)ActionProxy创建一个ActionInvocation实例，通过代理模式调用Action。</li>
<li>(8)action执行完毕后，返回一个result字符串，此时再按相反的顺序通过Intercepter拦截器。</li>
<li>(9)最后ActionInvocation实例，负责根据struts.xml中配置result元素，找到与之相对应的result，决定进一步输出。</li>
</ul>
<p>基本简要流程:</p>
<ul>
<li>I.客户端浏览器发出HTTP请求。</li>
<li>II.根据web.xml配置，该请求被FilterDispatcher接收。</li>
<li>III.根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。</li>
<li>IV.Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。 </li>
<li>VI.Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。VI.返回HTTP响应到客户端浏览器。</li>
</ul>
<h3 id="7-简述SSH工作流程；"><a href="#7-简述SSH工作流程；" class="headerlink" title="7. 简述SSH工作流程；"></a>7. 简述SSH工作流程；</h3><p>(1)JSP页面发出请求，Struts接收页面请求，Struts的action调用业务逻辑，业务逻辑调用业务组件（其中使用到Spring的依赖注入 IOC，或者AOP等）；业务组件根据Hibernate的对象&#x2F;关系数据库的映射关系查询数据库。Struts根据结果返回页面。</p>
<h3 id="8-谈谈Spring和Spring-MVC的流程和事务；spring配置文件都写什么？"><a href="#8-谈谈Spring和Spring-MVC的流程和事务；spring配置文件都写什么？" class="headerlink" title="8. 谈谈Spring和Spring MVC的流程和事务；spring配置文件都写什么？"></a>8. 谈谈Spring和Spring MVC的流程和事务；spring配置文件都写什么？</h3><p>(1)spring提供两种管理事务的方式:一种是声明式事务，一种是编程式事务。</p>
<p>Spring的声明式事务管理，基于Spring的AOP，基于Spring AOP实现，几乎就是xml文件的配置,不再需要不停地写commit，rollback，（但Spring仍然没有放弃编程式的事务管理策略）。</p>
<p>Spring的编程式事务管理，统一的事务编码风格，几乎是一个模板化的。</p>
<p>为我们提供了一个TransactionTemplate，使用回调机制，将应用代码从样板式的资源获取和释放代码中解放出来，不再有大量的try&#x2F;catch&#x2F;finally&#x2F;try&#x2F;catch代码块。</p>
<p>(2)springMVC的流程和事务:动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射 ,反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置<br>文件来动态的创建对象，和调用对象里的方法的 。</p>
<p>Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）<br>要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。</p>
<p>(3)spring的配置文件:一、引用外部属性文件;二、常用数据源的配置;三、配置事务管理器;四、context:component-scan<!-- 对包中的所有类进行扫描，以完成Bean创建和自动依赖注入的功能 -->;五、aop注解支持;六、缓存配置;七、<!-- Spring、MyBatis的整合，需要在 Spring 应用上下文中定义至少两样东西：一个SqlSessionFactory和至少一个数据映射器类（UserMapper->iocContext.xml）。 -->;</p>
<p>\9. ssm和ssh的区别？</p>
<p>(1)基于MVC三层架构，使用ssh框架 or ssm框架 or ssi框架，采用面向接口的方式编程。<br>共同点是struts、spring，不同点是nibernate和mybatis、ibatis。</p>
<p>(2)相对Hibernate“O&#x2F;R”而言，iBATIS 是一种“Sql Mapping”的ORM实现。</p>
<p>(3)由于hibernate是完全面向对象的编程，在实现dao中就非常的方便，而且不重复；当mybatis在.java代码中也是可以做到不重复，麻烦一点的是，每个映射文件都必须编写几乎相同的配置，除了resultType不一样。</p>
<p>(4)hibernate在实际编程中可以把基础的CRUD封装，比如BaseDao类。其它类只要去继承BaseDao就能执行所有的基础的CRUD。这样就非常方便。这个带来的好处还有，可以建立BaseService和BaseAction。 </p>
<p>由于mybatis的映射文件中，虽然SQL语句中的表名可以通过parameterType指定，但是resultType必须定死，不能以参数 的形式给予指定。导致的结果就是所有的DAO类的每个CRUD都必须和指定的映射文件绑定在一起，以至于不可能存在BaseDao类。当然也就不能建立 BaseService和BaseAction。</p>
<p>\10. spring核心：aop和ioc的解释？隔离范围？ 3种注入方法？</p>
<p>(1)aop:Spring提供了对AOP技术的良好封装， AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码;例如，加入日志，加入权限判断，加入异常处理，这种应用称为AOP。实现AOP功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK中采用Proxy类产生动态代理的方式为某个接口生成实现类，spring提供了这种支持，只需要在spring配置文件中配置这两个元素即可实现代理和aop功能;</p>
<p>(2)Ioc:Spring提供了对IOC良好支持，IOC是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC也称为DI（Depency Injection）;IOC可以理解为‘面向接口编程思想’的一种实现方法，通过IOC实现了强制的‘面向接口编程’。</p>
<p>(3)隔离范围: Spring支持<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=JDBC&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y4rjn4PvNhrjbYnvnzryPh0AP8IA3qPjfsn1bkrjKxmLKz0ZNzUjdCIZwsrBtEXh9GuA7EQhF9pywdQhPEUiqkIyN1IA-EUBt1nWfkP101PHm">JDBC</a>规范定义的四种隔离级别</p>
<p>Default默认的事务隔离级别</p>
<p>READ_UNCOMMITTED读未提交，一个事务可以操作另外一个未提交的事务，不能避免脏读，不可重复读，幻读，隔离级别最低，并发性 能最高</p>
<p>READ_COMMITTED读已提交，一个事务不可以操作另外一个未提交的事务， 能防止脏读，不能避免不可重复读，幻读。</p>
<p>repeatable_read能够避免脏读，不可重复读，不能避免幻读</p>
<p>SERIALIZABLE隔离级别最高，消耗资源最低，代价最高，能够防止脏读， 不可重复读，幻读。</p>
<p>(4)Spring的注入和IoC反转控制是一回事;关于getter和setter方式的注入;</p>
<p>Autowire&#x3D;”defualt”;autowire&#x3D;”byName”;autowire&#x3D;”byType”;</p>
<p>\11. 两亿条数据如何同时删除</p>
<p>(1)· public boolean delUsers(String[] userIds){ </p>
<p>·     boolean flag &#x3D; false; </p>
<p>·     Connection conn &#x3D; null; </p>
<p>·     PreparedStatement pstmt &#x3D; null;  </p>
<p>·     String sql &#x3D; “delete from t_user where user_id&#x3D;?”; </p>
<p>·     try { </p>
<p>·       conn &#x3D; DbUtil.getConnection(); </p>
<p>·       conn.setAutoCommit(false); </p>
<p>·       pstmt &#x3D; conn.prepareStatement(sql); </p>
<p>·       for(int i &#x3D;0 ;i&lt;userIds.length;i++){  </p>
<p>·         pstmt.setString(1,userIds[i].trim()); </p>
<p>·         pstmt.addBatch();         </p>
<p>·       }  </p>
<p>·       pstmt.executeBatch(); &#x2F;&#x2F;批量执行  </p>
<p>·       conn.commit();&#x2F;&#x2F;提交事务 </p>
<p>·       flag &#x3D; true; </p>
<p>·     } catch (SQLException e) { </p>
<p>·       try { </p>
<p>·         conn.rollback(); &#x2F;&#x2F;进行事务回滚 </p>
<p>·       } catch (SQLException ex) {  </p>
<p>·       }  </p>
<p>·     }finally { </p>
<p>·       DbUtil.close(pstmt); </p>
<p>·       DbUtil.close(conn); </p>
<p>·     }  </p>
<p>·     return flag; </p>
<p>·   } </p>
<p>\12. 如何将1个g的数据最快速度放进C盘中?</p>
<p>(1)public class Test01 {</p>
<p>  public static void main(String[] args) throws Exception{</p>
<p>​    getInputStream(“C:\setup.log”,”D:\a.txt”);</p>
<p>  }</p>
<p>  private static void getInputStream(String pathName,String copyName)throws Exception{</p>
<p>​    File file &#x3D; new File(pathName);</p>
<p>​    if(!file.exists())</p>
<p>​      throw new RuntimeException(“文件不存在呀,你Copy个屁！”);</p>
<p>​    else{</p>
<p>​      getCopy(copyName,new BufferedInputStream(new FileInputStream(file)));</p>
<p>​    }</p>
<p>  }</p>
<p>  private static void getCopy(String copyName,BufferedInputStream bis)throws Exception{</p>
<p>​    BufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(copyName));</p>
<p>​    BufferedInputStream biss &#x3D; bis;</p>
<p>​    byte[] b &#x3D; new byte[biss.available()];</p>
<p>​    int len &#x3D; 0;</p>
<p>​    while((len &#x3D; biss.read(b))!&#x3D;-1){</p>
<p>​      bos.write(b, 0, len);</p>
<p>​    }</p>
<p>​    bos.close();</p>
<p>​    biss.close();</p>
<p>​    System.out.println(copyName+”复制成功！”);</p>
<p>  }</p>
<p>冒泡排序:</p>
<p>public static void bubbleSort(int[] numbers) {<br>  int temp; &#x2F;&#x2F; 记录临时中间值<br>  int size &#x3D; numbers.length; &#x2F;&#x2F; 数组大小<br>  for (int i &#x3D; 0; i &lt; size - 1; i++) {<br>    for (int j &#x3D; i + 1; j &lt; size; j++) {<br>      if (numbers[i] &lt; numbers[j]) { &#x2F;&#x2F; 交换两数的位置<br>        temp &#x3D; numbers[i];<br>        numbers[i] &#x3D; numbers[j];<br>        numbers[j] &#x3D; temp;<br>      }<br>    }<br>  }<br>} </p>
<p>选择排序:</p>
<p>public static void selectSort(int[] numbers) {<br>  int size &#x3D; numbers.length, temp;<br>  for (int i &#x3D; 0; i &lt; size; i++) {<br>    int k &#x3D; i;<br>    for (int j &#x3D; size - 1; j &gt;i; j–) {<br>      if (numbers[j] &lt; numbers[k]) k &#x3D; j;<br>    }<br>    temp &#x3D; numbers[i];<br>    numbers[i] &#x3D; numbers[k];<br>    numbers[k] &#x3D; temp;<br>  }<br>} </p>
<h2 id="项目面试通关必懂"><a href="#项目面试通关必懂" class="headerlink" title="项目面试通关必懂"></a>项目面试通关必懂</h2><h3 id="项目通用问题："><a href="#项目通用问题：" class="headerlink" title="项目通用问题："></a>项目通用问题：</h3><ol>
<li><p>介绍下整个项目流程，谈谈你自己负责的模块？别人的模块是否了解？</p>
</li>
<li><p>讲解下自己负责的模块，这个模块如何实现的？做这个项目时候遇到怎样的问题？</p>
</li>
<li><p>你在项目组中的角色和优势？</p>
</li>
<li><p>做项目的时间，项目组几个人，多长时间完成？</p>
</li>
<li><p>介绍下算法和项目的思路？</p>
</li>
<li><p>问session和cooie的区别？</p>
</li>
</ol>
<p>  (1)具体来说cookie机制采用的是在客户端保持状态的方案，而session 机制采用的是在服务器端保持状态的方案。由于才服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上还有其他选择。</p>
<ol start="7">
<li><p>问登陆页；</p>
</li>
<li><p>Spring事务；</p>
</li>
<li><p>同步锁；</p>
</li>
<li><p>往关联两个表中添加数据，如果没有添加成功，会怎样？如何处理？</p>
</li>
<li><p>说下使用的项目ssm框架和使用的技术Json和ajax。</p>
</li>
<li><p>大数据如何处理？数据库如何批量删除和批量插入？</p>
</li>
</ol>
<p>具体项目还要清楚</p>
<p>一：好买网商城项目</p>
<p>1：商城项目的需求，介绍整个项目流程；</p>
<p>二：你我贷金融P2P项目</p>
<p>1．项目利息问题；</p>
<p>2．身份如何验证的问题？</p>
<p>3．项目的逻辑关系？</p>
<p>4．第三方接口怎么写？</p>
<p>5．违约如何提醒的问题？</p>
<p>6．金额除不尽的问题？</p>
<p>三 进销存项目：</p>
<p>1．介绍下进销存项目？</p>
<p>介绍项目时先说项目需求，然后从开始的进销存进货说到最后，进销存的模块：进货、销售、库存、财务报表、用户管理、信用冻结、全局资源，然后按照销售流程把项目贯穿一下。</p>
<p>2.进销存项目负责的模块是什么？</p>
<p>3.权限：权限分配；做权限控制，数据库关系映射介绍下？</p>
<p>4.数据库资金类型设置成bigdecimal还是double？</p>
<p>5.报表用的是什么？</p>
<p>6.一个项目数据库牵扯几个表？</p>
<p>7.进销存多少个表？用户管理方面多少个模块？用户管理模块多少个表？</p>
<p>8.如何判断是自己的采购、给哪家公司做的、好多人买东西发生了错误如何解决（事物&amp;多线程）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/JAVA%E5%BF%85%E8%83%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E9%80%9A%E5%85%B3%E8%A6%81%E7%82%B9/" data-id="cl0j84jyy00f404vh7gzr1oz6" data-title="JAVA必背面试题和项目面试通关要点" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式——单例模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.314Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>概念：<br>　　java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。<br>　　单例模式有以下特点：<br>　　1、单例类只能有一个实例。<br>　　2、单例类必须自己创建自己的唯一实例。<br>　　3、单例类必须给所有其他对象提供这一实例。<br>　　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>
<h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可能会浪费空间</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">byte</span>[] data1 = <span class="keyword">new</span> <span class="title class_">byte</span>[ <span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data2 = <span class="keyword">new</span> <span class="title class_">byte</span>[ <span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data3 = <span class="keyword">new</span> <span class="title class_">byte</span>[ <span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data4 = <span class="keyword">new</span> <span class="title class_">byte</span>[ <span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;&#125;	<span class="comment">//构造器私有</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();	<span class="comment">//直接加载使用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HUNGRY;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="懒汉单例"><a href="#懒汉单例" class="headerlink" title="懒汉单例"></a>懒汉单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.使用如下方式再次解决单例被破坏   但还是可以被破坏，如先破坏这个私有，再回去破坏LazyMan私有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">qinjiang</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">			<span class="keyword">if</span> (qinjiang ==<span class="literal">false</span>)<span class="type">i</span></span><br><span class="line">				<span class="variable">qinjiang</span> <span class="operator">=</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图使用反射破坏异常&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//9999999999999999999999999999999999999999999</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//8.解决 反射破坏单例模型的方法-----》三重检测</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">			<span class="keyword">if</span> (LazyMan ! =nu11)&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图使用反射破坏异常&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">//888888888888888888888888888888</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;	<span class="comment">//6. 所以一定要加上volatile关键字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 双重检测锁模式的 懒汉式单例 DCL懒汉式</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.加上锁可以解决多线程问题</span></span><br><span class="line">            <span class="keyword">synchronized</span>(LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (LazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">					LazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();	<span class="comment">//5.依旧存在问题：不是原子性操作</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    *1.分配内存空间</span></span><br><span class="line"><span class="comment">					*2.执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">					*3.把这个对象指同这个空间</span></span><br><span class="line"><span class="comment">					* 123</span></span><br><span class="line"><span class="comment">					* 132 A 指令重排</span></span><br><span class="line"><span class="comment">					* B</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> LazyMan;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1.单线程的情况下ok，但是多线程并发不行</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                LayMan.getInstance();<span class="comment">//2.结果是偶尔成功，偶尔失败</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.反射! 任何代码都可以使用反射去破坏代码私有性 破坏单例</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> LazyMan.getInstance();</span><br><span class="line">		Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>); 			declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">		<span class="type">LazyMan</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredconstructor.newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第8步解决了反射破坏单例模型致使上面两种对象不相同，但如下利用反射创建对象又会破坏单例模型</span></span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> declaredconstructor.newInstance();</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredconstructor.newInstance();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">		system.out.println(instance);</span><br><span class="line">        system.out.println(instance2);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstace</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> InnerClass. HOLDER;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">HOLDER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// enum是一个什么?本身也是一个cLass类</span><br><span class="line">public enum EnumSingle &#123;</span><br><span class="line">	INSTANCE;	//枚举</span><br><span class="line">	public EnumSingle getInstance()i</span><br><span class="line">			return INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String[] args) i</span><br><span class="line">	EnumSingle instance1 = EnumSingle.INSTANCE;EnumSingle instance2 = EnumSingle.INSTANCE;</span><br><span class="line">	System.out.println(instance1);</span><br><span class="line">	System.out.println(instance2);  //1 2相同</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" data-id="cl0j84jxt00bu04vh5t378r3l" data-title="单例模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式的通俗解释" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.299Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A/">23 种设计模式的通俗解释</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="23-种设计模式的通俗解释"><a href="#23-种设计模式的通俗解释" class="headerlink" title="23 种设计模式的通俗解释"></a>23 种设计模式的通俗解释</h1><h2 id="01-工厂方法"><a href="#01-工厂方法" class="headerlink" title="01 工厂方法"></a><strong>01 工厂方法</strong></h2><p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。</p>
<p>消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<h2 id="02-建造者模式"><a href="#02-建造者模式" class="headerlink" title="02 建造者模式"></a><strong>02 建造者模式</strong></h2><p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>
<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<h2 id="03-抽象工厂"><a href="#03-抽象工厂" class="headerlink" title="03 抽象工厂"></a><strong>03 抽象工厂</strong></h2><p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>
<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<h2 id="04-原型模式"><a href="#04-原型模式" class="headerlink" title="04 原型模式"></a><strong>04 原型模式</strong></h2><p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>
<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<h2 id="05-单例模式"><a href="#05-单例模式" class="headerlink" title="05 单例模式"></a><strong>05 单例模式</strong></h2><p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>
<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。</p>
<h2 id="06-适配器模式"><a href="#06-适配器模式" class="headerlink" title="06 适配器模式"></a><strong>06 适配器模式</strong></h2><p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>
<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<h2 id="07-桥梁模式"><a href="#07-桥梁模式" class="headerlink" title="07 桥梁模式"></a><strong>07 桥梁模式</strong></h2><p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>
<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联    变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 &#x2F; 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<h2 id="08-合成模式"><a href="#08-合成模式" class="headerlink" title="08 合成模式"></a><strong>08 合成模式</strong></h2><p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包    起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>
<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<h2 id="09-装饰模式"><a href="#09-装饰模式" class="headerlink" title="09 装饰模式"></a><strong>09 装饰模式</strong></h2><p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<h2 id="10-门面模式"><a href="#10-门面模式" class="headerlink" title="10 门面模式"></a><strong>10 门面模式</strong></h2><p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。</p>
<p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<h2 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11 享元模式"></a><strong>11 享元模式</strong></h2><p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。</p>
<p>享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。</p>
<p>将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<h2 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12 代理模式"></a><strong>12 代理模式</strong></h2><p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。</p>
<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h2 id="13-责任链模式"><a href="#13-责任链模式" class="headerlink" title="13 责任链模式"></a><strong>13 责任链模式</strong></h2><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>
<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<h2 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14 命令模式"></a><strong>14 命令模式</strong></h2><p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>
<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<h2 id="15-解释器模式"><a href="#15-解释器模式" class="headerlink" title="15 解释器模式"></a><strong>15 解释器模式</strong></h2><p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>
<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。</p>
<p>在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<h2 id="16-迭代模式"><a href="#16-迭代模式" class="headerlink" title="16 迭代模式"></a><strong>16 迭代模式</strong></h2><p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>
<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>
<p>迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<h2 id="17-调停者模式"><a href="#17-调停者模式" class="headerlink" title="17 调停者模式"></a><strong>17 调停者模式</strong></h2><p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>
<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h2 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18 备忘录模式"></a><strong>18 备忘录模式</strong></h2><p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h2 id="19-观察者模式"><a href="#19-观察者模式" class="headerlink" title="19 观察者模式"></a><strong>19 观察者模式</strong></h2><p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>
<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<h2 id="20-状态模式"><a href="#20-状态模式" class="headerlink" title="20 状态模式"></a><strong>20 状态模式</strong></h2><p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>
<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>
<p>状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<h2 id="21-策略模式"><a href="#21-策略模式" class="headerlink" title="21 策略模式"></a><strong>21 策略模式</strong></h2><p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>
<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<h2 id="22-模板方法模式"><a href="#22-模板方法模式" class="headerlink" title="22 模板方法模式"></a><strong>22 模板方法模式</strong></h2><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>
<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h2 id="23-访问者模式"><a href="#23-访问者模式" class="headerlink" title="23 访问者模式"></a><strong>23 访问者模式</strong></h2><p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>
<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>
<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A/" data-id="cl0j84jyn00eh04vhhph9c5rt" data-title="23 种设计模式的通俗解释" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式——抽象工厂模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.296Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">设计模式——抽象工厂模式抽象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>核心本质:<br>        实例化对象不使用new，用工厂方法代替<br>        将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</p>
<p>三种模式:<br>◆简单工厂模式<br>        ◆用来生产同一等级结构中的任意产品（对于增加新的产品，需要覆盖已有代码)</p>
<p>◆工厂方法模式<br>        ◆用来生产同一等级结构中的固定产品（支持增加任意产品)</p>
<p>◆抽象工厂模式<br>        ◆围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>
<p>UML类图</p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210712095229926.png" alt="image-20210712095229926"></p>
<p>定义︰抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类</p>
<p>适用场景:</p>
<p>​        客户端(应用层)不依赖于产品类实例如何被创建、实现等细节</p>
<p>​        强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码</p>
<p>​        提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现</p>
<p>优点:<br>        具体产品在应用层的代码隔离，无需关心创建的细节</p>
<p>​        将一个系列的产品统一到一起创建</p>
<p>缺点:<br>        规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难;</p>
<p>​        增加了系统的抽象性和理解难度</p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210712100406842.png" alt="image-20210712100406842"></p>
<p>第一步创建产品的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手机产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IphoneProduct</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">callup</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由器产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRouteProduct</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">openwifi</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setting</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步实现具体的产品类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小米手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title class_">IphoneProduct</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;关机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callup</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//华为手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaiweiPhone</span> <span class="keyword">implements</span> <span class="title class_">IphoneProduct</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;”关机“&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callup</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;“打电话”&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;”发短信“&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小米路由器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiRouter</span> <span class="keyword">implements</span> <span class="title class_">IRouteProduct</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;”关机“&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openwifi</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;“打开wifi”&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setting</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;”设置“&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//华为路由器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiRouter</span> <span class="keyword">implements</span> <span class="title class_">IRouteProduct</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;”关机“&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openwifi</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;“打开wifi”&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setting</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;”设置“&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步创建产品工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象产品工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IProductFactory</span>&#123;</span><br><span class="line">	<span class="comment">//生产手机</span></span><br><span class="line">	IPhoneProduct <span class="title function_">iPhoneProduct</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//生产路由器</span></span><br><span class="line">	IRouteProudct <span class="title function_">iRouteProudct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小米工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title class_">IProductFactory</span>&#123;</span><br><span class="line">	<span class="meta">@Overrid</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">IPhoneProduct</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiPhone</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Overrid</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">IRouteProduct</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiRoute</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//华为工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title class_">IProductFactory</span>&#123;</span><br><span class="line">	<span class="meta">@Overrid</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">IPhoneProduct</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Overrid</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">IRouteProduct</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiIRoute</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;===============小米系列产品============&quot;</span>)</span><br><span class="line">        <span class="comment">//小米工厂</span></span><br><span class="line">        <span class="type">XiaomiFactory</span> <span class="variable">xiaomiFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaomiFactory</span>();</span><br><span class="line">        <span class="comment">//小米手机产品</span></span><br><span class="line">        <span class="type">IphoneProduct</span> <span class="variable">iphoneProduct</span> <span class="operator">=</span> xiaomiFactory.iphoneProduct();</span><br><span class="line">        <span class="comment">//产品属性</span></span><br><span class="line">        iphoneProduct.callup();</span><br><span class="line">        iphoneProduct.sendSMS();</span><br><span class="line">        <span class="comment">//小米路由器</span></span><br><span class="line">        <span class="type">IRouteProduct</span> <span class="variable">iRouterProduct</span> <span class="operator">=</span> xiaomiFactory.iRouteProduct();</span><br><span class="line">        iRouterProduct.openwifi();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210712103427446.png" alt="image-20210712103427446"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" data-id="cl0j84jxv00c004vh631wbvhp" data-title="设计模式——抽象工厂模式抽象" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式——OOP七大原则" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.289Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/">设计模式——OOP七大原则</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="OOP七大原则"><a href="#OOP七大原则" class="headerlink" title="OOP七大原则"></a>OOP七大原则</h1><p><strong>开闭原则</strong>:对扩展开放，对修改关闭</p>
<p><strong>里氏替换原则</strong>:继承必须确保超类所拥有的性质在子类中仍然成立</p>
<p><strong>依赖倒置原则</strong>:要面向接口编程，不要面向实现编程。</p>
<p><strong>单一职责原则</strong>:控制类的粒度大小、将对象解耦、提高其内聚性。接口隔离原则:要为各个类建立它们需要的专用接口</p>
<p><strong>迪米特法则</strong>:只与你的直接朋友交谈，不跟“陌生人”说话。</p>
<p><strong>合成复用原则</strong>:尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/" data-id="cl0j84jxs00bp04vhf49ihkmh" data-title="设计模式——OOP七大原则" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式——建造者模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T07:11:57.286Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式——建造者模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><ul>
<li>建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式。</li>
<li>定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li>
<li>主要作用: 在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</li>
<li>用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象(把内部的建造过程和细节隐藏起来)</li>
<li>例子:<br>**工厂(建造者模式)**︰负责制造汽车（组装过&gt;程和细节在工厂内)<br>**汽车购买者(用户)**︰你只需要说出你需要的&gt;型号(对象的类型和内容)，然后直接购买就可以使用了(不需要知道汽车是怎么组装的（车轮、车门、&gt;发动机、方向盘等等）)</li>
</ul>
<p><strong>角色分析</strong>:</p>
<p><img src="https://gitee.com/Sobremesa_bolg/pic-go_img/raw/master/images/image-20210712145632067.png" alt="image-20210712145632067"></p>
<p>​    既然是建造者模式，那么我们还是继续造房吧。假设造房简化为如下步骤:(1)地基(2）钢筋工程(3）铺电线(4）粉刷;    如果要盖一座房子，首先要找一个建筑公司或工程承包商（指挥者)。承包商指挥工人(具体建造者)过来造房子(产品)，最后验收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//抽象的建造者： 不负责造房子，只负责定义方法或者接口</span><br><span class="line">public abstract class Builder &#123;</span><br><span class="line"></span><br><span class="line">    abstract  void  buildA();   //地基</span><br><span class="line">    abstract  void  buildB();   //钢筋工程</span><br><span class="line">    abstract  void  buildC();   //铺电线</span><br><span class="line">    abstract  void  buildD();   //粉刷</span><br><span class="line"></span><br><span class="line">    //完工：得到产品</span><br><span class="line">    abstract Product getProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//具体的建造者：工人</span><br><span class="line">public class Worker extends Builder&#123;</span><br><span class="line"></span><br><span class="line">    private Product product;</span><br><span class="line">    public Worker()&#123;</span><br><span class="line">        product = new Product();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildA() &#123;</span><br><span class="line">        product.setBuidA(&quot;地基&quot;);</span><br><span class="line">        System.out.println(&quot;地基&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildB() &#123;</span><br><span class="line">        product.setBuidB(&quot;钢筋工程&quot;);</span><br><span class="line">        System.out.println(&quot;钢筋工程&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildC() &#123;</span><br><span class="line">        product.setBuidC(&quot;铺电线&quot;);</span><br><span class="line">        System.out.println(&quot;铺电线&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildD() &#123;</span><br><span class="line">        product.setBuidD(&quot;粉刷&quot;);</span><br><span class="line">        System.out.println(&quot;粉刷&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product getProduct() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//产品：房子</span><br><span class="line">public class Product &#123;</span><br><span class="line">    private String buidA;</span><br><span class="line">    private String buidB;</span><br><span class="line">    private String buidC;</span><br><span class="line">    private String buidD;</span><br><span class="line"></span><br><span class="line">    public String getBuidA() &#123;</span><br><span class="line">        return buidA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuidA(String buidA) &#123;</span><br><span class="line">        this.buidA = buidA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBuidB() &#123;</span><br><span class="line">        return buidB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuidB(String buidB) &#123;</span><br><span class="line">        this.buidB = buidB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBuidC() &#123;</span><br><span class="line">        return buidC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuidC(String buidC) &#123;</span><br><span class="line">        this.buidC = buidC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBuidD() &#123;</span><br><span class="line">        return buidD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuidD(String buidD) &#123;</span><br><span class="line">        this.buidD = buidD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Product&#123;&quot; +</span><br><span class="line">                &quot;buidA=&#x27;&quot; + buidA + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, buidB=&#x27;&quot; + buidB + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, buidC=&#x27;&quot; + buidC + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, buidD=&#x27;&quot; + buidD + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//指挥：核心。负责构建一个工程，工程如何构建由他决定</span><br><span class="line">public class Director &#123;</span><br><span class="line">    //指挥工人按照顺序建房子</span><br><span class="line">    public Product build(Builder builder)&#123;</span><br><span class="line">        builder.buildA();</span><br><span class="line">        builder.buildB();</span><br><span class="line">        builder.buildC();</span><br><span class="line">        builder.buildC();</span><br><span class="line"></span><br><span class="line">        return builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //指挥</span><br><span class="line">        Director director  = new Director();</span><br><span class="line">        //指挥去指挥具体的工人去完成产品</span><br><span class="line">        Product build = director.build(new Worker());</span><br><span class="line">        System.out.println(build.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面示例是Builder模式的常规用法，导演类Director在Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。</li>
<li>通过静态内部类方式实现零件无序装配构造，这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品</li>
<li>比如:麦当劳的套餐，服务员（具体建造者）可以随意搭配任意几种产品(零件）组成一款套餐（产品)，然后出售给客户。比第一种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品的创建更加简单灵活。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//建造者</span><br><span class="line">public abstract class Builder &#123;</span><br><span class="line"></span><br><span class="line">    abstract Builder builderA(String msg);//汉堡</span><br><span class="line">    abstract Builder builderB(String msg);//可乐</span><br><span class="line">    abstract Builder builderC(String msg);//薯条</span><br><span class="line">    abstract Builder builderD(String msg);//甜点</span><br><span class="line"></span><br><span class="line">    abstract Product getProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package Buider.demo2;</span><br><span class="line"></span><br><span class="line">//产品：套餐</span><br><span class="line">public class Product &#123;</span><br><span class="line"></span><br><span class="line">    private String BuildA = &quot;汉堡&quot;;</span><br><span class="line">    private String BuildB = &quot;可乐&quot;;</span><br><span class="line">    private String BuildC = &quot;薯条&quot;;</span><br><span class="line">    private String BuildD = &quot;甜点&quot;;</span><br><span class="line"></span><br><span class="line">    public String getBuildA() &#123;</span><br><span class="line">        return BuildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuildA(String buildA) &#123;</span><br><span class="line">        BuildA = buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBuildB() &#123;</span><br><span class="line">        return BuildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuildB(String buildB) &#123;</span><br><span class="line">        BuildB = buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBuildC() &#123;</span><br><span class="line">        return BuildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuildC(String buildC) &#123;</span><br><span class="line">        BuildC = buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBuildD() &#123;</span><br><span class="line">        return BuildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBuildD(String buildD) &#123;</span><br><span class="line">        BuildD = buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Product&#123;&quot; +</span><br><span class="line">                &quot;BuildA=&#x27;&quot; + BuildA + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, BuildB=&#x27;&quot; + BuildB + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, BuildC=&#x27;&quot; + BuildC + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, BuildD=&#x27;&quot; + BuildD + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package Buider.demo2;</span><br><span class="line">//具体的建造者</span><br><span class="line">public class Worker extends Builder&#123;</span><br><span class="line"></span><br><span class="line">    public Product product;</span><br><span class="line">    public Worker()&#123;</span><br><span class="line">        product = new Product();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Builder builderA(String msg) &#123;</span><br><span class="line">        product.setBuildA(msg);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Builder builderB(String msg) &#123;</span><br><span class="line">        product.setBuildB(msg);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Builder builderC(String msg) &#123;</span><br><span class="line">        product.setBuildC(msg);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Builder builderD(String msg) &#123;</span><br><span class="line">        product.setBuildD(msg);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product getProduct() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package Buider.demo2;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //服务员</span><br><span class="line">        Worker worker = new Worker();</span><br><span class="line">        //默认</span><br><span class="line">        Product product = worker.getProduct();</span><br><span class="line">        System.out.println(product.toString());</span><br><span class="line">        //自由组合</span><br><span class="line">        Product product2 = worker.builderA(&quot;全家桶&quot;).builderB(&quot;雪碧&quot;)</span><br><span class="line">                .getProduct();</span><br><span class="line"></span><br><span class="line">        System.out.println(product2.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点:</p>
<ul>
<li>产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>
<li>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰</li>
<li>具体的建造者类之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则“。</li>
</ul>
<p>缺点:</p>
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似;如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="cl0j84jxv00bz04vh8rj1ej1a" data-title="设计模式——建造者模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/concurrency/">concurrency</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/open-source/">open-source</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/" rel="tag">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E9%A1%B9%E7%9B%AE/" rel="tag">Java项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">MySql、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" rel="tag">Redis、面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Java/" rel="tag">Spring Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E3%80%81blog/" rel="tag">hexo、blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm-memory-management/" rel="tag">jvm-memory-management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty-source/" rel="tag">netty-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-intro/" rel="tag">spring-aop-intro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-source/" rel="tag">spring-aop-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="tag">循环依赖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/Java/" style="font-size: 15.56px;">Java</a> <a href="/tags/Java-JVM/" style="font-size: 18.89px;">Java JVM</a> <a href="/tags/Java-Spring/" style="font-size: 13.33px;">Java Spring</a> <a href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.78px;">Java、面试题</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">Java数据结构</a> <a href="/tags/Java%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">Java项目</a> <a href="/tags/MySql/" style="font-size: 20px;">MySql</a> <a href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.11px;">MySql、面试题</a> <a href="/tags/Redis/" style="font-size: 14.44px;">Redis</a> <a href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Redis、面试</a> <a href="/tags/Spring-Java/" style="font-size: 13.33px;">Spring Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/hexo%E3%80%81blog/" style="font-size: 10px;">hexo、blog</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm-memory-management/" style="font-size: 10px;">jvm-memory-management</a> <a href="/tags/netty-source/" style="font-size: 11.11px;">netty-source</a> <a href="/tags/redis/" style="font-size: 17.78px;">redis</a> <a href="/tags/spring-aop-intro/" style="font-size: 10px;">spring-aop-intro</a> <a href="/tags/spring-aop-source/" style="font-size: 10px;">spring-aop-source</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" style="font-size: 10px;">循环依赖</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/09/update%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97%EF%BC%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/Redis_hot/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM类加载机制</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Lee yunbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>