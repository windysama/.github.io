<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MyHomePage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="MyHomePage">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="MyHomePage">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lee yunbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MyHomePage" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MyHomePage</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Java中i++在并发开发中存在的问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/23/Java%E4%B8%ADi++%E5%9C%A8%E5%B9%B6%E5%8F%91%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-04-23T13:46:40.000Z" itemprop="datePublished">2021-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/23/Java%E4%B8%ADi++%E5%9C%A8%E5%B9%B6%E5%8F%91%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/">Java并发(1) i++的线程安全问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java并发-i-的线程安全问题"><a href="#Java并发-i-的线程安全问题" class="headerlink" title="Java并发 i++的线程安全问题"></a>Java并发 i++的线程安全问题</h1><h2 id="1-问题背景条件"><a href="#1-问题背景条件" class="headerlink" title="1. 问题背景条件"></a>1. 问题背景条件</h2><p>多线程操作同一变量<br>此处不可能是局部变量，肯定是成员变量或静态变量<br>PS：为什么不可能是局部变量？<br>需要多线程访问局部变量，那么多个线程就必须在方法中进行定义，如使用匿名内部类方式定义多个线程。<br>在使用匿名内部类引用局部变量时，局部变量必须通过final来修饰。这样做的原因是变量的生命周期问题。<br>final修饰的变量，不管是int还是Integer，都不能进行自加操作。</p>
<h2 id="2-引起线程安全问题的原因"><a href="#2-引起线程安全问题的原因" class="headerlink" title="2. 引起线程安全问题的原因"></a>2. 引起线程安全问题的原因</h2><p>内存可见性<br>i++操作过程</p>
<h2 id="3-内存可见性"><a href="#3-内存可见性" class="headerlink" title="3. 内存可见性"></a>3. 内存可见性</h2><p>Java内存模型<br>在A线程执行i++结束后，如果没有及时把缓存中的结果刷新到主内存，B线程就开始执行i++操作，那么结果就会出错。</p>
<p>在多并发条件下i++不是线程安全的, 主要原因是i++并非原子操作, 其底层可以分为1.获取变量的值2. 将值进行加一3.将值赋给变量三个步骤; 因此多线程条件下会由于 重复赋值等问题造成结果有误.</p>
<p>解决方案：使用volatile关键字修饰。但volatile解决的是多线程间共享变量的可见性问题，而保证不了多线程间共享变量原子性问题。对于多线程的i++,++i,依然还是会存在多线程问题,volatile是无法解决的</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>1、 使用循环CAS，实现i++原子操作</strong></p>
<p><strong>2、使用锁机制，实现i++原子操作</strong></p>
<p><strong>3、使用synchronized，实现i++原子操作</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/23/Java%E4%B8%ADi++%E5%9C%A8%E5%B9%B6%E5%8F%91%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="cl0j84jvk003j04vhbbsje10d" data-title="Java并发(1) i++的线程安全问题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL索引分类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/23/MySQL%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-23T13:45:43.000Z" itemprop="datePublished">2021-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/23/MySQL%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/">聚簇索引和非聚簇索引</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h1><h1 id="一、根据底层数据结构划分"><a href="#一、根据底层数据结构划分" class="headerlink" title="一、根据底层数据结构划分"></a><strong>一、根据底层数据结构划分</strong></h1><p>索引是提高查询效率的数据结构，而能够提高查询效率的数据结构有很多，如二叉搜索树，红黑树，跳表，哈希表（散列表）等，而MySQL中用到了B+Tree和散列表（Hash表）作为索引的底层数据结构(其实也用到了跳表实现全文索引，但这不是重要考点，所以可以忽略)。</p>
<h2 id="1-hash索引"><a href="#1-hash索引" class="headerlink" title="1. hash索引"></a><strong>1. hash索引</strong></h2><p>MySQL并没有显式支持Hash索引，而是作为内部的一种优化。具体在Innodb存储引擎里，会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，就为之建立hash索引。因此，在MySQL的Innodb里，对于热点的数据会自动生成Hash索引。这种hash索引，根据其使用的场景特点，也叫自适应Hash索引。</p>
<h2 id="2-B-树索引"><a href="#2-B-树索引" class="headerlink" title="2. B+树索引"></a><strong>2. B+树索引</strong></h2><p>这个是MySQL索引的基本实现方式。除了全文索引、hash索引，Innodb、MyISAM的索引都是通过B+树实现的。</p>
<h1 id="二、根据索引字段个数划分"><a href="#二、根据索引字段个数划分" class="headerlink" title="二、根据索引字段个数划分"></a><strong>二、根据索引字段个数划分</strong></h1><p>为了能应对不同的数据检索需求，索引既可以仅包含一个字段，也可以同时包含多个字段。单个字段组成的索引可以称为<strong>单值索引</strong>，否则称之为复合索引，也称为<strong>组合索引</strong>或多值索引。</p>
<p>这个很好理解，假如我们有一张表，有三个属性，分别是 id，age 和 name 。假如在id上建立索引，那这就是单值索引；如果在 name 和 age 上建立索引，那这就是复合索引。</p>
<p>复合索引的索引的数据顺序跟字段的顺序相关，包含多个值的索引中，如果当前面字段的值重复时，将会按照其后面的值进行排序。</p>
<p>使用覆盖索引的前提是字段长度比较短，对于值长度较长的字段则不适合使用覆盖索引，原因有很多，比如索引一般存储在内存中，如果占用空间较大，则可能会从磁盘中加载，影响性能。</p>
<h1 id="三、根据是否是在主键上建立的索引进行划分"><a href="#三、根据是否是在主键上建立的索引进行划分" class="headerlink" title="三、根据是否是在主键上建立的索引进行划分"></a><strong>三、根据是否是在主键上建立的索引进行划分</strong></h1><h2 id="1-主键索引"><a href="#1-主键索引" class="headerlink" title="1. 主键索引"></a><strong>1. 主键索引</strong></h2><p>MySQL中是根据主键来组织数据的，所以每张表都必须有主键索引，主键索引只能有一个，不能为null同时必须保证唯一性。建表时如果没有指定主键索引，则会自动生成一个隐藏的字段作为主键索引。</p>
<h2 id="2-辅助索引"><a href="#2-辅助索引" class="headerlink" title="2. 辅助索引"></a><strong>2. 辅助索引</strong></h2><p>如果不是主键索引，则就可以称之为非主键索引，又可以称之为辅助索引或者二级索引。主键索引的叶子节点存储了完整的数据行，而非主键索引的叶子节点存储的则是主键索引值，通过非主键索引查询数据时，会先查找到主键索引，然后再到主键索引上去查找对应的数据。</p>
<p>在这里假设我们有张表user，具有三列：ID，age，name，create_time，id是主键，（age，create_time,，name）建立辅助索引。执行如下sql语句：</p>
<p>select name from user where age&gt;2 order by create_time desc。</p>
<p>正常的话，查询分两步：</p>
<p>1.按照辅助索引，查找到记录的主键，</p>
<p>2.按照主键主键索引里查找记录，返回name。</p>
<p>但实际上，我们可以看到，辅助索引节点是按照age，create_time，name建立的，索引信息里完全包含我们所要的信息，如果能从辅助索引里返回name信息，则第二步是完全没有必要的，可以极大提升查询速度。</p>
<p>按照这种思想Innodb里针对使用辅助索引的查询场景做了优化，叫覆盖索引（在这里小声吐槽一下，不知道业界起这种名词干嘛，太容易引起歧义了，叫个索引覆盖查询不是更好吗）。</p>
<h1 id="四、根据数据与索引的存储关联性划分"><a href="#四、根据数据与索引的存储关联性划分" class="headerlink" title="四、根据数据与索引的存储关联性划分"></a><strong>四、根据数据与索引的存储关联性划分</strong></h1><p>根据数据与索引的存储关联性，可以分为聚簇索引和非聚簇索引（也叫聚集索引和非聚集索引）。聚簇索引也叫簇类索引，是一种对磁盘上实际数据重新组织以按指定的一个或多个列的值排序。整个简洁的说法，这俩的<strong>区别就是索引的存储顺序和数据的存储顺序是否是关系的，有关就是聚簇索引，无关就是非聚簇索引</strong>。具体实现方式根据索引的数据结构不同会有所不同。下面以B+树实现的索引为例，举例来说明聚簇索引和非聚簇索引。</p>
<h2 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a><strong>1. 聚簇索引</strong></h2><p>Innodb的主键索引，非叶子节点存储的是索引指针，叶子节点存储的是既有索引也有数据，是典型的聚簇索引（这里可以发现，索引和数据的存储顺序是强相关的。因此是典型的聚簇索引），如图：</p>
<h2 id="2-非聚簇索引"><a href="#2-非聚簇索引" class="headerlink" title="2. 非聚簇索引"></a><strong>2. 非聚簇索引</strong></h2><p>MyISAM中索引和数据文件分开存储，B+Tree的叶子节点存储的是数据存放的地址，而不是具体的数据，是典型的非聚簇索引；换言之，数据可以在磁盘上随便找地方存，索引也可以在磁盘上随便找地方存，只要叶子节点记录对了数据存放地址就行。因此，索引存储顺序和数据存储关系毫无关联，是典型的非聚簇索引，另外Inndob里的辅助索引也是非聚簇索引</p>
<h1 id="五、其他分类"><a href="#五、其他分类" class="headerlink" title="五、其他分类"></a><strong>五、其他分类</strong></h1><h2 id="1-唯一索引"><a href="#1-唯一索引" class="headerlink" title="1. 唯一索引"></a><strong>1. 唯一索引</strong></h2><p>顾名思义，不允许具有索引值相同的行，从而禁止重复的索引或键值。系统在创建该索引时检查是否有重复的键值，并在每次使用 INSERT 或 UPDATE 语句添加数据时进行检查， 如果有重复的值，则会操作失败，抛出异常。</p>
<p>需要注意的是，主键索引一定是唯一索引，而唯一索引不一定是主键索引。唯一索引可以理解为仅仅是将索引设置一个唯一性的属性。</p>
<h2 id="2-全文索引"><a href="#2-全文索引" class="headerlink" title="2. 全文索引"></a><strong>2. 全文索引</strong></h2><p>在MySQL 5.6版本以前,只有MyISAM存储引擎支持全文引擎。在5.6版本中,InnoDB加入了对全文索引的支持,但是不支持中文全文索引.在5.7.6版本,MySQL内置了ngram全文解析器,用来支持亚洲语种的分词。主要用来利用关键词查询文本，不是MySQL的主要面向场景，使用较少，这里就不展开讨论了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/23/MySQL%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/" data-id="cl0j84jvv004m04vhccse6zgb" data-title="聚簇索引和非聚簇索引" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JVM对象分配规则" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/23/JVM%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99/" class="article-date">
  <time class="dt-published" datetime="2021-04-23T12:12:20.000Z" itemprop="datePublished">2021-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/23/JVM%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99/">对象分配规则</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="对象分配规则"><a href="#对象分配规则" class="headerlink" title="对象分配规则"></a>对象分配规则</h1><p>1.对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p>
<p>2.大对象直接进入老年代(大对象是指需要大量连续内存空间的对象)。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存)。</p>
<p>3.长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p>
<p>4.动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
<p>5.空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/23/JVM%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99/" data-id="cl0j84jvd002o04vhh989ara3" data-title="对象分配规则" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JVM的JMM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/23/JVM%E7%9A%84JMM/" class="article-date">
  <time class="dt-published" datetime="2021-04-23T12:12:20.000Z" itemprop="datePublished">2021-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/23/JVM%E7%9A%84JMM/">Java内存模型（JMM）总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java内存模型（JMM）总结"><a href="#Java内存模型（JMM）总结" class="headerlink" title="Java内存模型（JMM）总结"></a>Java内存模型（JMM）总结</h1><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a><strong>Java内存模型（JMM）</strong></h2><p>我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。</p>
<p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍然在使用。</p>
<p>Java内存模型（不仅仅是JVM内存分区）：调用栈和本地变量存放在线程栈上，对象存放在堆上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-bd607bd9a5598a8330ad329033e04b91_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-a1a75c9f7264cf78d0927663371ca9d2_720w.jpg" alt="img"></p>
<ul>
<li>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</li>
<li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li>
<li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li>
<li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li>
<li>静态成员变量跟随着类定义一起也存放在堆上。</li>
<li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/23/JVM%E7%9A%84JMM/" data-id="cl0j84jve002v04vh3cn2g827" data-title="Java内存模型（JMM）总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java中Synchronized底层原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/23/Java%E4%B8%ADSynchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-23T12:12:20.000Z" itemprop="datePublished">2021-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/23/Java%E4%B8%ADSynchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">Synchronized底层原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、synchronized-使用"><a href="#一、synchronized-使用" class="headerlink" title="一、synchronized 使用"></a>一、synchronized 使用</h1><h2 id="1、synchronized的作用"><a href="#1、synchronized的作用" class="headerlink" title="1、synchronized的作用"></a>1、synchronized的作用</h2><p><code>synchronized</code> 的作用主要有三：</p>
<ul>
<li>（1）、<strong>原子性</strong>：<strong>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong>被<code>synchronized</code>修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放。</li>
<li>（2）、<strong>可见性</strong>：**可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。 **synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。</li>
<li>（3）、<strong>有序性</strong>：<strong>有序性值程序执行的顺序按照代码先后执行。</strong> synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</li>
</ul>
<h2 id="2、synchronized的使用"><a href="#2、synchronized的使用" class="headerlink" title="2、synchronized的使用"></a>2、synchronized的使用</h2><p><strong>Synchronized主要有三种用法</strong>：</p>
<ul>
<li><p>（1）、<strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>（2）、<strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ <strong>static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份</strong>）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>（3）、<strong>修饰代码块</strong> ：指定加锁对象，对给定对象&#x2F;类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单总结一下</strong>：</p>
<p><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</p>
<p><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</p>
<p>接下来看一个 synchronized 使用经典实例—— 线程安全的单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//保证有序性，防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、synchronized同步原理"><a href="#二、synchronized同步原理" class="headerlink" title="二、synchronized同步原理"></a>二、synchronized同步原理</h1><p>数据同步需要依赖锁，那锁的同步又依赖谁？<strong>synchronized给出的答案是在软件层面依赖JVM，而j.u.c.Lock给出的答案是在硬件层面依赖特殊的CPU指令。</strong></p>
<h2 id="1、synchronized-同步语句块原理"><a href="#1、synchronized-同步语句块原理" class="headerlink" title="1、synchronized 同步语句块原理"></a>1、synchronized 同步语句块原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>
<p><img src="/1.png" alt="1"></p>
<p><img src="E:\MyBolg\source_posts\Synchronized底层原理\1.png" alt="1"></p>
<p>从图中可以看出：</p>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指明同步代码块的结束位置。**</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，**<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。**</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h2 id="2、synchronized-修饰方法原理"><a href="#2、synchronized-修饰方法原理" class="headerlink" title="2、synchronized 修饰方法原理"></a>2、synchronized 修饰方法原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译一下：</p>
<p><img src="/2.png" alt="2"></p>
<p><img src="E:\MyBolg\source_posts\Synchronized底层原理\2.png" alt="2"></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p><strong>简单总结一下</strong>：</p>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<h1 id="三、synchronized同步概念"><a href="#三、synchronized同步概念" class="headerlink" title="三、synchronized同步概念"></a>三、synchronized同步概念</h1><h2 id="1、Java对象头"><a href="#1、Java对象头" class="headerlink" title="1、Java对象头"></a>1、Java对象头</h2><p>在JVM中，对象在内存中的布局分为三块区域：<strong>对象头、实例数据和对齐填充</strong>。</p>
<p><img src="/3.png" alt="3"></p>
<p><img src="E:\MyBolg\source_posts\Synchronized底层原理\3.png" alt="3"></p>
<p><code>synchronized</code>用的锁是存在Java对象头里的。</p>
<p>Hotspot 有两种对象头：</p>
<ul>
<li>数组类型，如果对象是数组类型，则虚拟机用3个字宽 （Word）存储对象头</li>
<li>非数组类型：如果对象是非数组类型，则用2字宽存储对象头。</li>
</ul>
<p>对象头由两部分组成</p>
<ul>
<li>Mark Word：存储自身的运行时数据，例如 HashCode、GC 年龄、锁相关信息等内容。</li>
<li>Klass Pointer：类型指针指向它的类元数据的指针。</li>
</ul>
<p>64 位虚拟机 Mark Word 是 64bit，在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化</p>
<p><img src="/4.png" alt="4"></p>
<p><img src="E:\MyBolg\source_posts\Synchronized底层原理\4.png" alt="4"></p>
<h2 id="2、监视器（Monitor）"><a href="#2、监视器（Monitor）" class="headerlink" title="2、监视器（Monitor）"></a>2、监视器（Monitor）</h2><p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<ol>
<li><strong>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</strong></li>
<li><strong>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</strong></li>
</ol>
<p>那什么是Monitor？可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。</p>
<p>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，<strong>每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁</strong>。</p>
<p>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的。</p>
<h1 id="四、synchronized优化"><a href="#四、synchronized优化" class="headerlink" title="四、synchronized优化"></a>四、synchronized优化</h1><p>从JDK5引入了现代操作系统新增加的CAS原子操作（ <strong>JDK5中并没有对synchronized关键字做优化，而是体现在J.U.C中，所以在该版本concurrent包有更好的性能</strong> ），从JDK6开始，就对synchronized的实现机制进行了较大调整，<strong>包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略</strong>。由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。</p>
<p>锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。<strong>但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级</strong>。</p>
<p><img src="/lock.png" alt="lock"></p>
<p><img src="E:\MyBolg\source_posts\Synchronized底层原理\lock.png" alt="lock"></p>
<h2 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h2><p>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，<strong>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p>
<p>如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p>
<p>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着， 如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<p>下图中的线 程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程</p>
<p><img src="/5.png" alt="5"></p>
<p><strong><img src="E:\MyBolg\source_posts\Synchronized底层原理\5.png" alt="5"></strong></p>
<h2 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h2><p>引入轻量级锁的主要目的是 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p>
<p><strong>（1）轻量级锁加锁</strong></p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p><strong>（2）轻量级锁解锁</strong></p>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成 功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
<p>下图是 两个线程同时争夺锁，导致锁膨胀的流程图：</p>
<p><img src="/6.png" alt="6"></p>
<p><img src="E:\MyBolg\source_posts\Synchronized底层原理\6.png" alt="6"></p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h2 id="3、锁的优缺点比较"><a href="#3、锁的优缺点比较" class="headerlink" title="3、锁的优缺点比较"></a>3、锁的优缺点比较</h2><p>各种锁并不是相互代替的，<strong>而是在不同场景下的不同选择</strong>，绝对不是说重量级锁就是不合适的。<strong>每种锁是只能升级，不能降级，即由偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>，而这个过程就是开销逐渐加大的过程。</p>
<blockquote>
<p><strong>如果是单线程使用，那偏向锁毫无疑问代价最小</strong>，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较下对象头就可以了；</p>
<p><strong>如果出现了其他线程竞争</strong>，则偏向锁就会升级为轻量级锁；</p>
<p><strong>如果其他线程通过一定次数的CAS尝试没有成功</strong>，则进入重量级锁；</p>
</blockquote>
<p>锁的优缺点的对比如下表：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法仅有纳米级的差距</td>
<td>如果线程间存在锁的竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问的同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的相应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间 同步响应非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量 同步块执行速度较长</td>
</tr>
</tbody></table>
<p>原文连接<a target="_blank" rel="noopener" href="https://www.cnblogs.com/three-fighter/p/14396208.html">https://www.cnblogs.com/three-fighter/p/14396208.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/23/Java%E4%B8%ADSynchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" data-id="cl0j84jvl003m04vh5ky8dg5g" data-title="Synchronized底层原理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试必考题B+索引比B索引好在哪？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98B+%E7%B4%A2%E5%BC%95%E6%AF%94B%E7%B4%A2%E5%BC%95%E5%A5%BD%E5%9C%A8%E5%93%AA%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T16:00:00.000Z" itemprop="datePublished">2021-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98B+%E7%B4%A2%E5%BC%95%E6%AF%94B%E7%B4%A2%E5%BC%95%E5%A5%BD%E5%9C%A8%E5%93%AA%EF%BC%9F/">B+树相比B树的优势</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="B-树相比B树的优势"><a href="#B-树相比B树的优势" class="headerlink" title="B+树相比B树的优势"></a>B+树相比B树的优势</h1><p>B+树的优势在于查找效率上，具体说明：<br>　　首先，Ｂ＋树的查找和Ｂ树一样，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。</p>
<p>　　（1）不同的是，Ｂ＋树中间节点没有卫星数据（索引元素所指向的数据记录），只有索引，而Ｂ树每个结点中的每个关键字都有卫星数据；这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，Ｂ＋树更加“矮胖”，ＩＯ操作更少</p>
<p>　　（2）、其次，因为卫星数据的不同，导致查询过程也不同；Ｂ树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而Ｂ＋树每次必须查找到叶子结点，性能稳定</p>
<p>　　（3）在范围查询方面，B+树的优势更加明显，B树的范围查找需要不断依赖中序遍历。首先二分查找到范围下限，在不断通过中序遍历，知道查找到范围的上限即可。整个过程比较耗时。而B+树的范围查找则简单了许多。首先通过二分查找，找到范围下限，然后同过叶子结点的链表顺序遍历，直至找到上限即可，整个过程简单许多，效率也比较高。</p>
<p><strong>B+树相比B树的优势：</strong><br>　　1.单一节点存储更多的元素，使得查询的IO次数更少；<br>　　2.所有查询都要查找到叶子节点，查询性能稳定；<br>　　3.所有叶子节点形成有序链表，便于范围查询。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98B+%E7%B4%A2%E5%BC%95%E6%AF%94B%E7%B4%A2%E5%BC%95%E5%A5%BD%E5%9C%A8%E5%93%AA%EF%BC%9F/" data-id="cl0j84jxw00c404vh3kvhcu1w" data-title="B+树相比B树的优势" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试必考题HashMap为什么指定为2的幂次" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%87%E5%AE%9A%E4%B8%BA2%E7%9A%84%E5%B9%82%E6%AC%A1/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T16:00:00.000Z" itemprop="datePublished">2021-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%87%E5%AE%9A%E4%B8%BA2%E7%9A%84%E5%B9%82%E6%AC%A1/">面试必考题HashMap为什么指定为2的幂次</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="hashmap的大小为什么指定为2的幂次"><a href="#hashmap的大小为什么指定为2的幂次" class="headerlink" title="hashmap的大小为什么指定为2的幂次"></a>hashmap的大小为什么指定为2的幂次</h1><p>JDK8中HashMap的大小默认初始值，以及后面的扩容操作，都指定，大小必须是2的幂次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">*</span><br><span class="line">* The <span class="keyword">default</span> initial capacity - MUST be a power of two.</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt;<span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tablesizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">	n |=n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    n |=n &gt;&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt;<span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt;<span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n&lt;<span class="number">0</span>) ? <span class="number">1</span> :(n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY :n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以为什么呢？</p>
<p>HashMap中指定哈希桶数组大小为2的幂次，主要是在两方面进行优化：</p>
<p>1，扩容：大小指定为2的幂次，当哈希桶扩大2倍时，只需要进行左移操作，众所周知，位操作的速度还是超快的</p>
<p><img src="/%E6%89%A9%E5%AE%B9.png" alt="扩容"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap为什么指定为2的幂次\扩容.png" alt="扩容"></p>
<p>2，Hash算法的均匀分布，减少哈希碰撞几率：16或者其他2的幂，Length-1的值是后面的二进制位全为1，例如16-1&#x3D;15二进制1111，32-1&#x3D;31二进制11111，这种情况下，index &#x3D; key值HashCode&amp;（length-1），index的结果等同于key值的HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>
<p><img src="/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83.png" alt="均匀分布"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap为什么指定为2的幂次\均匀分布.png" alt="均匀分布"></p>
<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012898245/article/details/91039215">https://blog.csdn.net/u012898245/article/details/91039215</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%87%E5%AE%9A%E4%B8%BA2%E7%9A%84%E5%B9%82%E6%AC%A1/" data-id="cl0j84jxx00c504vh6yx24f30" data-title="面试必考题HashMap为什么指定为2的幂次" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试必考题HashMap什么时候触发扩容" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E6%89%A9%E5%AE%B9/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T16:00:00.000Z" itemprop="datePublished">2021-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E6%89%A9%E5%AE%B9/">面试必考题HashMap什么时候触发扩容</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HashMap-什么时候进行扩容呢"><a href="#HashMap-什么时候进行扩容呢" class="headerlink" title="HashMap 什么时候进行扩容呢"></a>HashMap 什么时候进行扩容呢</h1><p>HashMap扩容:</p>
<p>当HashMap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>　　那么HashMap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16 x 0.75&#x3D;12的时候，就把数组的大小扩展为2 * 16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p>
<p>原文连接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/miaosj/p/11088613.html">https://www.cnblogs.com/miaosj/p/11088613.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E6%89%A9%E5%AE%B9/" data-id="cl0j84jxx00c704vhdtjs64vx" data-title="面试必考题HashMap什么时候触发扩容" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试必考题HashMap在1.7和1.8中怎么扩容？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E5%9C%A81.7%E5%92%8C1.8%E4%B8%AD%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T16:00:00.000Z" itemprop="datePublished">2021-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E5%9C%A81.7%E5%92%8C1.8%E4%B8%AD%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%EF%BC%9F/">HashMap在1.7和1.8中怎么扩容？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Hashmap的结构，1-7和1-8有哪些区别？"><a href="#Hashmap的结构，1-7和1-8有哪些区别？" class="headerlink" title="Hashmap的结构，1.7和1.8有哪些区别？"></a>Hashmap的结构，1.7和1.8有哪些区别？</h1><h2 id="（一）-真实面试题之：Hashmap的结构，1-7和1-8有哪些区别"><a href="#（一）-真实面试题之：Hashmap的结构，1-7和1-8有哪些区别" class="headerlink" title="（一） 真实面试题之：Hashmap的结构，1.7和1.8有哪些区别"></a>（一） 真实面试题之：Hashmap的结构，1.7和1.8有哪些区别</h2><p>不同点：</p>
<p>（1）JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</p>
<p>（2）扩容后数据存储位置的计算方式也不一样：</p>
<ol>
<li>在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;按位与（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1）</li>
<li>而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值&#x3D;JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式</li>
</ol>
<p><img src="/%E6%89%A9%E5%AE%B9.png" alt="扩容"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap在1.7和1.8中怎么扩容？\扩容.png" alt="扩容"></p>
<p>在计算hash值的时候，JDK1.7用了9次扰动处理&#x3D;4次位运算+5次异或，而JDK1.8只用了2次扰动处理&#x3D;1次位运算+1次异或。</p>
<p><strong>扩容流程对比图：</strong></p>
<p><img src="/%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="扩容流程对比图"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap在1.7和1.8中怎么扩容？\扩容流程对比图.png" alt="扩容流程对比图"></p>
<p><strong>（3）JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率）</strong></p>
<p><img src="/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap在1.7和1.8中怎么扩容？\流程图.png" alt="流程图"></p>
<p>**这里在重新进行补充两个问题：</p>
<p><strong>（1）为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实就是当这个Map中实际插入的键值对的值的大小如果大于这个默认的阈值的时候（初始是16*0.75=12）的时候才会触发扩容，</span></span><br><span class="line"><span class="comment">//这个是在JDK1.8中的先插入后扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br></pre></td></tr></table></figure>

<p>其实这个问题也是JDK8对HashMap中，主要是因为对链表转为红黑树进行的优化，因为你插入这个节点的时候有可能是普通链表节点，也有可能是红黑树节点，但是为什么1.8之后HashMap变为先插入后扩容的原因，我也有点不是很理解？欢迎来讨论这个问题？</p>
<p>但是在JDK1.7中的话，是先进行扩容后进行插入的，就是当你发现你插入的桶是不是为空，如果不为空说明存在值就发生了hash冲突，那么就必须得扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容，但是当如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一次无用扩容，也减少了内存的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">		<span class="comment">//这里当钱数组如果大于等于12（假如）阈值的话，并且当前的数组的Entry数组还不能为空的时候就扩容</span></span><br><span class="line">    　　<span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　 <span class="comment">//扩容数组，比较耗时</span></span><br><span class="line">       　　 resize(<span class="number">2</span> * table.length);</span><br><span class="line">        　　hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    　　&#125;</span><br><span class="line"></span><br><span class="line">    　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    　　Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">　　　　<span class="comment">//把新加的放在原先在的前面，原先的是e，现在的是new，next指向e</span></span><br><span class="line">   　　 table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);<span class="comment">//假设现在是new</span></span><br><span class="line">    　　size++;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢（面试蘑菇街问过）？</p>
<p>如果选择6和8（如果链表小于等于6树还原转为链表，大于等于8转为树），中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。<br>还有一点重要的就是由于treenodes的大小大约是常规节点的两倍，因此我们仅在容器包含足够的节点以保证使用时才使用它们，当它们变得太小（由于移除或调整大小）时，它们会被转换回普通的node节点，容器中节点分布在hash桶中的频率遵循泊松分布，桶的长度超过8的概率非常非常小。所以作者应该是根据概率统计而选择了8作为阀值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java中解释的原因</span></span><br><span class="line">  * Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">    * use them only when bins contain enough nodes to warrant use</span><br><span class="line">    * (see TREEIFY_THRESHOLD). And when they become too <span class="title function_">small</span> <span class="params">(due to</span></span><br><span class="line"><span class="params">    * removal or resizing)</span> they are converted back to plain bins.  In</span><br><span class="line">    * usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">    * rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">    * nodes in bins follows a Poisson distribution</span><br><span class="line">    * (http:<span class="comment">//en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line">    * parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span><br><span class="line">    * threshold of <span class="number">0.75</span>, although with a large variance because of</span><br><span class="line">    * resizing granularity. Ignoring variance, the expected</span><br><span class="line">    * occurrences of list size k <span class="title function_">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * pow(<span class="number">0.5</span>, k) /</span><br><span class="line">    * factorial(k)). The first values are:</span><br><span class="line">    *</span><br><span class="line">    * <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">    * <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">    * <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">    * <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">    * <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">    * <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">    * <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">    * <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">    * <span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">    * more: less than <span class="number">1</span> in ten million</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="（二）哈希表如何解决Hash冲突？"><a href="#（二）哈希表如何解决Hash冲突？" class="headerlink" title="（二）哈希表如何解决Hash冲突？"></a>（二）哈希表如何解决Hash冲突？</h2><p><img src="/hash%E5%86%B2%E7%AA%81.png" alt="hash冲突"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap在1.7和1.8中怎么扩容？\hash冲突.png" alt="hash冲突"></p>
<h2 id="（三）为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化"><a href="#（三）为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化" class="headerlink" title="（三）为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化"></a>（三）为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化</h2><p><img src="/hashmap%E7%89%B9%E7%82%B9.jpg" alt="hashmap特点"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap在1.7和1.8中怎么扩容？\hashmap特点.jpg" alt="hashmap特点"></p>
<h2 id="（四）为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键"><a href="#（四）为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键" class="headerlink" title="（四）为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键"></a>（四）为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键</h2><p><img src="/%E5%8C%85%E8%A3%85%E7%B1%BB.png" alt="包装类"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap在1.7和1.8中怎么扩容？\包装类.png" alt="包装类"></p>
<h2 id="（五）HashMap-中的-key若-Object类型，-则需实现哪些方法？"><a href="#（五）HashMap-中的-key若-Object类型，-则需实现哪些方法？" class="headerlink" title="（五）HashMap 中的 key若 Object类型， 则需实现哪些方法？"></a>（五）HashMap 中的 key若 Object类型， 则需实现哪些方法？</h2><p><img src="/object%E7%B1%BB%E5%9E%8B.png" alt="object类型"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题HashMap在1.7和1.8中怎么扩容？\object类型.png" alt="object类型"></p>
<p>原文连接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36520235/article/details/82417949">https://blog.csdn.net/qq_36520235/article/details/82417949</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98HashMap%E5%9C%A81.7%E5%92%8C1.8%E4%B8%AD%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%EF%BC%9F/" data-id="cl0j84jxy00c904vh74d62p2v" data-title="HashMap在1.7和1.8中怎么扩容？" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">MySql、面试题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试必考题LRU和LFU" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98LRU%E5%92%8CLFU/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T16:00:00.000Z" itemprop="datePublished">2021-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98LRU%E5%92%8CLFU/">面试必考题LRU和LFU</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="缓存淘汰机制实现-LRU-LFU"><a href="#缓存淘汰机制实现-LRU-LFU" class="headerlink" title="缓存淘汰机制实现-LRU-LFU"></a>缓存淘汰机制实现-LRU-LFU</h1><h2 id="（1）缓存是什么"><a href="#（1）缓存是什么" class="headerlink" title="（1）缓存是什么"></a>（1）缓存是什么</h2><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p>
<h2 id="（2）为什么需要缓存"><a href="#（2）为什么需要缓存" class="headerlink" title="（2）为什么需要缓存"></a>（2）为什么需要缓存</h2><p>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(cacheline)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。</p>
<p>对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。</p>
<p>Cache Line 是 Cache 与 DRAM 同步的最小单位. 典型的虚拟内存页面大小为 4KB,而典型的 Cache line 通常的大小为 32 或 64 字节</p>
<h2 id="（3）缓存淘汰策略分类"><a href="#（3）缓存淘汰策略分类" class="headerlink" title="（3）缓存淘汰策略分类"></a>（3）缓存淘汰策略分类</h2><p>缓存的大小是有限的，当缓存被用满时，性需要进行数据清理。哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。</p>
<h4 id="3-1）先进先出策略FIFO（First-In，First-Out）"><a href="#3-1）先进先出策略FIFO（First-In，First-Out）" class="headerlink" title="3.1）先进先出策略FIFO（First In，First Out）"></a>3.1）先进先出策略FIFO（First In，First Out）</h4><p>思路：如果一个护具最先进入缓存中，则应该最早淘汰掉。<br>实现思路：</p>
<h4 id="3-2）最近最少频率使用策略（最不经常使用）LFU（Least-Frenquently-Used）"><a href="#3-2）最近最少频率使用策略（最不经常使用）LFU（Least-Frenquently-Used）" class="headerlink" title="3.2）最近最少频率使用策略（最不经常使用）LFU（Least Frenquently Used）"></a>3.2）最近最少频率使用策略（最不经常使用）LFU（Least Frenquently Used）</h4><p><strong>思想：最不经常使用策略,在一段时间内,数据被使用频次最少的,优先被淘汰。最少使用（LFU）是一种用于管理计算机内存的缓存算法。主要是记录和追踪内存块的使用次数,当缓存已满并且需要更多空间时，系统将以最低内存块使用频率清除内存.采用LFU算法的最简单方法是为每个加载到缓存的块分配一个计数器。每次引用该块时，计数器将增加一。当缓存达到容量并有一个新的内存块等待插入时，系统将搜索计数器最低的块并将其从缓存中删除；</strong></p>
<p><img src="/LRU.png" alt="LRU"></p>
<p><img src="E:\MyBolg\source_posts\面试必考题LRU和LFU\LRU.png" alt="LRU"></p>
<h4 id="3-3）最近最久未使用策略LRU（Least-Recently-Used）"><a href="#3-3）最近最久未使用策略LRU（Least-Recently-Used）" class="headerlink" title="3.3）最近最久未使用策略LRU（Least Recently Used）"></a>3.3）最近最久未使用策略LRU（Least Recently Used）</h4><p>LRU（The Least Recently Used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如Redis, Memcached）中都有广泛使用。</p>
<p>思想：LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。同样，如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98LRU%E5%92%8CLFU/" data-id="cl0j84jxy00cc04vh1xrh7idg" data-title="面试必考题LRU和LFU" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/concurrency/">concurrency</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/open-source/">open-source</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/" rel="tag">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E9%A1%B9%E7%9B%AE/" rel="tag">Java项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">MySql、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" rel="tag">Redis、面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Java/" rel="tag">Spring Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E3%80%81blog/" rel="tag">hexo、blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm-memory-management/" rel="tag">jvm-memory-management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty-source/" rel="tag">netty-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-intro/" rel="tag">spring-aop-intro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-source/" rel="tag">spring-aop-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="tag">循环依赖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/Java/" style="font-size: 15.56px;">Java</a> <a href="/tags/Java-JVM/" style="font-size: 18.89px;">Java JVM</a> <a href="/tags/Java-Spring/" style="font-size: 13.33px;">Java Spring</a> <a href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.78px;">Java、面试题</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">Java数据结构</a> <a href="/tags/Java%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">Java项目</a> <a href="/tags/MySql/" style="font-size: 20px;">MySql</a> <a href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.11px;">MySql、面试题</a> <a href="/tags/Redis/" style="font-size: 14.44px;">Redis</a> <a href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Redis、面试</a> <a href="/tags/Spring-Java/" style="font-size: 13.33px;">Spring Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/hexo%E3%80%81blog/" style="font-size: 10px;">hexo、blog</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm-memory-management/" style="font-size: 10px;">jvm-memory-management</a> <a href="/tags/netty-source/" style="font-size: 11.11px;">netty-source</a> <a href="/tags/redis/" style="font-size: 17.78px;">redis</a> <a href="/tags/spring-aop-intro/" style="font-size: 10px;">spring-aop-intro</a> <a href="/tags/spring-aop-source/" style="font-size: 10px;">spring-aop-source</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" style="font-size: 10px;">循环依赖</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/09/update%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97%EF%BC%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/Redis_hot/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM类加载机制</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Lee yunbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>