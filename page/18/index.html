<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MyHomePage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="MyHomePage">
<meta property="og:url" content="http://example.com/page/18/index.html">
<meta property="og:site_name" content="MyHomePage">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lee yunbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MyHomePage" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MyHomePage</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-12. 重写、重载" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/12.%20%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E8%BD%BD/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/12.%20%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E8%BD%BD/">12.重写、重载</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="12-重写、重载"><a href="#12-重写、重载" class="headerlink" title="12.重写、重载"></a>12.重写、重载</h1><h3 id="什么是重写？"><a href="#什么是重写？" class="headerlink" title="什么是重写？"></a>什么是重写？</h3><p>重写发生在父类和子类之间，方法名相同，参数列表相同，子类重写父类方法、比父类方法更好访问，不能比父类方法声明更多异常</p>
<h3 id="什么是方法重载？"><a href="#什么是方法重载？" class="headerlink" title="什么是方法重载？"></a>什么是方法重载？</h3><p>方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要他们的参数个数或者类型不同即可。在这种情况下，方法就被叫做重载 override</p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>都是实现多态的方式</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>重载Overload 实现编译时的多态性</p>
<p>重写Override 实现运行时多态</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/12.%20%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E8%BD%BD/" data-id="cl0j84jub000004vhgluz1cte" data-title="12.重写、重载" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10. Java实例化对象的几种方式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/10.%20Java%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/10.%20Java%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">10.Java实例化对象的几种方式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="10-Java实例化对象的几种方式"><a href="#10-Java实例化对象的几种方式" class="headerlink" title="10.Java实例化对象的几种方式"></a>10.Java实例化对象的几种方式</h1><h3 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h3><p>​        用new语句创建对象，这是最常见的创建对象的方法。 int[] a &#x3D; new int[n];</p>
<h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h3><p>​        通过工厂方法返回对象，如：String str &#x3D; String.valueOf(23); </p>
<h3 id="3-反射"><a href="#3-反射" class="headerlink" title="3. 反射"></a>3. 反射</h3><p>​        运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</p>
<p>​        如：Object obj  &#x3D; Class.forName(“java.lang.Object”).newInstance(); </p>
<h3 id="4-clone"><a href="#4-clone" class="headerlink" title="4. clone()"></a>4. clone()</h3><p>​        调用对象的clone()方法。从已有对象中克隆一个新的对象</p>
<h3 id="5-序列化"><a href="#5-序列化" class="headerlink" title="5. 序列化"></a>5. 序列化</h3><p>​        通过I&#x2F;O流（包括反序列化），如运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/10.%20Java%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" data-id="cl0j84juf000104vhhy8d94to" data-title="10.Java实例化对象的几种方式" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-1. JDK and JRE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/1.%20JDK%20and%20JRE/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/1.%20JDK%20and%20JRE/">1.JDK，JRE，JVM有什么区别？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-JDK，JRE，JVM有什么区别？"><a href="#1-JDK，JRE，JVM有什么区别？" class="headerlink" title="1.JDK，JRE，JVM有什么区别？"></a>1.JDK，JRE，JVM有什么区别？</h1><p><strong>JDK：</strong>Java Development Kit，Java开发工具包，提供了Java的开发环境和运行环境。包含了编译Java源文件的编译器Javac，还有调试和分析的工具。</p>
<p><strong>JRE</strong>：Java Runtime Environment，Java运行环境，包含Java虚拟机及一些基础类库</p>
<p><strong>JVM</strong>：Java Virtual Machine，Java虚拟机，提供执行字节码文件的能力所以，如果只是运行Java程序，只需要安装JRE即可。另外注意，JVM是实现Java跨平台的核心，但JVM本身并不是跨平台的，不同的平台需要安装不同的JVM</p>
<p><img src="/JVM.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/1.%20JDK%20and%20JRE/" data-id="cl0j84jui000404vh7xvibsqo" data-title="1.JDK，JRE，JVM有什么区别？" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-15. Java容器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/15.%20Java%E5%AE%B9%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/15.%20Java%E5%AE%B9%E5%99%A8/">15. Java容器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="15-Java容器"><a href="#15-Java容器" class="headerlink" title="15. Java容器"></a>15. Java容器</h1><p>java容器分Collection和Map两大类：</p>
<p><img src="/Collection%E5%92%8CMap.jpg"></p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="Set-不重复集合"><a href="#Set-不重复集合" class="headerlink" title="Set 不重复集合"></a>Set 不重复集合</h3><p>​              HashSet: 基于hash实现的不重复集合，<strong>无序</strong></p>
<p>​                      LinkListHashSet: 基于hash实现的不重复集合，<strong>有序</strong></p>
<p>​              SortedSet: 可排序不重复集合</p>
<p>​                      NavigableSet: 可导航搜索的不重复集合</p>
<p>​                      TreeSet: 基于红黑树实现的可排序不重复集合</p>
<h3 id="List-有序集合"><a href="#List-有序集合" class="headerlink" title="List 有序集合"></a>List 有序集合</h3><p>​              AbstractList: 有序集合的最小化抽象实现 </p>
<p>​              ArrayList: 基于数组实现的有序集合</p>
<p>​              LinkedList: 基于链表实现的有序集合</p>
<p>​              Vector: 矢量队列</p>
<p>​                       Stack: 栈，先进后出</p>
<h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h3><p>​              AbstractQueue: 队列的核心实现</p>
<p>​              BlockingQueue: 阻塞队列</p>
<p>​              Deque: 可两端操作线性集合</p>
<h2 id="Map-键值映射集合"><a href="#Map-键值映射集合" class="headerlink" title="Map 键值映射集合"></a>Map 键值映射集合</h2><p>​        AbstractMap: 键值映射集合最小化抽象实现    </p>
<p>​        Hashtable: 基于哈希表实现的键值映射集合，<strong>key、value均不可为null</strong> 线程安全，</p>
<p>​        HashMap: 类似Hashtable，但方法不同步，<strong>key、value可为null</strong> 非线程安全</p>
<p>​        推荐单线程环境下使用HashMap，多线程使用ConcurrentHashMap代替（不推荐使用hashtable）</p>
<p>​                LinkedHashMap: 根据插入顺序实现的键值映射集合</p>
<p>​        IdentityHashMap: 基于哈希表实现的键值映射集合，两个key引用相等&#x3D;&#x3D;，认为是同一个key</p>
<p>​        SortedMap:  可排序键值映射集合</p>
<p>​                NavigableMap: 可导航搜索的键值映射集合</p>
<p>​        WeakHashMap: 弱引用建，不阻塞被垃圾回收器回收，key回收后自动移除键值对</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/15.%20Java%E5%AE%B9%E5%99%A8/" data-id="cl0j84juj000504vhfgvxht6i" data-title="15. Java容器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-16. ArrayList和LinkedList" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/16.%20ArrayList%E5%92%8CLinkedList/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/16.%20ArrayList%E5%92%8CLinkedList/">16.谈谈ArrayList和LinkedList的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="16-谈谈ArrayList和LinkedList的区别"><a href="#16-谈谈ArrayList和LinkedList的区别" class="headerlink" title="16.谈谈ArrayList和LinkedList的区别"></a>16.谈谈ArrayList和LinkedList的区别</h1><p><strong>1，底层数据结构的差异</strong></p>
<p>​    ArrayList，数组，连续一块内存空间</p>
<p>​    LinkedList，双向链表，不是连续的内存空间</p>
<p><strong>2，一个常规的结论</strong></p>
<p><strong>虽然不严谨，但也可以应付很多面试了</strong></p>
<p>​        ArrayList，查找快，因为是连续的内存空间，方便寻址，但删除，插入慢，因为需要发生数据迁移</p>
<p>​        LinkedList，查找慢，因为需要通过指针一个个寻找，但删除，插入块，因为只要改变前后节点的指针指向即可。</p>
<p><strong>3，ArrayList细节分析</strong></p>
<p>1，增加</p>
<ul>
<li><p>添加到末尾，正常不需要做特别的处理，除非现有的数组空间不够了，需要扩容</p>
</li>
<li><ul>
<li><p>数组初始化容量多大？10，当你知道需要存储多少数据时，建议在创建的时候，直接设置初始化大小</p>
</li>
<li><p>怎么扩容？</p>
</li>
<li><ul>
<li><p>当发现容量不够之后，就进行扩容</p>
</li>
<li><p>按原先数组容量的1.5倍进行扩容，位运算，下面是关键的源码</p>
<p><code>int oldCapacity = elementData.length;</code><br> <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></p>
</li>
<li><p>再将原先数组的元素复制到新数组，Arrays</p>
<p><code>elementData = Arrays.copyOf(elementData, newCapacity)</code></p>
</li>
<li><p>添加到其他位置，这个时候需要做整体的搬迁</p>
<p>ArrayList</p>
<p>底层数组：连续的内存空间长度固定</p>
</li>
</ul>
</li>
<li><p>扩容方法：</p>
</li>
<li><p>1.创建一个新数组，新数组的长度是原数组的1.5倍位运算</p>
</li>
<li><p>2.将原数组的数据在迁移到新数组</p>
</li>
</ul>
</li>
</ul>
<p>2, 删除</p>
<ul>
<li><ul>
<li>删除末尾，并不需要迁移</li>
<li>删除其他的位置，这个时候也需要搬迁</li>
</ul>
</li>
</ul>
<p>3, 修改</p>
<ul>
<li><ul>
<li>修改之前，必须先定位</li>
<li>定位-查找-ArrayList（数组是一段连续的内存空间，定位会特别快）</li>
</ul>
</li>
</ul>
<p>4，查找</p>
<blockquote>
<p>​    ArrayList -&gt; a,c,b,d</p>
<p>​    LinkedList -&gt; a,c,b,d</p>
</blockquote>
<p>查找第二个元素</p>
<p>​    ArrayList连续的内存空间，可计算的偏移量</p>
<p>​    LinkedList不连续，无法计算，只能一个一个往下找</p>
<p>​    结论：ArrayList&gt;LinkedList</p>
<p>查找b在哪？</p>
<p>​    遍历 ，都只能一个个比较 速度相同</p>
<p><strong>4，LinkedList细节分析</strong></p>
<p>​    1，提供了的两个引用（first，last）</p>
<p>​    2，增加</p>
<p>​    添加到末尾，创建一个新的节点，将之前的last节点设置为新节点的pre，新节点设置为last</p>
<p>我们看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取到最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//构建一个新节点，将当前的last作为这个新节点的pre</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//把last指向新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果原先没有最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//将first指向新节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则，将原先的last的next指向新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">Node节点的定义：内部类</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        添加到其他位置，这个时候，就需要调整前后节点的引用指向</p>
<p>​    3，如何去定义一个双向链表的节点，如上述的源码所示</p>
<p>​    4，修改</p>
<p>​        修改最后一个节点或者第一个节点，那么就很快（first，last）</p>
<p>​        修改其他位置，如果是按坐标来定位节点，则会按照二分查找法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​     5，一个思考题，假如我们可以确定要存储1000个元素，那么采用ArrayList和LinkedList，</p>
<p>哪个更耗内存，为什么？</p>
<p>​        确定要存储的1000个对象的信息</p>
<p>​        ArrayList</p>
<p>​        LinkedList </p>
<p>​        哪个更省内存？</p>
<p>​        初始化好空间，就是1000，避免后期的扩容</p>
<p>​        LinkedList 比ArrayList多两个内存（头尾指针）</p>
<p>​    6，LinkedList，要实现在A和B之间插入C，该如何实现，编写伪代码即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C.pre = A;                        <span class="comment">// 先让C的前置节点认识A</span></span><br><span class="line">C.next = A.next;                  <span class="comment">// 再让C 的后置节点认识B</span></span><br><span class="line">A.next.pre = C;                   <span class="comment">// 然后A的后置节点的前置节点(即原来的B)变为C</span></span><br><span class="line">A.next = C;                       <span class="comment">// 最后让A 的后置节点变为C</span></span><br></pre></td></tr></table></figure>

<p>ArrayList连续的内存空间 优势变劣势</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/16.%20ArrayList%E5%92%8CLinkedList/" data-id="cl0j84juj000604vh8rbsay57" data-title="16.谈谈ArrayList和LinkedList的区别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-18. HashSet的存储原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/18.%20HashSet%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/18.%20HashSet%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/">18.HashMap的实现原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="18-HashMap的实现原理"><a href="#18-HashMap的实现原理" class="headerlink" title="18.HashMap的实现原理"></a>18.HashMap的实现原理</h1><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树</p>
<h2 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h2><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet.java:</span><br><span class="line">Public <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(e)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e,PRESENT)==nill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>从上面的代码可以看出<strong>HashSet</strong>原理实质就是<strong>Hashmap</strong>的原理</em></p>
<p><strong>第一，为什么要采用Hash算法？有什么优势，解决了什么问题？</strong></p>
<p>如果解决的问题是唯一性；并且存储数据，底层采用的是数组。</p>
<p>当我们往数组放数据的时候，你如何判断是否唯一？</p>
<p>可以采用遍历的方式，逐个比较，但是这种效率低，尤其是有很多数据的情况下。</p>
<p><strong>所以</strong></p>
<p>为了解决这个效率低的问题，采用新的方式：</p>
<p>采用hash算法，通过计算存储对象的hashcode，然后再跟数组长度-1做位运算，得到我们要存储在数组的哪个下标，如果此时计算的位置没有其他元素，直接存储，不用比较。</p>
<p>此处，我们只会用到hashCode</p>
<p>但是随着元素的不断添加，就可能出现“哈希冲突”，不同的对象计算出来的hash值是相同的，这个时候，我们就需要比较，才需要用到equals方法</p>
<p>如果equals相同，则不插入；不相等，则形成链表插入</p>
<p><strong>第二，所谓哈希表是一张什么表？</strong></p>
<p>本质是一个数组，而且数组的元素是链表</p>
<p>以上是JDK1.7的版本实现</p>
<p>而JDK1.8做了优化：</p>
<p>随着元素不断添加，链表可能会越来越长，当长度大于8时，会使用红黑树进行存放</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/18.%20HashSet%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/" data-id="cl0j84jum000a04vhbby14vth" data-title="18.HashMap的实现原理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2. ==和equals的区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/2.%20==%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/2.%20==%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/">2.==和equals的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="2-x3D-x3D-和equals的区别"><a href="#2-x3D-x3D-和equals的区别" class="headerlink" title="2.&#x3D;&#x3D;和equals的区别"></a>2.&#x3D;&#x3D;和equals的区别</h1><p>&#x3D;&#x3D; 比较的是值</p>
<p>比较基本的数据类型，比较的是数值</p>
<p>比较引用类型：比较引用指向的值（地址）</p>
<p>&#x3D;&#x3D;比较的是栈内存中存放的对象的堆内存地址，判断两个对象的地址是否相同需要判断是否指向同一个对象，是真正意义上的指针操作</p>
<p>equals</p>
<p>默认比较两个对象的内容是否相同，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的任然是Object类中的方法，而Object中的equals方法返回的却是**&#x3D;&#x3D;**的判断</p>
<p>代码案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;zs&quot;</span>);	</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">//false new String()会开辟新的内存空间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;zs&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);	<span class="comment">//true s3和s4指向同一个引用</span></span><br><span class="line">System.out.println(s3 == s1);	<span class="comment">//false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;zszs&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s3+s4;</span><br><span class="line">System.out.println(s5 == s6);   <span class="comment">//false</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;zs&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;zs&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> s7+s8;				<span class="comment">//true final修饰的变量为常量</span></span><br><span class="line">System.out.println(s5 == s9);</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s10</span> <span class="operator">=</span> s3+s4;		<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s10);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/2.%20==%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cl0j84jum000c04vhfg2s3vkj" data-title="2.==和equals的区别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-20. LinkedHashMap和HashMap的区别（重点）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/20.%20LinkedHashMap%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/20.%20LinkedHashMap%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/">20.LinkedHashMap和HashMap的区别（重点）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="20-LinkedHashMap和HashMap的区别（重点）"><a href="#20-LinkedHashMap和HashMap的区别（重点）" class="headerlink" title="20.LinkedHashMap和HashMap的区别（重点）"></a>20.LinkedHashMap和HashMap的区别（重点）</h1><p>HashMap：</p>
<p>HaspMap基于Hash算法实现，通过put(key.value)存储，get(key)获取。当传入key时，HaspMap会根据key.hashCode()计算hash值，根据hash值将value保存在buucket里。当计算出的hash值相同时，成为hash冲突，hashmap的做法是用链表和红黑树存储相同的hash值得value，当hash的冲突较少时，使用链表，否则使用红黑树。</p>
<p>主要关注几个点：</p>
<p>​        1，初始化大小是16，如果事先知道数据量的大小，建议修改默认初始化大小。 减少扩容次数，提高性能 ，这是我一直会强调的点</p>
<p>​        2，最大的装载因子默认是0.75，当HashMap中元素个数达到容量的0.75时，就会扩容。 容量是原先的两倍</p>
<p>​        3，HashMap底层采用链表法来解决冲突。 但是存在一个问题，就是链表也可能会过长，影响性能</p>
<p>于是JDK1.8,对HashMap做了进一步的优化，引入了红黑树。</p>
<p>​        当链表长度超过8，且数组容量大于64时，链表就会转换为红黑树</p>
<p>​        当红黑树的节点数量小于6时，会将红黑树转换为链表。</p>
<p>​        因为在数据量较小的情况下，红黑树要维护自身平衡，比链表性能没有优势。</p>
<p>这3点非常重要！</p>
<p>其次，LinkedHashMap就是链表+散列表的结构，其底层采用了Linked双向链表来保存节点的访问顺序，所以保证了有序性</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</li>
<li>HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。</li>
<li>HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null，其中HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null。此外，HashMap中的映射不是有序的。</li>
<li>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</li>
<li>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序 </p>
<ol>
<li>插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序</li>
<li>访问顺序：所谓访问指的是get&#x2F;put操作，对一个键执行get&#x2F;put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</li>
</ol>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h2 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>HashMap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。</li>
<li>HashMap最多只允许一条记录的键为Null；允许多条记录的值为 Null。</li>
<li>HashMap不支持线程的同步（即任一时刻可以有多个线程同时写HashMap），可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</li>
<li><strong>Hashtable与 HashMap类似，它继承自Dictionary类。不同的是：Hashtable不允许记录的键或者值为空；它支持线程的同步（即任一时刻只有一个线程能写Hashtable），因此也导致了 Hashtable在写入时会比较慢。</strong></li>
</ul>
<h2 id="LinkedHashMap-1"><a href="#LinkedHashMap-1" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul>
<li>保存插入顺序：LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时带参数，按照应用次数排序。</li>
<li>速度慢：在遍历的时候会比HashMap慢，不过有种情况例外：当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢。因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/20.%20LinkedHashMap%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/" data-id="cl0j84juq000k04vhbgvx45s9" data-title="20.LinkedHashMap和HashMap的区别（重点）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-21. ConcurrentHashMap，HashMap，Hashtable的区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/21.%20ConcurrentHashMap%EF%BC%8CHashMap%EF%BC%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/21.%20ConcurrentHashMap%EF%BC%8CHashMap%EF%BC%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/">21. ConcurrentHashMap，HashMap，Hashtable的区别（重点）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="21-ConcurrentHashMap，HashMap，Hashtable的区别"><a href="#21-ConcurrentHashMap，HashMap，Hashtable的区别" class="headerlink" title="21. ConcurrentHashMap，HashMap，Hashtable的区别"></a>21. ConcurrentHashMap，HashMap，Hashtable的区别</h1><p>存储： HashMap运行key和value为nuell，而Hashtable不允许</p>
<p>线程安全：前者非线程安全，后者线程安全</p>
<p>推荐使用：在hashtable的类注释可以看到，hashtable是保留类不建议使用，推荐在单线程环境下使用HashMap代替，如果需要多线程使用则用ConcurrentHashMap替代</p>
<p><img src="/hashtable.png" alt="hashtable"></p>
<p>​                                                             HashTable</p>
<p>Hashtable是线程安全的，但效率低</p>
<p><img src="/hashmap.png" alt="hashmap"></p>
<p>​                                                                      HashMap</p>
<p>HashMap是线程不安全的，但效率高</p>
<p><img src="/concurrenthashmap.png" alt="concurrenthashmap"></p>
<p>三者在开发这如何选择</p>
<p>1、优先选择HashMap（如果不是多个线程访问同一个资源的情况，有限选择HashMap，局部变量，不是全局变量）</p>
<p>2、是全局变量，多个线程共享访问的时候，选择ConcurrentHashMap（开发中一般是不需要这个东西的）</p>
<h3 id="1、首先，来看看其他几个相关的类"><a href="#1、首先，来看看其他几个相关的类" class="headerlink" title="1、首先，来看看其他几个相关的类"></a>1、首先，来看看其他几个相关的类</h3><p><strong>Hashtable是线程安全的，但效率低</strong></p>
<p>HashMap是线程不安全的(如果有多个线程同时操作这一个hashmap，可能会出现线程不安全甚至出现死锁)，但效率高Collections.synchronizedMap()，工具类提供了同步包装器的方法，来返回具有线程安全的集合对象</p>
<p>性能依然有问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SynchronizedMap</span>&lt;&gt;(m);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//在这个类的内部方法实现上，也只是单纯加上了锁</span></span><br><span class="line"> <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>为解决这样的矛盾问题，所以JDK提供了并发包，来平衡这样的问题（java.util.concurrent）</p>
<h2 id="2，ConcurrentHashMap（重点"><a href="#2，ConcurrentHashMap（重点" class="headerlink" title="2，ConcurrentHashMap（重点)"></a>2，ConcurrentHashMap（重点)</h2><ul>
<li><p>兼顾了线程安全和效率的问题</p>
<p>​    分析：HashTable锁了整段数据（用户操作是不同的数据段，依然需要等待）</p>
<p>​    解决方案：把数据分段，执行分段锁（分离锁），核心把锁的范围变小，这样出现并    发冲突的概率就变小</p>
<p>​    在保存的时候，计算所存储的数据是属于哪一段，只锁当前这一段</p>
</li>
<li><p>注意：分段锁（分离锁）是JDK1.8之前的一种的方案，JDK1.8之后做了优化。</p>
</li>
</ul>
<p><strong>JDK1.7跟JDK1.8在ConcurrentHashMap的实现上存在以下区别：</strong></p>
<p><strong>1，数据结构</strong></p>
<p>JDK1.7采用链表的方式，而JDK1.8则采用链表+红黑树的方式</p>
<p><strong>2，发生hash碰撞之后</strong></p>
<p>JDK1.7发生碰撞之后，会采用链表的方式来解决</p>
<p>JDK1.8发生碰撞之后，默认采用链表，但当链表的长度超过8，且数组容量超过64时，会转换为红黑树存储</p>
<p><strong>3，保证并发安全</strong></p>
<p>JDK1.7采用分段锁的方式，而JDK1.8采用CAS和synchronized的组合模式</p>
<p><strong>4，查询复杂度</strong></p>
<p>JDK1.7采用链表的方式，时间复杂度为O(n)，而JDK1.8在采用红黑树的方式时，时间复杂度为O(log(n))</p>
<p><strong>题外话：</strong></p>
<p><strong>不过红黑树其实是一种兜底方案，因为当链表数量达到8个的时候，其发生的概率是千万分之几，所以作者考虑到这种极端情况下，需要用红黑树的方式来优化</strong></p>
<h2 id="ConcurrentHashMap原理概览"><a href="#ConcurrentHashMap原理概览" class="headerlink" title="ConcurrentHashMap原理概览"></a>ConcurrentHashMap原理概览</h2><p>在ConcurrentHashMap中通过一个Node[]数组来保存添加到map中的键值对，而在同一个数组位置是通过链表和红黑树的形式来保存的。但是这个数组只有在第一次添加元素的时候才会初始化，否则只是初始化一个ConcurrentHashMap对象的话，只是设定了一个sizeCtl变量，这个变量用来判断对象的一些状态和是否需要扩容，后面会详细解释。</p>
<p>　　第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取与来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个以上，如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64了的话，在会将该节点的链表转换成树。</p>
<p>　　通过扩容数组的方式来把这些节点给分散开。然后将这些元素复制到扩容后的新的数组中，同一个链表中的元素通过hash值的数组长度位来区分，是还是放在原来的位置还是放到扩容的长度的相同位置去 。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p>
<p>　　取元素的时候，相对来说比较简单，通过计算hash来确定该元素在数组的哪个位置，然后在通过遍历链表或树来判断key和key的hash，取出value值。</p>
<h2 id="ConcurrentHashMap的锁分段技术保障线程安全"><a href="#ConcurrentHashMap的锁分段技术保障线程安全" class="headerlink" title="ConcurrentHashMap的锁分段技术保障线程安全"></a><strong>ConcurrentHashMap的锁分段技术</strong>保障线程安全</h2><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁。那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 另外，ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/21.%20ConcurrentHashMap%EF%BC%8CHashMap%EF%BC%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cl0j84jus000n04vhh27n2hr1" data-title="21. ConcurrentHashMap，HashMap，Hashtable的区别（重点）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-24. IO" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/24.%20IO/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T16:00:00.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/24.%20IO/">24. IO流的分类及选择</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="24-IO流的分类及选择"><a href="#24-IO流的分类及选择" class="headerlink" title="24. IO流的分类及选择"></a>24. IO流的分类及选择</h1><p><strong>1，分类</strong></p>
<p>按方向分：输入流，输出流</p>
<p><strong>（注意，是站在程序的角度来看方向），输入流用于读文件，输出流用于写文件</strong></p>
<p>按读取的单位分：字节流，字符流</p>
<p>按处理的方式分：节点流，处理流</p>
<p>比如，FileInputStream和BufferedInputStream(后者带有缓存区功能-byte[])</p>
<p>IO流的4大基类：InputStream，OutputStream，Reader，Writer</p>
<p><strong>2，选择</strong></p>
<p>字节流可以读取任何文件</p>
<p>读取文本文件的时候：选择字符流（假如有解析文件的内容的需求，比如逐行处理，则采用字符流，比如txt文件）</p>
<p>读取二进制文件的时候，选择字节流（视频，音频，doc，ppt）</p>
<p>   下面是IO中输入字节流的继承图。</p>
<p> <strong>InputStream</strong></p>
<p>​        <strong>ByteArrayInputStream</strong></p>
<p>​        <strong>FileInputStream</strong></p>
<p>​        <strong>FilterInputStream</strong></p>
<p>​                <strong>BufferedInputStream</strong></p>
<p>​                <strong>DataInputStream</strong></p>
<p>​                <strong>LineNumberInputStream</strong></p>
<p>​                 <strong>PushbackInputStream</strong></p>
<p>​        <strong>ObjectInputStream</strong></p>
<p>​         <strong>PipedInputStream</strong></p>
<p>​        <strong>SequenceInputStream</strong></p>
<p>​         <strong>StringBufferInputStream</strong></p>
<p>在上面的关系图中可以看出：</p>
<p>1.InputStream是所有的输入字节流的父类，它是一个抽象类。</p>
<p>2.ByteArrayInputStream、StringBufferInputStream、FileInputStream是三种基本的介质流，它们分别将Byte数组、StringBuffer、和本地文件中读取数据。PipedInputStream是从与其它线程共用的管道中读取数据，与Piped相关的知识会用专门的一小节讲解。</p>
<p>3.ObjectInputStream和所有FilterInputStream的子类都是装饰流（装饰器模式的主角）。下表列出了这些流的功能及如何使用它们（具体使用在讲解完装饰器模式后会举几个例子）。</p>
<table>
<thead>
<tr>
<th><strong>类</strong></th>
<th><strong>功能</strong></th>
<th align="left"><strong>如何构造</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td align="left"><strong>怎样使用</strong></td>
</tr>
<tr>
<td><strong>ByteArrayInputStream</strong></td>
<td><strong>将内存中的Byte数组适配为一个InputStream。</strong></td>
<td align="left"><strong>从内存中的Byte数组创建该对象（2种方法）</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"><strong>一般作为数据源，会使用其它装饰流提供额外的功能，一般都建议加个缓冲功能。</strong></td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong></td>
<td><strong>将内存中的字符串适配为一个InputStream。</strong></td>
<td align="left"><strong>从一个String对象创建该对象。底层的实现使用StringBuffer。该类被Deprecated。主要原因是StringBuffer不应该属于字节流，所以推荐使用StringReader。</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"><strong>一般作为数据源，同样会使用其它装饰器提供额外的功能。</strong></td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td><strong>最基本的文件输入流。主要用于从文件中读取信息。</strong></td>
<td align="left"><strong>通过一个代表文件路径的 String、File对象或者  FileDescriptor对象创建。</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"><strong>一般作为数据源，同样会使用其它装饰器提供额外的功能。</strong></td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td><strong>读取从对应PipedOutputStream写入的数据。在流中实现了管道的概念。</strong></td>
<td align="left"><strong>利用对应的PipedOutputStream创建。</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"><strong>在多线程程序中作为数据源，同样会使用其它装饰器提供额外的功能。</strong></td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
<td><strong>将2个或者多个InputStream  对象转变为一个InputStream.</strong></td>
<td align="left"><strong>使用两个InputStream 或者内部对象为InputStream  的Enumeration对象创建该对象。</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left"><strong>一般作为数据源，同样会使用其它装饰器提供额外的功能。</strong></td>
</tr>
<tr>
<td><strong>FilterInputStream</strong></td>
<td><strong>给其它被装饰对象提供额外功能的抽象类</strong></td>
<td align="left"><strong>主要子类见下表</strong></td>
</tr>
</tbody></table>
<p>装饰、输入字节流：</p>
<table>
<thead>
<tr>
<th><strong>类</strong></th>
<th align="left"><strong>功能</strong></th>
<th><strong>如何构造</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="left"></td>
<td><strong>怎样使用</strong></td>
</tr>
<tr>
<td>DataInputStream</td>
<td align="left">一般和DataOutputStream配对使用,完成基本数据类型的读写。</td>
<td>利用一个InputStream构造。</td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td>提供了大量的读取基本数据类新的读取方法。</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td align="left">使用该对象阻止每次读取一个字节都会频繁操作IO。将字节读取一个缓存区，从缓存区读取。</td>
<td>利用一个InputStream、或者带上一个自定义的缓存区的大小构造。</td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td>使用InputStream的方法读取，只是背后多一个缓存的功能。设计模式中透明装饰器的应用。</td>
</tr>
<tr>
<td>LineNumberInputStream</td>
<td align="left">跟踪输入流中的行号。可以调用getLineNumber( )和  setLineNumber(int)方法得到和设置行号。</td>
<td>利用一个InputStream构造。</td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td>紧紧增加一个行号。可以象使用其它InputStream一样使用。</td>
</tr>
<tr>
<td>PushbackInputStream</td>
<td align="left">可以在读取最后一个byte 后将其放回到缓存中。</td>
<td>利用一个InputStream构造。</td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td>一般仅仅会在设计compiler的scanner  时会用到这个类。在我们的java语言的编译器中使用它。很多程序员可能一辈子都不需要</td>
</tr>
</tbody></table>
<p>下面是IO中输出字节流的继承图。</p>
<ul>
<li><p>OutputStream</p>
</li>
<li><ul>
<li><p>ByteArrayOutputStream</p>
</li>
<li><p>FileOutputStream</p>
</li>
<li><p>FilterOutputStream</p>
</li>
<li><ul>
<li>BufferedOutputStream</li>
<li>DataOutputStream</li>
<li>PrintStream</li>
</ul>
</li>
<li><p>ObjectOutputStream</p>
</li>
<li><p>PipedOutputStream</p>
</li>
</ul>
</li>
</ul>
<p>在上面的关系图中可以看出：1.OutputStream是所有的输出字节流的父类，它是一个抽象类。2. ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte数组、和本地文件中写入数据。PipedOutputStream是向与其它线程共用的管道中写入数据， 3. ObjectOutputStream和所有FilterOutputStream的子类都是装饰流。下表列出了输出字节流的功能及如何使用它们。</p>
<table>
<thead>
<tr>
<th><strong>类</strong></th>
<th><strong>功能</strong></th>
<th><strong>如何构造</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td><strong>怎样使用</strong></td>
</tr>
<tr>
<td>ByteArrayOutputStream</td>
<td>在内存中创建一个buffer。所有写入此流中的数据都被放入到此buffer中。</td>
<td>无参或者使用一个可选的初始化buffer的大小的参数构造。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>一般将其和FilterOutputStream套接得到额外的功能。建议首先和BufferedOutputStream套接实现缓冲功能。通过toByteArray方法可以得到流中的数据。（不通明装饰器的用法）</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>将信息写入文件中。</td>
<td>使用代表文件路径的String、File对象或者  FileDescriptor对象创建。还可以加一个代表写入的方式是否为append的标记。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>一般将其和FilterOutputStream套接得到额外的功能。</td>
</tr>
<tr>
<td>PipedOutputStream</td>
<td>任何写入此对象的信息都被放入对应PipedInputStream  对象的缓存中，从而完成线程的通信，实现了“管道”的概念。具体在后面详细讲解。</td>
<td>利用PipedInputStream构造</td>
</tr>
<tr>
<td></td>
<td></td>
<td>在多线程程序中数据的目的地的。一般将其和FilterOutputStream套接得到额外的功能。</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>实现装饰器功能的抽象类。为其它OutputStream对象增加额外的功能。</td>
<td>见下表</td>
</tr>
<tr>
<td></td>
<td></td>
<td>见下表</td>
</tr>
</tbody></table>
<p>装饰输出字节流：</p>
<table>
<thead>
<tr>
<th><strong>类</strong></th>
<th><strong>功能</strong></th>
<th><strong>如何构造</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td><strong>怎样使用</strong></td>
</tr>
<tr>
<td>DataOutputStream</td>
<td>通常和DataInputStream配合使用，使用它可以写入基本数据类新。</td>
<td>使用OutputStream构造</td>
</tr>
<tr>
<td></td>
<td></td>
<td>包含大量的写入基本数据类型的方法。</td>
</tr>
<tr>
<td>PrintStream</td>
<td>产生具有格式的输出信息。（一般地在java程序中DataOutputStream用于数据的存储，即J2EE中持久层完成的功能，PrintStream完成显示的功能，类似于J2EE中表现层的功能）</td>
<td>使用OutputStream和一个可选的表示缓存是否在每次换行时是否flush的标记构造。还提供很多和文件相关的构造方法。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>一般是一个终极（“final”）的包装器，很多时候我们都使用它！</td>
</tr>
<tr>
<td>BufferedOutputStream</td>
<td>使用它可以避免频繁地向IO写入数据，数据一般都写入一个缓存区，在调用flush方法后会清空缓存、一次完成数据的写入。</td>
<td>从一个OutputStream或者和一个代表缓存区大小的可选参数构造。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>提供和其它OutputStream一致的接口，只是内部提供一个缓存的功能。</td>
</tr>
</tbody></table>
<p><img src="/IO%E6%B5%81.jpg" alt="IO"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/24.%20IO/" data-id="cl0j84juu000q04vhh6ag39dx" data-title="24. IO流的分类及选择" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/19/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/concurrency/">concurrency</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/open-source/">open-source</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/" rel="tag">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E9%A1%B9%E7%9B%AE/" rel="tag">Java项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">MySql、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" rel="tag">Redis、面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Java/" rel="tag">Spring Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E3%80%81blog/" rel="tag">hexo、blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm-memory-management/" rel="tag">jvm-memory-management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty-source/" rel="tag">netty-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-intro/" rel="tag">spring-aop-intro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-source/" rel="tag">spring-aop-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="tag">循环依赖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/Java/" style="font-size: 15.56px;">Java</a> <a href="/tags/Java-JVM/" style="font-size: 18.89px;">Java JVM</a> <a href="/tags/Java-Spring/" style="font-size: 13.33px;">Java Spring</a> <a href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.78px;">Java、面试题</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">Java数据结构</a> <a href="/tags/Java%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">Java项目</a> <a href="/tags/MySql/" style="font-size: 20px;">MySql</a> <a href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.11px;">MySql、面试题</a> <a href="/tags/Redis/" style="font-size: 14.44px;">Redis</a> <a href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Redis、面试</a> <a href="/tags/Spring-Java/" style="font-size: 13.33px;">Spring Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/hexo%E3%80%81blog/" style="font-size: 10px;">hexo、blog</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm-memory-management/" style="font-size: 10px;">jvm-memory-management</a> <a href="/tags/netty-source/" style="font-size: 11.11px;">netty-source</a> <a href="/tags/redis/" style="font-size: 17.78px;">redis</a> <a href="/tags/spring-aop-intro/" style="font-size: 10px;">spring-aop-intro</a> <a href="/tags/spring-aop-source/" style="font-size: 10px;">spring-aop-source</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" style="font-size: 10px;">循环依赖</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/09/update%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97%EF%BC%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/Redis_hot/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM类加载机制</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Lee yunbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>