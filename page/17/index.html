<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MyHomePage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="MyHomePage">
<meta property="og:url" content="http://example.com/page/17/index.html">
<meta property="og:site_name" content="MyHomePage">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lee yunbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MyHomePage" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MyHomePage</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-MySql查询练习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/MySql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T10:31:33.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySql/">MySql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/MySql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/">查询练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h1><p>### 准备数据</p>
<p>`&#96;&#96;mysql<br>– 创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE select_test;</span><br></pre></td></tr></table></figure>

<p>– 切换数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE select_test;</span><br></pre></td></tr></table></figure>

<p>– 创建学生表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">  no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20) NOT NULL,</span><br><span class="line">  sex VARCHAR(10) NOT NULL,</span><br><span class="line">  birthday DATE, -- 生日</span><br><span class="line">  class VARCHAR(20) -- 所在班级</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 创建教师表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE teacher (</span><br><span class="line">  no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20) NOT NULL,</span><br><span class="line">  sex VARCHAR(10) NOT NULL,</span><br><span class="line">  birthday DATE,</span><br><span class="line">  profession VARCHAR(20) NOT NULL, -- 职称</span><br><span class="line">  department VARCHAR(20) NOT NULL -- 部门</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 创建课程表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE course (</span><br><span class="line">  no VARCHAR(20) PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20) NOT NULL,</span><br><span class="line">  t_no VARCHAR(20) NOT NULL, -- 教师编号</span><br><span class="line">  -- 表示该 tno 来自于 teacher 表中的 no 字段值</span><br><span class="line">  FOREIGN KEY(t_no) REFERENCES teacher(no) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 成绩表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE score (</span><br><span class="line">  s_no VARCHAR(20) NOT NULL, -- 学生编号</span><br><span class="line">  c_no VARCHAR(20) NOT NULL, -- 课程号</span><br><span class="line">  degree DECIMAL,   -- 成绩</span><br><span class="line">  -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值</span><br><span class="line">  FOREIGN KEY(s_no) REFERENCES student(no),   </span><br><span class="line">  FOREIGN KEY(c_no) REFERENCES course(no),</span><br><span class="line">  -- 设置 s_no, c_no 为联合主键</span><br><span class="line">  PRIMARY KEY(s_no, c_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 查看所有表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p>– 添加学生表数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student VALUES(&#x27;101&#x27;, &#x27;曾华&#x27;, &#x27;男&#x27;, &#x27;1977-09-01&#x27;, &#x27;95033&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;102&#x27;, &#x27;匡明&#x27;, &#x27;男&#x27;, &#x27;1975-10-02&#x27;, &#x27;95031&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;103&#x27;, &#x27;王丽&#x27;, &#x27;女&#x27;, &#x27;1976-01-23&#x27;, &#x27;95033&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;104&#x27;, &#x27;李军&#x27;, &#x27;男&#x27;, &#x27;1976-02-20&#x27;, &#x27;95033&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;105&#x27;, &#x27;王芳&#x27;, &#x27;女&#x27;, &#x27;1975-02-10&#x27;, &#x27;95031&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;106&#x27;, &#x27;陆军&#x27;, &#x27;男&#x27;, &#x27;1974-06-03&#x27;, &#x27;95031&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;107&#x27;, &#x27;王尼玛&#x27;, &#x27;男&#x27;, &#x27;1976-02-20&#x27;, &#x27;95033&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;108&#x27;, &#x27;张全蛋&#x27;, &#x27;男&#x27;, &#x27;1975-02-10&#x27;, &#x27;95031&#x27;);</span><br><span class="line">INSERT INTO student VALUES(&#x27;109&#x27;, &#x27;赵铁柱&#x27;, &#x27;男&#x27;, &#x27;1974-06-03&#x27;, &#x27;95031&#x27;);</span><br></pre></td></tr></table></figure>

<p>– 添加教师表数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO teacher VALUES(&#x27;804&#x27;, &#x27;李诚&#x27;, &#x27;男&#x27;, &#x27;1958-12-02&#x27;, &#x27;副教授&#x27;, &#x27;计算机系&#x27;);</span><br><span class="line">INSERT INTO teacher VALUES(&#x27;856&#x27;, &#x27;张旭&#x27;, &#x27;男&#x27;, &#x27;1969-03-12&#x27;, &#x27;讲师&#x27;, &#x27;电子工程系&#x27;);</span><br><span class="line">INSERT INTO teacher VALUES(&#x27;825&#x27;, &#x27;王萍&#x27;, &#x27;女&#x27;, &#x27;1972-05-05&#x27;, &#x27;助教&#x27;, &#x27;计算机系&#x27;);</span><br><span class="line">INSERT INTO teacher VALUES(&#x27;831&#x27;, &#x27;刘冰&#x27;, &#x27;女&#x27;, &#x27;1977-08-14&#x27;, &#x27;助教&#x27;, &#x27;电子工程系&#x27;);</span><br></pre></td></tr></table></figure>

<p>– 添加课程表数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO course VALUES(&#x27;3-105&#x27;, &#x27;计算机导论&#x27;, &#x27;825&#x27;);</span><br><span class="line">INSERT INTO course VALUES(&#x27;3-245&#x27;, &#x27;操作系统&#x27;, &#x27;804&#x27;);</span><br><span class="line">INSERT INTO course VALUES(&#x27;6-166&#x27;, &#x27;数字电路&#x27;, &#x27;856&#x27;);</span><br><span class="line">INSERT INTO course VALUES(&#x27;9-888&#x27;, &#x27;高等数学&#x27;, &#x27;831&#x27;);</span><br></pre></td></tr></table></figure>

<p>– 添加添加成绩表数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO score VALUES(&#x27;103&#x27;, &#x27;3-105&#x27;, &#x27;92&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;103&#x27;, &#x27;3-245&#x27;, &#x27;86&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;103&#x27;, &#x27;6-166&#x27;, &#x27;85&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;105&#x27;, &#x27;3-105&#x27;, &#x27;88&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;105&#x27;, &#x27;3-245&#x27;, &#x27;75&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;105&#x27;, &#x27;6-166&#x27;, &#x27;79&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;109&#x27;, &#x27;3-105&#x27;, &#x27;76&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;109&#x27;, &#x27;3-245&#x27;, &#x27;68&#x27;);</span><br><span class="line">INSERT INTO score VALUES(&#x27;109&#x27;, &#x27;6-166&#x27;, &#x27;81&#x27;);</span><br></pre></td></tr></table></figure>

<p>– 查看表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM course;</span><br><span class="line">SELECT * FROM score;</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">SELECT * FROM teacher;</span><br></pre></td></tr></table></figure>

<p>### 1 到 10</p>
<p>`&#96;&#96;mysql<br>– 查询 student 表的所有行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student;</span><br></pre></td></tr></table></figure>

<p>– 查询 student 表中的 name、sex 和 class 字段的所有行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, sex, class FROM student;</span><br></pre></td></tr></table></figure>

<p>– 查询 teacher 表中不重复的 department 列<br>– department: 去重查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT department FROM teacher;</span><br></pre></td></tr></table></figure>

<p>– 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）<br>– BETWEEN xx AND xx: 查询区间, AND 表示 “并且”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM score WHERE degree BETWEEN 60 AND 80;</span><br><span class="line">SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;</span><br></pre></td></tr></table></figure>

<p>– 查询 score 表中成绩为 85, 86 或 88 的行<br>– IN: 查询规定中的多个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM score WHERE degree IN (85, 86, 88);</span><br></pre></td></tr></table></figure>

<p>– 查询 student 表中 ‘95031’ 班或性别为 ‘女’ 的所有行<br>– or: 表示或者关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE class = &#x27;95031&#x27; or sex = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure>

<p>– 以 class 降序的方式查询 student 表的所有行<br>– DESC: 降序，从高到低<br>– ASC（默认）: 升序，从低到高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student ORDER BY class DESC;</span><br><span class="line">SELECT * FROM student ORDER BY class ASC;</span><br></pre></td></tr></table></figure>

<p>– 以 c_no 升序、degree 降序查询 score 表的所有行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM score ORDER BY c_no ASC, degree DESC;</span><br></pre></td></tr></table></figure>

<p>– 查询 “95031” 班的学生人数<br>– COUNT: 统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM student WHERE class = &#x27;95031&#x27;;</span><br></pre></td></tr></table></figure>

<p>– 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。<br>– (SELECT MAX(degree) FROM score): 子查询，算出最高分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);</span><br></pre></td></tr></table></figure>

<p>–  排序查询<br>– LIMIT r, n: 表示从第r行开始，查询n条数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s_n</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/MySql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/" data-id="cl0j84jwa005w04vh4zuwbo27" data-title="查询练习" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySql数据库的三大设计范式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T10:30:41.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySql/">MySql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/">数据库的三大设计范式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h1><h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><p>只要字段值还可以继续拆分，就不满足第一范式。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p>
<p>mysql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE myorder (</span><br><span class="line">  product_id INT,</span><br><span class="line">  customer_id INT,</span><br><span class="line">  product_name VARCHAR(20),</span><br><span class="line">  customer_name VARCHAR(20),</span><br><span class="line">  PRIMARY KEY (product_id, customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
<p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p>
<p>mysql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">  order_id INT PRIMARY KEY,</span><br><span class="line">  product_id INT,</span><br><span class="line">  customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE product (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
<h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p>
<p>mysql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">  order_id INT PRIMARY KEY,</span><br><span class="line">  product_id INT,</span><br><span class="line">  customer_id INT,</span><br><span class="line">  customer_phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p>
<p>mysql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE myorder (</span><br><span class="line">  order_id INT PRIMARY KEY,</span><br><span class="line">  product_id INT,</span><br><span class="line">  customer_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  phone VARCHAR(15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/" data-id="cl0j84jw9005t04vh9rd48nyb" data-title="数据库的三大设计范式" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySql建表约束" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/MySql%E5%BB%BA%E8%A1%A8%E7%BA%A6%E6%9D%9F/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T10:29:31.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySql/">MySql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/MySql%E5%BB%BA%E8%A1%A8%E7%BA%A6%E6%9D%9F/">建表约束</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h1><p>### 主键约束</p>
<p>`&#96;&#96;mysql<br>– 主键约束<br>– 使某个字段不重复且不得为空，确保表内所有数据的唯一性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 联合主键<br>– 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">  id INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  password VARCHAR(20),</span><br><span class="line">  PRIMARY KEY(id, name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 自增约束<br>– 自增约束的主键由系统自动递增分配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 添加主键约束<br>– 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user ADD PRIMARY KEY(id);</span><br><span class="line">ALTER TABLE user MODIFY id INT PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p>– 删除主键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user drop PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p>### 唯一主键</p>
<p>`&#96;&#96;mysql<br>– 建表时创建唯一主键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">  id INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  UNIQUE(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 添加唯一主键<br>– 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user ADD UNIQUE(name);</span><br><span class="line">ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;</span><br></pre></td></tr></table></figure>

<p>– 删除唯一主键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user DROP INDEX name;</span><br></pre></td></tr></table></figure>

<p>### 非空约束</p>
<p>`&#96;&#96;mysql<br>– 建表时添加非空约束<br>– 约束某个字段不能为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">  id INT,</span><br><span class="line">  name VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 移除非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user MODIFY name VARCHAR(20);</span><br></pre></td></tr></table></figure>

<p>### 默认约束</p>
<p>`&#96;&#96;mysql<br>– 建表时添加默认约束<br>– 约束某个字段的默认值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user2 (</span><br><span class="line">  id INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  age INT DEFAULT 10</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 移除非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user MODIFY age INT;</span><br></pre></td></tr></table></figure>

<p>### 外键约束</p>
<p>mysql<br>– 班级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE classes (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 学生表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE students (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  -- 这里的 class_id 要和 classes 中的 id 字段相关联</span><br><span class="line">  class_id INT,</span><br><span class="line">  -- 表示 class_id 的值必须来自于 classes 中的 id 字段值</span><br><span class="line">  FOREIGN KEY(class_id) REFERENCES classes(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；<br>– 2. 主表中的记录被副表引用时，主表不可以被删除。<br>`&#96;&#96;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/MySql%E5%BB%BA%E8%A1%A8%E7%BA%A6%E6%9D%9F/" data-id="cl0j84jw8005n04vhbqx7btvf" data-title="建表约束" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySql创建数据库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/MySql%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T09:32:39.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySql/">MySql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/MySql%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/">创建数据库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL数据库创建和基本命令"><a href="#MySQL数据库创建和基本命令" class="headerlink" title="MySQL数据库创建和基本命令"></a>MySQL数据库创建和基本命令</h1><p>登录和退出MySQL服务器</p>
<p>shell</p>
<p>登录MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 123456</span><br></pre></td></tr></table></figure>

<p>退出MySQL数据库服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>–mysql<br>– 显示所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<p>– 创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE test;</span><br></pre></td></tr></table></figure>

<p>– 切换数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br></pre></td></tr></table></figure>

<p>– 显示数据库中的所有表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<p>– 创建数据表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE pet (</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  owner VARCHAR(20),</span><br><span class="line">  species VARCHAR(20),</span><br><span class="line">  sex CHAR(1),</span><br><span class="line">  birth DATE,</span><br><span class="line">  death DATE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>– 查看数据表结构<br>– describe pet;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc pet;</span><br></pre></td></tr></table></figure>

<p>– 查询表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from pet;</span><br></pre></td></tr></table></figure>

<p>– 插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO pet VALUES (&#x27;puffball&#x27;, &#x27;Diane&#x27;, &#x27;hamster&#x27;, &#x27;f&#x27;, &#x27;1990-03-30&#x27;, NULL);</span><br></pre></td></tr></table></figure>

<p>– 修改数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE pet SET name = &#x27;squirrel&#x27; where owner = &#x27;Diane&#x27;;</span><br></pre></td></tr></table></figure>

<p>– 删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM pet where name = &#x27;squirrel&#x27;;</span><br></pre></td></tr></table></figure>

<p>– 删除表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE myorder;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/MySql%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="cl0j84jw2005b04vhejbr93ln" data-title="创建数据库" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/Java%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:55:42.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/Java%E9%94%81/">JAVA锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="多线程中synchronized锁升级的原理是什么"><a href="#多线程中synchronized锁升级的原理是什么" class="headerlink" title="多线程中synchronized锁升级的原理是什么"></a>多线程中synchronized锁升级的原理是什么</h1><p>synchronized锁升级原理：</p>
<p>在锁对象的对头里面有一个thread id字段，在第一次访问的时候thread id为空，jvm让其持有偏向锁，并将thread id设置为其线程id，再次进入的时候会判断thread id是否为其线程id一致，如果一致则可以直接使用次对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized锁的升级</p>
<p>锁升级的目的：锁升级是为了减低锁带来的性能消耗。在java6之后优化synchronized的实现方式，使用了偏向锁升级轻量级锁再升级重量级锁的方式，从而减低了锁带来哦的性能消耗。</p>
<h1 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h1><p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试去获取独占锁a的情况下，就会发送AB两个线程互相持有对方需要的锁，而发生阻塞的现象，称之为死锁！</p>
<h1 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h1><ol>
<li><p>尽量使用tryLock的方法</p>
</li>
<li><p>设置超时时间</p>
</li>
<li><p>使用Java.util.concurrent并发类代替自己手写锁</p>
</li>
<li><p>尽量降低锁的使用粒度，不要几个功能用一把锁</p>
</li>
<li><p>尽量减少同步的代码块</p>
</li>
</ol>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能低，每次都拿数据的时候都认为比人不会修改，所以不用上锁，但在更新的时候会判断一下在此期间别人有没有更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java中乐观锁基本都是CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败</p>
<p>（数据库中的乐观锁：乐观锁认为一个用户读数据的时候，比人不会去写自己所读的数据）</p>
<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁是悲观思想，即认为写多，遇到并发写的可能性搞，每次那数据的时候都认为比人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block知道拿到锁。java中悲观锁就是Synchronized,AQS框架下则是先尝试cas乐观锁去获取锁，获取不到才会装换为悲观锁，如RetreenLock。</p>
<p>（数据库中的悲观锁：悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许比人修改那部分的数据）</p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁原理非常简单， 如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p><strong>自旋锁的优缺点</strong></p>
<p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p>
<p><strong>自旋锁时间阈值</strong>（JDK1.6 引入了适应性自旋锁）</p>
<p>自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！ </p>
<p>JVM 对于自旋周期的选择， jdk1.5 这个限度是一定的写死的， 在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化， 如果平均负载小于 CPUs 则一直自旋， 如果有超过(CPUs&#x2F;2)个线程正在自旋，则后来线程直接阻塞， 如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入 阻塞， 如果 CPU 处于节电模式则停止自旋， 自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差） ， 自旋时会适当放弃线程优先级之间的差异。</p>
<p><strong>自旋锁的开启</strong></p>
<p>JDK1.6 中-XX:+UseSpinning 开启；</p>
<p>-XX:PreBlockSpin&#x3D;10 为自旋次数；</p>
<p>JDK1.7 后，去掉此参数，由 jvm 控制； </p>
<h1 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h1><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。 他属于独占式的悲观锁，同时属于可重入锁。 Synchronized 作用范围</p>
<ol>
<li><p>作用于方法时，锁住的是对象的实例(this)； </p>
</li>
<li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p>
</li>
<li><p>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。 它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p>
</li>
</ol>
<p><strong>Synchronized</strong> <strong>核心组件</strong></p>
<ol>
<li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>Contention List： 竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List： Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</p>
</li>
<li><p>OnDeck：任意时刻， 最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为 Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<p><strong>Synchronized</strong> <strong>实现</strong> </p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争， JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。 </p>
</li>
<li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</p>
</li>
<li><p>处于 ContentionList、 EntryList、 WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p>
</li>
<li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时， 等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/zqz_zqz/article/details/70233767">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></p>
</li>
<li><p>每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p>
</li>
<li><p>Java1.6， synchronized 进行了很多的优化， 有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p>
</li>
<li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</p>
</li>
</ol>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h1><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法， 他是一种可重入锁， 除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p>
<p>Lock 接口的主要方法</p>
<ol>
<li><p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.</p>
</li>
<li><p>boolean tryLock()： 如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用,当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.</p>
</li>
<li><p>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</p>
</li>
<li><p>Condition newCondition()： 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</p>
</li>
<li><p>getHoldCount() ： 查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。</p>
</li>
<li><p>getQueueLength（） ： 返回正等待获取此锁的线程估计数，比如启动 10 个线程， 1 个线程获得锁，此时返回的是 9</p>
</li>
<li><p>getWaitQueueLength： （Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了</p>
</li>
<li><p>condition 对象的 await 方法，那么此时执行此方法返回 10</p>
</li>
<li><p>hasWaiters(Condition condition)： 查询是否有线程等待与此锁有关的给定条件(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法。</p>
</li>
<li><p>hasQueuedThread(Thread thread)： 查询给定线程是否等待获取此锁</p>
</li>
<li><p>hasQueuedThreads()： 是否有线程等待此锁</p>
</li>
<li><p>isFair()： 该锁是否公平锁</p>
</li>
<li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</p>
</li>
<li><p>isLock()： 此锁是否有任意线程占用</p>
</li>
<li><p>lockInterruptibly（） ： 如果当前线程未被中断，获取锁</p>
</li>
<li><p>tryLock（） ： 尝试获得锁，仅在调用时锁未被线程占用，获得锁</p>
</li>
<li><p>tryLock(long timeout TimeUnit unit)： 如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</p>
</li>
</ol>
<h1 id="非公平锁和公平锁"><a href="#非公平锁和公平锁" class="headerlink" title="非公平锁和公平锁"></a>非公平锁和公平锁</h1><p><strong>非公平锁</strong></p>
<p>JVM 按随机、就近原则分配锁的机制则称为不公平锁， ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。 非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p>
<p><strong>公平锁</strong></p>
<p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p>
<h1 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h1><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<p><strong>独占锁</strong></p>
<p>独占锁模式下，每次只能有一个线程能持有锁， ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读&#x2F;读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p><strong>共享锁</strong></p>
<p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如： ReadWriteLock。 共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li><p>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</p>
</li>
<li><p>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p>
</li>
</ol>
<h1 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（Mutex Lock）</h1><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。</p>
<p>而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。</p>
<p>因此， 这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁” 。 JDK 中对 Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。</p>
<p>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。 </p>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。</p>
<p><strong>锁升级</strong></p>
<p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p>
<p>“轻量级” 是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。</p>
<p>在解释轻量级锁的执行过程之前， 先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁 </p>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。 偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</p>
<p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令， 而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。</p>
<p>上面说过， 轻量级锁是为了在线程交替执行同步块时提高性能， 而偏向锁则是在只有一个线程执行同步块时进一步提高性能 </p>
<h1 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h1><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p><strong>减少锁持有时间</strong></p>
<p>只用在有线程安全要求的程序上加锁</p>
<p><strong>减小锁粒度</strong></p>
<p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。</p>
<p>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。</p>
<p><strong>锁分离</strong></p>
<p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据</p>
<p><strong>锁粗化</strong></p>
<p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度， 如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p>
<p><strong>锁消除</strong></p>
<p>锁消除是在编译器级别的事情。 在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p>
<p>参考： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/39628e1180a9">https://www.jianshu.com/p/39628e1180a9</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/Java%E9%94%81/" data-id="cl0j84jyi00dx04vhbcmfgbfk" data-title="JAVA锁" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java中notify和notifyAll" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/Java%E4%B8%ADnotify%E5%92%8CnotifyAll/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:27:15.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/Java%E4%B8%ADnotify%E5%92%8CnotifyAll/">notify和notifyAll</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线程唤醒notify-和notifyAll"><a href="#线程唤醒notify-和notifyAll" class="headerlink" title="线程唤醒notify()和notifyAll()"></a>线程唤醒notify()和notifyAll()</h1><p>Object 类中的 notify() 方法， 唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待， 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。 </p>
<h1 id="notify-和notifyAll-有什么区别？"><a href="#notify-和notifyAll-有什么区别？" class="headerlink" title="notify()和notifyAll()有什么区别？"></a>notify()和notifyAll()有什么区别？</h1><p>notify可能会导致死锁，而notifyAll则不会</p>
<p>任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码</p>
<p>使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</p>
<p>wait() 应配合while循环使用，不应使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续wait()直至条件满足再往下执行。</p>
<p>notify() 是对notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是 WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中. </p>
<h1 id="为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify和notifyAll这些方法不在thread类里面？"></a>为什么wait, notify和notifyAll这些方法不在thread类里面？</h1><p>明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象 。</p>
<h1 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h1><ol>
<li><p>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。</p>
</li>
<li><p>如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</p>
</li>
<li><p>还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
</li>
</ol>
<p>wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。</p>
<p>在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</p>
<p>调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:”特殊状态已经被设置”。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/Java%E4%B8%ADnotify%E5%92%8CnotifyAll/" data-id="cl0j84jvm003s04vhcl6ldq47" data-title="notify和notifyAll" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Git常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:12:18.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Git常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p><img src="/git.png" alt="git"></p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>配置基本用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name&lt;你的用户名&gt;</span><br><span class="line"></span><br><span class="line">git config --global user.eamil&lt;你的邮箱地址&gt;</span><br></pre></td></tr></table></figure>

<p>创建一个新仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init	//也叫初始化一个仓库</span><br></pre></td></tr></table></figure>

<p>从远程服务器克隆一个仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;远程仓库url&gt;</span><br></pre></td></tr></table></figure>

<p>显示当前的工作目录下的提交文件状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>将指定文件Stage(标记为将要被提交的文件)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add&lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>将指定的文件Unstage（取消标记为将要被提交的文件）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset&lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>创建一个提交并提供提交信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交信息&quot;</span><br></pre></td></tr></table></figure>

<p>显示历史</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log //查看日志</span><br></pre></td></tr></table></figure>

<p>向远程仓库推送(Push)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>从远程仓库拉去（pull）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>修改（Amend）上一个提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &quot;&lt;新提交的信息&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>查看所有分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>创建新的分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch&lt;分支名字&gt;</span><br></pre></td></tr></table></figure>

<p>切换分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout&lt;分支名字&gt;</span><br></pre></td></tr></table></figure>

<p>重命名分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m&lt;旧名字&gt;&lt;新名字&gt;</span><br></pre></td></tr></table></figure>

<p>删除分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名字&gt;</span><br></pre></td></tr></table></figure>

<p>将分支变基（Rebase）到master</p>
<p>注：需要先切换到分支之后，再完成变基</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout&lt;分支名字&gt;</span><br><span class="line"></span><br><span class="line">git rebase  master</span><br></pre></td></tr></table></figure>

<p>使用快进(Fast-Forward)将分支合并到master</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout&lt;分支名字&gt;</span><br><span class="line"></span><br><span class="line">git merge --ff-only master</span><br></pre></td></tr></table></figure>

<p>中止这一次提交的合并(当遇到冲突的时候)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save &quot;&lt;可以输入一个信息&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>将未提交的修改暂存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save &quot;&lt;可以输入一个信息&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>将上一个暂存的修改恢复并从暂存列表中删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<p>签出指定的提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout&lt;提交的hash&gt;</span><br></pre></td></tr></table></figure>

<p>撤销旧提交</p>
<p>注：Revert并不会修改就提交历史，而是在工作树种生成与之前提交相反的修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert&lt;旧提交的hash&gt;</span><br></pre></td></tr></table></figure>

<p>利用reflog查看本地仓库中所有的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="cl0j84jv6002704vh3k57f2yt" data-title="Git常用命令" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线程池" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:12:18.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基于线程池的方式"><a href="#基于线程池的方式" class="headerlink" title="基于线程池的方式"></a>基于线程池的方式</h2><p>​        线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池 </span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">// 提交多个线程任务，并执行 </span></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running ..&quot;</span>); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">3000</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">              &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="七种线程池"><a href="#七种线程池" class="headerlink" title="七种线程池"></a>七种线程池</h2><p>Java里面线程池的顶级接口是Executor，但严格意义上将Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池是Executor Service。</p>
<p><strong>newSingleThreadExceutor</strong></p>
<p>它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以保证了所有任务都是被顺序执行的，最多会有一个任务处于活动状态。并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</p>
<p><strong>newCachedThreadPool</strong><br>他是用来处理大量短时间工作任务的线程池，具有几个鲜明的特点：它会查实缓存线程并重用，当无缓存线程时，就会创建新的工作线程；如果线程闲置时间超过60秒，则被终止并移除缓存；长时间闲置的，这种线程不会消耗什么资源。其内部使用SynchronousQueue队列。</p>
<p><strong>newFixedThreadPool</strong><br>重用指定数目(nThreads)的线程，背后使用是无界的工作队列，任何时候最多有nThreads个线程时活动的。这意味着如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目。</p>
<p><strong>newScheduledThreadPool</strong><br>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(<span class="number">3</span>); scheduledThreadPool.schedule(newRunnable()&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;延迟三秒&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123; <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;延迟 1 秒后每三秒执行一次&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p><strong>newSingleThreadExecutor</strong></p>
<p>创建单线程，返回SecheduledExecutorService，可以进行定时或者周期性的工作调度。Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后(或发生异常时）重新启动一个线程来替代原来的线程继续执行下去!</p>
<p><strong>newWorkStealingPool</strong></p>
<p>Java8加入的创建方法。内部会构建ForkJoinPool,利用Work-Stealing算法，并行的处理任务，不保障处理顺序</p>
<p><strong>ThreadPollExecutor</strong></p>
<p>是最原始的线程池创建方法。也是最重要的</p>
<h1 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h1><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务</p>
<p>SHUTDOWN：不接受新的任务，但是会处理等待队列中的任务</p>
<p>STOP：不接受新的任务，不会处理等待队列中的任务，中断正在执行任务的线程</p>
<p>TIDYING：所有任务都被销毁，workCount为0，线程池的状态在装换为TIDYING状态时，会被执行钩子方法terminated()。</p>
<p>TERMINATED：terminated()方法结束后，线程池的状态就是这个。</p>
<h1 id="线程池中的submit-和execute-方法有什么区别"><a href="#线程池中的submit-和execute-方法有什么区别" class="headerlink" title="线程池中的submit()和execute()方法有什么区别"></a>线程池中的submit()和execute()方法有什么区别</h1><p>execute()：只能执行Runnable类型的任务</p>
<p>submit()：可以执行runnable和Callable类型的任务</p>
<p>Callable类型的任务可以获得执行的返回值，Runnable执行无返回值</p>
<h1 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h1><p>方法一：使用安全类，比如Java.util.concurrent类</p>
<p>方法二：使用自动锁synchronized。</p>
<p>方法三：使用手动锁Lock。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" data-id="cl0j84jxn00b904vh38l65g5d" data-title="线程池" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-39. 类的加载机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/39.%20%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T06:48:06.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/39.%20%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">39类的加载机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="谈谈类的加载机制"><a href="#谈谈类的加载机制" class="headerlink" title="谈谈类的加载机制"></a>谈谈类的加载机制</h1><p><strong>本文转载</strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59073186">https://zhuanlan.zhihu.com/p/59073186</a></p>
<p><strong>面试场景：</strong></p>
<p>面试官第一问：</p>
<blockquote>
<p>请问，我现在编写一个类，类全名如下：java.lang.String,<br>我们知道JDK也给我们听过了一个java.lang.String，<br>那么，我们编写的这个String类能否替换到JDK默认提供，也就是说程序实际运行的时候，会加载我们的String还是JDK的String？为什么？</p>
</blockquote>
<p>如果，你无法确定？那么第二问：</p>
<blockquote>
<p>了解类的加载机制吗？知道JDK的类加载器吗？双亲委托机制说说看</p>
</blockquote>
<p>如果，你还不了解，那么我们聊聊今天的天气吧！</p>
<p><strong>1，首先，什么是类的加载机制？</strong></p>
<blockquote>
<p>JVM使用Java类的流程如下：<br>1，Java源文件—-编译—-&gt;class文件<br>2，类加载器ClassLoader会读取这个.class文件，并将其转化为java.lang.Class的实例。有了该实例，JVM就可以使用他来创建对象，调用方法等操作了。<br>那么ClassLoader是以一种什么机制来加载Class的？<br>这就是我们要谈的类的加载机制！</p>
</blockquote>
<p><strong>2，搞清楚这个问题，首先要知道，我们用到的Class文件都有哪些来源？</strong></p>
<blockquote>
<p>1，Java内部自带的核心类，位于$JAVA_HOME&#x2F;jre&#x2F;lib，其中最著名的莫过于rt.jar<br>2，Java的扩展类，位于$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录下<br>3，我们自己开发的类或项目开发用到的第三方jar包，位于我们项目的目录下，比如WEB-INF&#x2F;lib目录</p>
</blockquote>
<p><strong>3，那么，针对这些Class，JDK是怎么分工的？谁来加载这些Class？</strong></p>
<blockquote>
<p>针对不同的来源，Java分了不同的ClassLoader来加载<br>1，Java核心类，这些Java运行的基础类，由一个名为BootstrapClassLoader加载器负责加载。这个类加载器被称为“根加载器或引导加载器”<br>注意：BootstrapClassLoader不继承ClassLoader，是由JVM内部实现。法力无边，所以你通过java程序访问不到，得到的是null。<br>2，Java扩展类，是由ExtClassLoader负责加载，被称为“扩展类加载器”。<br>3，项目中编写的类，是由AppClassLoader来负责加载，被称为“系统类加载器”。</p>
</blockquote>
<p><strong>4， 那凭什么，我就知道这个类应该由老大BootStrapClassLoader来加载？</strong></p>
<p><strong>这里面就要基于双亲委托机制？</strong></p>
<blockquote>
<p>所谓双亲委托机制，就是加载一个类，会先获取到一个系统类加载器AppClassLoader的实例，然后往上层层请求，先由BootstarpClassLoader去加载，<br>如果BootStrapClassLoader发现没有，再下发给ExtClassLoader去加载，还是没有，才由AppClassLoader去加载。<br>如果还是没有，则报错</p>
</blockquote>
<p><strong>5，所以，上述问题的答案你清楚了吗？</strong></p>
<blockquote>
<p>JDK提供java.lang.String类，默认在rt.jar这个包里面，所以，默认会由BootstarpClassLoader加载，<br>所以，我们自己编写的java.lang.String，都没有机会被加载到</p>
</blockquote>
<p><strong>6，给两段程序看看，类加载器的关系</strong></p>
<p>案例1：创建一个自己的类，然后打印其类加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.huangguizhao.thread.client.Programmer&quot;</span>);</span><br><span class="line">		<span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> clazz.getClassLoader();</span><br><span class="line">		System.out.println(classLoader.getClass().getSimpleName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例2：打印其双亲类加载器信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(classLoader.getParent() != <span class="literal">null</span>)&#123;</span><br><span class="line">       classLoader = classLoader.getParent();</span><br><span class="line">       System.out.println(<span class="string">&quot;--&gt;&quot;</span>+classLoader.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/39.%20%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" data-id="cl0j84jv2001q04vh59010dk7" data-title="39类的加载机制" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-37. 谈谈你对ThreadLocal的理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/37.%20%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T06:41:33.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/37.%20%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/">37谈谈你对ThreadLocal的理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="37谈谈你对ThreadLocal的理解"><a href="#37谈谈你对ThreadLocal的理解" class="headerlink" title="37谈谈你对ThreadLocal的理解"></a>37谈谈你对ThreadLocal的理解</h1><p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路，使用这个工具类可以很简洁地编写出优美的多线程程序。</p>
<p>ThreadLocal解决了什么问题？内部源码是怎么样的？</p>
<p>作用：</p>
<p>​        当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。从线程的角度看，目标变量就像是线程的本地变量，这也是类名中“Local”所要表达的意思。经典使用场景是数据库连接和session管理等。</p>
<p>​        为ThreadLocal是线程局部变量，而线程局部变量在多线程场景中应用广泛。以JDBC Connection 为例子简述一下ThreadLocal的应用场景。JDBC Connection 类是非线程安全的，两个线程不能安全地共享一个 Connection：</p>
<blockquote>
<p>当线程A获取到Connection，开启一个事务，正在在执行事务，但是未结束。此时，线程B也获取到Connection，它发送了一些SQL操作，这些SQL操作将会被数据库归入线程A的事务当中被执行，这就造成了张冠李戴。</p>
</blockquote>
<p>如果采用线程局部变量的形式，此时Connection为线程A和线程B的局部变量，本质上就是开启了两个Connection，从而可以使线程A和线程B可以相互独立</p>
<p><strong>第一个问题：证明ThreadLocal为每个线程创建一个变量副本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//开启多个线程来执行任务</span></span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                threadLocal.set(System.currentTimeMillis());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;&quot;</span>+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出的结果是不同的</p>
<p><strong>问题二：为什么可以给每个线程保存一个不同的副本</strong></p>
<p>那我们来分析源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//2，获取到当前线程对应的map</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.以threadLocal为key，获取到entry</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">//4.获取对应entry的value，就是我们存放到里面的变量的副本</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要结合set方法的源码分析，才可以更好理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(System.currentTimeMillis());</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; </span><br><span class="line">        <span class="comment">//1.获取到当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//2.获取当前线程对应的map</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//3.往map存放一个键值对</span></span><br><span class="line">            <span class="comment">//this ThreadLocal</span></span><br><span class="line">            <span class="comment">//value 保存的副本</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以，我们得到结论：</p>
<p>每个线程都会有对应的map，map来保存键值对。</p>
<p><strong>问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？</strong></p>
<p>比如：hibernate管理session，mybatis管理sqlsession，其内部都是采用ThreadLocal来实现的。</p>
<p>前提知识：不管是什么框架，最本质的操作都是基于JDBC，当我们需要跟数据库打交道的时候，都需要有一个connection。</p>
<p>那么，当我们需要在业务层实现事务控制时，该如何达到这个效果？</p>
<p>我们构建下代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//省略接口的声明</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">LogDao</span> <span class="variable">logDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogDao</span>();</span><br><span class="line"><span class="comment">//事务的边界放在业务层</span></span><br><span class="line">    <span class="comment">//JDBC的封装，connection</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">        logDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao add。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//创建connection对象</span></span><br><span class="line">        <span class="comment">//connection.commit();</span></span><br><span class="line">        <span class="comment">//connection.rollback();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LogDao add。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//创建connection对象</span></span><br><span class="line">        <span class="comment">//connection.commit();</span></span><br><span class="line">        <span class="comment">//connection.rollback();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果代码按上面的方式来管理connection，我们还可以保证service的事务控制吗？</p>
<p>这是不行的，假设第一个dao操作成功了，那么它就提交事务了，而第二个dao操作失败了，它回滚了事务，但不会影响到第一个dao的事务，因为上面这么写是两个独立的事务</p>
<p>那么怎么解决。</p>
<p>上面的根源就是两个dao操作的是不同的connection</p>
<p>所以，我们保证是同个connection即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务的边界放在业务层</span></span><br><span class="line"><span class="comment">//JDBC的封装，connection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connection</span>();</span><br><span class="line">    userDao.add(connection);</span><br><span class="line">    logDao.add(connection);</span><br><span class="line">&#125;</span><br><span class="line">上面的方式代码不够优雅</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionUtils</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="literal">null</span>)&#123;</span><br><span class="line">            connection = <span class="keyword">new</span> <span class="title class_">Connection</span>();</span><br><span class="line">            threadLocal.set(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao add。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//创建connection对象</span></span><br><span class="line">        <span class="comment">//connection.commit();</span></span><br><span class="line">        <span class="comment">//connection.rollback();</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtils.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao-&gt;&quot;</span>+connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到此，我们可以保证两个dao操作的是同一个connection递同一个对象，比如connection</p>
<h2 id="第一节：ThreadLocal是什么"><a href="#第一节：ThreadLocal是什么" class="headerlink" title="第一节：ThreadLocal是什么"></a><strong>第一节：ThreadLocal是什么</strong></h2><p>ThreadLocal并不是新生事物，早在JDK 1.2的版本中就已经出现了。JDK 1.2发布于1998年12月，距今已经有22年的历史。JDK 1.2是Java发展史的一座里程碑，涌现了很多开创性的功能，例如本文要说的ThreadLocal。</p>
<p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路，使用这个工具类可以很简洁地编写出优美的多线程程序。但是，ThreadLocal很容易让人望文生义，想当然地认为是一个“本地线程”。其实，ThreadLocal并不是一个Thread，而是Thread的局部变量，所以有人觉得它命名为ThreadLocalVariable更容易让人理解一些。</p>
<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。从线程的角度看，目标变量就像是线程的本地变量，这也是类名中“Local”所要表达的意思。</p>
<p>ThreadLocal是线程局部变量，而线程局部变量在多线程场景中应用广泛。以JDBC Connection 为例子简述一下ThreadLocal的应用场景。JDBC Connection 类是非线程安全的，两个线程不能安全地共享一个 Connection：</p>
<p>当线程A获取到Connection，开启一个事务，正在在执行事务，但是未结束。此时，线程B也获取到Connection，它发送了一些SQL操作，这些SQL操作将会被数据库归入线程A的事务当中被执行，这就造成了张冠李戴。</p>
<p>如果采用线程局部变量的形式，此时Connection为线程A和线程B的局部变量，本质上就是开启了两个Connection，从而可以使线程A和线程B可以相关独立。</p>
<p><strong>线程局部变量</strong></p>
<p>其实，线程局部变量并不是Java的新发明，很多语言在语法层面就提供线程局部变量。下面以C++为例子给大家说明一下线程局部变量的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static generator;//代码1</span><br></pre></td></tr></table></figure>

<p><strong>上述代码1的解释：</strong></p>
<p>（1）generator 是一个静态变量，这个静态变量在任何线程都可以被使用，而且在任何线程里面的值都是固定的。</p>
<p>（2）generator是个生成器，假设它产生的随机数为100，那么所有线程里面的generator都是100。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static thread_local generator;//代码2</span><br></pre></td></tr></table></figure>

<p><strong>上述代码2的解释：</strong></p>
<p>（1）generator 是一个静态变量，这个静态变量在任何线程都可以被使用，但是由于其被thread_local所修饰，所以不同线程的值是不同的。</p>
<p>（2）generator是个生成器，在某个线程里面generator可能是100，而在另外一个线程里面可能是99，在第三个线程里面可能是98……，总之不同线程的值是不同的。</p>
<h2 id="第二节：ThreadLocal的用法介绍"><a href="#第二节：ThreadLocal的用法介绍" class="headerlink" title="第二节：ThreadLocal的用法介绍"></a><strong>第二节：ThreadLocal的用法介绍</strong></h2><p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void set(Object value)</span><br></pre></td></tr></table></figure>

<p>代码解释：设置当前线程的线程局部变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object get()</span><br></pre></td></tr></table></figure>

<p>代码解释：该方法返回当前线程所对应的线程局部变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void remove()</span><br></pre></td></tr></table></figure>

<p>代码解释： 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected Object initialValue()</span><br></pre></td></tr></table></figure>

<p>代码解释：返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。如果有人心急则吃不了热豆腐，在还没有set的情况下，调用get则返回null。</p>
<p><strong>需要注意的是：</strong>在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal <T>。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</p>
<p>关于Object和T的区别：Object是个根类，是个真实存在的类；T是个占位符，表示某个具体的类，仅在编译器有效，最终会被擦除用Object代替。</p>
<h2 id="第三节：ThreadLocal的实现原理"><a href="#第三节：ThreadLocal的实现原理" class="headerlink" title="第三节：ThreadLocal的实现原理"></a><strong>第三节：ThreadLocal的实现原理</strong></h2><p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadLocal</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Thread, Object&gt; valueMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object newValue)</span></span><br><span class="line">	&#123;</span><br><span class="line">		valueMap.put(Thread.currentThread(), newValue);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">		<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> valueMap.get(currentThread);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (o == <span class="literal">null</span> &amp;&amp; !valueMap.containsKey(currentThread))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			o = initialValue();</span><br><span class="line"></span><br><span class="line">			valueMap.put(currentThread, o);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		valueMap.remove(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">initialValue</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//随机休息1000到2000毫秒</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randSleep</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">rand</span> <span class="operator">=</span> random.nextInt(<span class="number">1000</span>) + <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			Thread.sleep(rand);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> <span class="type">MyThreadLocal</span> <span class="variable">myThreadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadLocal</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				randSleep();</span><br><span class="line">				myThreadLocal.set(i);</span><br><span class="line">				<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) myThreadLocal.get();</span><br><span class="line">				System.out.println(<span class="string">&quot;task1:&quot;</span> + num);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				randSleep();</span><br><span class="line">				myThreadLocal.set(i);</span><br><span class="line">				<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) myThreadLocal.get();</span><br><span class="line">				System.out.println(<span class="string">&quot;task2:&quot;</span> + num);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task1).start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task2).start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第四节：-Thread同步机制的比较"><a href="#第四节：-Thread同步机制的比较" class="headerlink" title="第四节： Thread同步机制的比较"></a><strong>第四节： Thread同步机制的比较</strong></h2><p>ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
<p>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<p>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal<T>版本。</p>
<p>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/16/37.%20%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="cl0j84jv0001h04vh66tz3oad" data-title="37谈谈你对ThreadLocal的理解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/18/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/concurrency/">concurrency</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/open-source/">open-source</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JVM/" rel="tag">Java JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/" rel="tag">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">Java、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E9%A1%B9%E7%9B%AE/" rel="tag">Java项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">MySql、面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" rel="tag">Redis、面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Java/" rel="tag">Spring Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E3%80%81blog/" rel="tag">hexo、blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm-memory-management/" rel="tag">jvm-memory-management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty-source/" rel="tag">netty-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-intro/" rel="tag">spring-aop-intro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop-source/" rel="tag">spring-aop-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" rel="tag">循环依赖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/Java/" style="font-size: 15.56px;">Java</a> <a href="/tags/Java-JVM/" style="font-size: 18.89px;">Java JVM</a> <a href="/tags/Java-Spring/" style="font-size: 13.33px;">Java Spring</a> <a href="/tags/Java%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 17.78px;">Java、面试题</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">Java数据结构</a> <a href="/tags/Java%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">Java项目</a> <a href="/tags/MySql/" style="font-size: 20px;">MySql</a> <a href="/tags/MySql%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.11px;">MySql、面试题</a> <a href="/tags/Redis/" style="font-size: 14.44px;">Redis</a> <a href="/tags/Redis%E3%80%81%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Redis、面试</a> <a href="/tags/Spring-Java/" style="font-size: 13.33px;">Spring Java</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/hexo%E3%80%81blog/" style="font-size: 10px;">hexo、blog</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jvm-memory-management/" style="font-size: 10px;">jvm-memory-management</a> <a href="/tags/netty-source/" style="font-size: 11.11px;">netty-source</a> <a href="/tags/redis/" style="font-size: 17.78px;">redis</a> <a href="/tags/spring-aop-intro/" style="font-size: 10px;">spring-aop-intro</a> <a href="/tags/spring-aop-source/" style="font-size: 10px;">spring-aop-source</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" style="font-size: 10px;">循环依赖</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">数据结构</a> <a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/09/update%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97%EF%BC%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/Redis_hot/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM类加载机制</a>
          </li>
        
          <li>
            <a href="/2022/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Lee yunbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>